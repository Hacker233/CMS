
93fdcbe2bc2f63043c16304a14fa732d713c8cea	{"key":"{\"uglify-es\":\"3.3.9\",\"uglifyjs-webpack-plugin\":\"1.1.6\",\"uglifyjs-webpack-plugin-options\":{\"test\":/\\.js$/i,\"warningsFilter\":function () {\n      return true;\n    },\"extractComments\":false,\"sourceMap\":false,\"cache\":true,\"parallel\":true,\"uglifyOptions\":{\"output\":{\"comments\":false}}},\"path\":\"\\u002FUsers\\u002Fsunxin\\u002Fnew\\u002FClient\\u002Fdist\\u002Flogin.js\",\"input\":\"webpackJsonp([0],[\\n\\u002F* 0 *\\u002F,\\n\\u002F* 1 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F* WEBPACK VAR INJECTION *\\u002F(function(Vue) {\\u002F**\\r\\n * Created by sunxin on 2017\\u002F2\\u002F16.\\r\\n *\\u002F\\r\\nVue.use({\\r\\n    install (Vue, options) {\\r\\n        Vue.prototype.$remote=global.remote\\r\\n        Vue.prototype.$apiLogin = global.api;\\r\\n    }\\r\\n});\\r\\n\\r\\ndocument.body.ondrop = function (event) {\\r\\n    event.preventDefault();\\r\\n    event.stopPropagation();\\r\\n}\\r\\n\\r\\nvar $={};\\r\\n$.err=function (msg) {\\r\\n    if(typeof(msg)==\\\"object\\\")\\r\\n    {\\r\\n        $.tip(msg.message,0);\\r\\n        console.log(msg.message)\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        $.tip(msg,0);\\r\\n        console.log(msg)\\r\\n    }\\r\\n}\\r\\n$.ready = function (callback) {\\r\\n    if (document.addEventListener) {\\r\\n        document.addEventListener('DOMContentLoaded', function () {\\r\\n            document.removeEventListener('DOMContentLoaded', arguments.callee, false);\\r\\n            callback();\\r\\n        }, false)\\r\\n    }\\r\\n    else if (document.attachEvent) {\\r\\n        document.attachEvent('onreadystatechange', function () {\\r\\n            if (document.readyState == \\\"complete\\\") {\\r\\n                document.detachEvent(\\\"onreadystatechange\\\", arguments.callee);\\r\\n                callback();\\r\\n            }\\r\\n        })\\r\\n    }\\r\\n    else if (document.lastChild == document.body) {\\r\\n        callback();\\r\\n    }\\r\\n}\\r\\n\\r\\n$.trim=function (str) {\\r\\n    return str.replace(\\u002F(^\\\\s*)|(\\\\s*$)\\u002Fg, \\\"\\\");\\r\\n}\\r\\n\\r\\n$.clone=function(o){\\r\\n    var k, ret= o, b;\\r\\n    if(o && ((b = (o instanceof Array)) || o instanceof Object)) {\\r\\n        ret = b ? [] : {};\\r\\n        for(k in o){\\r\\n            if(o.hasOwnProperty(k)){\\r\\n                ret[k] = arguments.callee(o[k]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return ret;\\r\\n}\\r\\n\\r\\n$.addClass=function (ele,name) {\\r\\n    if(ele.className==\\\"\\\")\\r\\n    {\\r\\n        ele.className=name;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        ele.className+=\\\" \\\"+name;\\r\\n    }\\r\\n}\\r\\n\\r\\n$.removeClass=function (ele,name) {\\r\\n    var reg=new RegExp(name+\\\"|\\\\\\\\s+\\\"+name+\\\"|\\\"+name+\\\"\\\\\\\\s+\\\",\\\"gi\\\")\\r\\n    ele.className=ele.className.replace(reg,\\\"\\\");\\r\\n}\\r\\n\\r\\n$.addEventListener=function (ele,ev,fn) {\\r\\n    var arr=ev.split(\\\" \\\");\\r\\n    arr.forEach(function (obj) {\\r\\n        if(ele.attachEvent)\\r\\n        {\\r\\n            ele.attachEvent(\\\"on\\\" + obj,fn);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            ele.addEventListener(obj,fn,false);\\r\\n        }\\r\\n    })\\r\\n}\\r\\n\\r\\n$.removeEventListener=function (ele,ev,fn) {\\r\\n    var arr=ev.split(\\\" \\\");\\r\\n    arr.forEach(function (obj) {\\r\\n        if(ele.detachEvent)\\r\\n        {\\r\\n            ele.detachEvent(\\\"on\\\" + obj,fn);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            ele.removeEventListener(obj,fn);\\r\\n        }\\r\\n    })\\r\\n\\r\\n}\\r\\n\\r\\n$.once=function (ele,ev,fn) {\\r\\n    $.addEventListener(ele,ev,function () {\\r\\n        fn.apply(this,arguments);\\r\\n        $.removeEventListener(ele,ev,arguments.callee);\\r\\n    })\\r\\n}\\r\\n\\r\\n$.startLoading=function (scope) {\\r\\n    var arr=[\\\"不忘初心，方得始终\\\",\\\"愿每一个程序员有情人终成眷属\\\",\\\"嘿咻嘿咻拼命加载中！\\\"];\\r\\n    if(document.getElementById(\\\"SBDocStartLoading\\\"))\\r\\n    {\\r\\n        return;\\r\\n    }\\r\\n    var ele=document.createElement(\\\"div\\\");\\r\\n    ele.id=\\\"SBDocStartLoading\\\";\\r\\n    ele.style.position=\\\"absolute\\\";\\r\\n    ele.style.zIndex=10000;\\r\\n    ele.style.backgroundColor=\\\"white\\\";\\r\\n    var ele1;\\r\\n    if(scope==1)\\r\\n    {\\r\\n        ele1=document.getElementById(\\\"showContent\\\");\\r\\n        ele.style.left=\\\"100px\\\";\\r\\n        ele.style.top=\\\"60px\\\";\\r\\n        ele.style.width=\\\"calc(100vw - 100px)\\\";\\r\\n        ele.style.height=\\\"calc(100vh - 60px)\\\";\\r\\n    }\\r\\n    else if(scope==2)\\r\\n    {\\r\\n        ele1=document.getElementById(\\\"interfaceContent\\\");\\r\\n        var rect=ele1.getBoundingClientRect();\\r\\n        ele.style.left=rect.left+\\\"px\\\";\\r\\n        ele.style.top=rect.top+40+\\\"px\\\";\\r\\n        ele.style.width=rect.width+\\\"px\\\";\\r\\n        ele.style.height=\\\"calc(100vh - 155px)\\\";\\r\\n    }\\r\\n    else if(scope==3)\\r\\n    {\\r\\n        ele1=document.getElementById(\\\"testInfoContent\\\");\\r\\n        var rect=ele1.getBoundingClientRect();\\r\\n        ele.style.left=rect.left+\\\"px\\\";\\r\\n        ele.style.top=rect.top+40+\\\"px\\\";\\r\\n        ele.style.width=rect.width+\\\"px\\\";\\r\\n        ele.style.height=\\\"calc(100vh - 155px)\\\";\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        ele.style.left=0;\\r\\n        ele.style.top=0;\\r\\n        ele.style.width=\\\"100%\\\";\\r\\n        ele.style.height=document.documentElement.clientHeight+\\\"px\\\";\\r\\n        ele.style.backgroundColor=\\\"rgb(45,45,45)\\\"\\r\\n    }\\r\\n    ele.innerHTML='\\u003Cdiv style=\\\"text-align: center;margin-top: '+(document.documentElement.clientHeight\\u002F2-100)+'px\\\"\\u003E\\u003Cdiv class=\\\"fa fa-spinner fa-spin\\\" style=\\\"color: #50bfff;font-size: 30px;\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv style=\\\"margin-top: 30px;color: gray;font-size: 15px\\\"\\u003E'+(ele1?arr[parseInt(Math.random()*arr.length)]:\\\"DOClever,做最好的接口管理平台\\\")+'\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E'\\r\\n    document.body.appendChild(ele);\\r\\n}\\r\\n\\r\\n$.stopLoading=function () {\\r\\n    setTimeout(function () {\\r\\n        var ele=document.getElementById(\\\"SBDocStartLoading\\\");\\r\\n        if(ele)\\r\\n        {\\r\\n            $.addClass(ele,\\\"animated fadeOut\\\");\\r\\n            $.once(ele,\\\"webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend\\\",function () {\\r\\n                var ele=document.getElementById(\\\"SBDocStartLoading\\\");\\r\\n                if(ele)\\r\\n                {\\r\\n                    ele.parentNode.removeChild(ele);\\r\\n                }\\r\\n            })\\r\\n        }\\r\\n    },100);\\r\\n}\\r\\n\\r\\n$.animate=function (ele,style) {\\r\\n    if(ele)\\r\\n    {\\r\\n        style=\\\"animated \\\"+style;\\r\\n        $.addClass(ele,style);\\r\\n        $.once(ele,\\\"webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend\\\",function () {\\r\\n            $.removeClass(ele,style);\\r\\n        })\\r\\n    }\\r\\n}\\r\\n\\r\\n$.query=function (str,ele) {\\r\\n    if(ele)\\r\\n    {\\r\\n        return ele.querySelector(str);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return document.querySelector(str);\\r\\n    }\\r\\n}\\r\\n\\r\\n$.queryAll=function (str,ele) {\\r\\n    if(ele)\\r\\n    {\\r\\n        return ele.querySelectorAll(str);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return document.querySelectorAll(str);\\r\\n    }\\r\\n}\\r\\n\\r\\n$.confirm=function (title,funcOk,funcCancel) {\\r\\n    return new Promise(function (resolve,reject) {\\r\\n        Vue.prototype.$confirm(title, 'DOClever', {\\r\\n            confirmButtonText: '确定',\\r\\n            cancelButtonText: '取消',\\r\\n            type: 'warning'\\r\\n        }).then(function () {\\r\\n            if(funcOk)\\r\\n            {\\r\\n                funcOk();\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                resolve(true);\\r\\n            }\\r\\n        }).catch(function () {\\r\\n            if(funcCancel)\\r\\n            {\\r\\n                funcCancel();\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                resolve(false);\\r\\n            }\\r\\n        })\\r\\n    })\\r\\n}\\r\\n\\r\\n$.tip=function (content,bOk) {\\r\\n    if(bOk==1)\\r\\n    {\\r\\n        Vue.prototype.$message.success(content);\\r\\n    }\\r\\n    else if(bOk==0)\\r\\n    {\\r\\n        Vue.prototype.$message.error(content);\\r\\n    }\\r\\n    else if(bOk==2)\\r\\n    {\\r\\n        Vue.prototype.$message.warning(content);\\r\\n    }\\r\\n    else if(bOk==3)\\r\\n    {\\r\\n        return Vue.prototype.$message({\\r\\n            dangerouslyUseHTMLString: true,\\r\\n            message: `\\u003Ci class='el-icon-loading'\\u003E\\u003C\\u002Fi\\u003E${content}`,\\r\\n            duration:0\\r\\n        })\\r\\n    }\\r\\n}\\r\\n\\r\\n$.loading=function (content) {\\r\\n    return $.tip(content,3);\\r\\n}\\r\\n\\r\\n$.notify=function (content,bOk) {\\r\\n    if(bOk)\\r\\n    {\\r\\n        Vue.prototype.$notify({\\r\\n            title: content,\\r\\n            type: 'success',\\r\\n            duration:1000\\r\\n        });\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        Vue.prototype.$notify({\\r\\n            title: content,\\r\\n            type: 'error',\\r\\n            duration:1000\\r\\n        });\\r\\n    }\\r\\n}\\r\\n\\r\\n$.input=function (title,func,defaultValue) {\\r\\n    Vue.prototype.$prompt(title, 'DOClever', {\\r\\n        confirmButtonText: '确定',\\r\\n        cancelButtonText: '取消',\\r\\n        inputValidator:function (value) {\\r\\n            if(value===\\\"\\\")\\r\\n            {\\r\\n                return \\\"请输入内容\\\"\\r\\n            }\\r\\n        },\\r\\n        inputValue:defaultValue?defaultValue:\\\"\\\"\\r\\n    }).then(function (value) {\\r\\n        if(func)\\r\\n        {\\r\\n            func(value);\\r\\n        }\\r\\n    }).catch(function () {\\r\\n\\r\\n    });\\r\\n}\\r\\n\\r\\n$.showMenu=function (vue,eleInput,data) {\\r\\n    var ele=document.createElement(\\\"div\\\");\\r\\n    vue.$el.appendChild(ele);\\r\\n    var xy=$.getCaretCoordinates(eleInput,eleInput.selectionStart);\\r\\n    var bound=eleInput.getBoundingClientRect();\\r\\n    var self = vue;\\r\\n    var Child = Vue.extend(__webpack_require__(14));\\r\\n    var child = new Child({\\r\\n        el: ele,\\r\\n        parent: self,\\r\\n        propsData:{\\r\\n            source:data\\r\\n        }\\r\\n    });\\r\\n    child.$on(\\\"level\\\",function (level) {\\r\\n        var ele=child.$el;\\r\\n        var width=level*150;\\r\\n        if(bound.left+width\\u003Edocument.documentElement.clientWidth)\\r\\n        {\\r\\n            ele.style.left=document.documentElement.clientWidth-width+\\\"px\\\";\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            ele.style.left=xy.left+bound.left+\\\"px\\\";\\r\\n        }\\r\\n    })\\r\\n    child.$el.style.left=xy.left+bound.left+\\\"px\\\";\\r\\n    if(xy.top+bound.top+xy.height+210\\u003Edocument.documentElement.clientHeight)\\r\\n    {\\r\\n        child.$el.style.top=xy.top+bound.top-210+\\\"px\\\";\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        child.$el.style.top=xy.top+bound.top+xy.height+10+\\\"px\\\";\\r\\n    }\\r\\n    return child;\\r\\n}\\r\\n\\r\\n$.inputMul=function (vue,placeholder,func,hudRemove,content) {\\r\\n    var ele=document.createElement(\\\"div\\\");\\r\\n    vue.$el.appendChild(ele);\\r\\n    var self = vue;\\r\\n    var Child = Vue.extend(__webpack_require__(22));\\r\\n    var child = new Child({\\r\\n        el: ele,\\r\\n        parent: self,\\r\\n        propsData:{\\r\\n            placeholder:placeholder,\\r\\n            hudremove:hudRemove,\\r\\n            source:content\\r\\n        }\\r\\n    });\\r\\n    child.$data.showDialog=true;\\r\\n    child.$refs.box.$on(\\\"close\\\",function () {\\r\\n        child.$el.parentNode.removeChild(child.$el);\\r\\n    })\\r\\n    child.$on(\\\"save\\\",function (val) {\\r\\n        if(func)\\r\\n        {\\r\\n            var ret=func(val);\\r\\n            if(ret)\\r\\n            {\\r\\n                child.$data.showDialog=false;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            child.$data.showDialog=false;\\r\\n        }\\r\\n    })\\r\\n    return child;\\r\\n}\\r\\n\\r\\n$.inputTwo=function (vue,labelTitle,labelContent,placeholderTitle,placeholderContent,textTitle,textContent,func,hudRemove) {\\r\\n    var ele=document.createElement(\\\"div\\\");\\r\\n    vue.$el.appendChild(ele);\\r\\n    var self = vue;\\r\\n    var Child = Vue.extend(__webpack_require__(26));\\r\\n    var child = new Child({\\r\\n        el: ele,\\r\\n        parent: self,\\r\\n        propsData:{\\r\\n            name1:labelTitle,\\r\\n            name2:labelContent,\\r\\n            placeholder1:placeholderTitle,\\r\\n            placeholder2:placeholderContent,\\r\\n            text1:textTitle,\\r\\n            text2:textContent,\\r\\n            hudremove:hudRemove\\r\\n        }\\r\\n    });\\r\\n    child.$data.showDialog=true;\\r\\n    child.$refs.box.$on(\\\"close\\\",function () {\\r\\n        child.$el.parentNode.removeChild(child.$el);\\r\\n    })\\r\\n    child.$on(\\\"save\\\",function (val1,val2) {\\r\\n        if(func)\\r\\n        {\\r\\n            var ret=func(val1,val2);\\r\\n            if(ret)\\r\\n            {\\r\\n                child.$data.showDialog=false;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            child.$data.showDialog=false;\\r\\n        }\\r\\n    })\\r\\n    return child;\\r\\n}\\r\\n\\r\\nvar hud=null;\\r\\n$.startHud=function (ele) {\\r\\n    if(ele)\\r\\n    {\\r\\n        hud=Vue.prototype.$loading({\\r\\n            target:ele,\\r\\n            background:\\\"white\\\"\\r\\n        })\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        hud=Vue.prototype.$loading({\\r\\n            fullscreen: true\\r\\n        })\\r\\n    }\\r\\n}\\r\\n\\r\\n$.stopHud=function () {\\r\\n    if(hud)\\r\\n    {\\r\\n        hud.close();\\r\\n        hud=null;\\r\\n    }\\r\\n}\\r\\n\\r\\n$.getNowFormatDate=function(fmt,date) {\\r\\n    var date=date || new Date();\\r\\n    var o = {\\r\\n        \\\"M+\\\": date.getMonth() + 1, \\u002F\\u002F月份\\r\\n        \\\"d+\\\": date.getDate(), \\u002F\\u002F日\\r\\n        \\\"h+\\\": date.getHours(), \\u002F\\u002F小时\\r\\n        \\\"m+\\\": date.getMinutes(), \\u002F\\u002F分\\r\\n        \\\"s+\\\": date.getSeconds(), \\u002F\\u002F秒\\r\\n        \\\"q+\\\": Math.floor((date.getMonth() + 3) \\u002F 3), \\u002F\\u002F季度\\r\\n        \\\"S\\\": date.getMilliseconds() \\u002F\\u002F毫秒\\r\\n    };\\r\\n    if (\\u002F(y+)\\u002F.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \\\"\\\").substr(4 - RegExp.$1.length));\\r\\n    for (var k in o)\\r\\n        if (new RegExp(\\\"(\\\" + k + \\\")\\\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\\\"00\\\" + o[k]).substr((\\\"\\\" + o[k]).length)));\\r\\n    return fmt;\\r\\n}\\r\\n\\r\\n$.showBox=function (vue,obj,attr) {\\r\\n    var ele=document.createElement(\\\"div\\\");\\r\\n    vue.$el.appendChild(ele);\\r\\n    var self = vue;\\r\\n    var module;\\r\\n    var Child = Vue.extend(obj);\\r\\n    var child = new Child({\\r\\n        el: ele,\\r\\n        parent: self,\\r\\n        propsData:attr?attr:null\\r\\n    });\\r\\n    child.$data.showDialog=true;\\r\\n    child.$refs.box.$on(\\\"close\\\",function () {\\r\\n        child.$el.parentNode.removeChild(child.$el);\\r\\n        child.$destroy();\\r\\n    })\\r\\n    return child;\\r\\n}\\r\\n\\r\\n$.param=function (obj,bKey) {\\r\\n    var arr=[];\\r\\n    for(var key in obj)\\r\\n    {\\r\\n        arr.push((bKey?encodeURIComponent(key):key)+\\\"=\\\"+encodeURIComponent(obj[key]));\\r\\n    }\\r\\n    return arr.join(\\\"&\\\");\\r\\n}\\r\\n\\r\\n$.inArr=function (str,arr) {\\r\\n    for(var i=0;i\\u003Carr.length;i++)\\r\\n    {\\r\\n        if(str.toLowerCase()==arr[i].toLowerCase())\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\n$.parseURL=function(url) {\\r\\n    var a = document.createElement('a');\\r\\n    a.href = url;\\r\\n    return {\\r\\n        source: url,\\r\\n        protocol: a.protocol.replace(':',''),\\r\\n        host: a.hostname,\\r\\n        port: a.port,\\r\\n        query: a.search,\\r\\n        params: (function(){\\r\\n            var ret = {},\\r\\n                seg = a.search.replace(\\u002F^\\\\?\\u002F,'').split('&'),\\r\\n                len = seg.length, i = 0, s;\\r\\n            for (;i\\u003Clen;i++) {\\r\\n                if (!seg[i]) { continue; }\\r\\n                s = seg[i].split('=');\\r\\n                ret[s[0]] = s[1];\\r\\n            }\\r\\n            return ret;\\r\\n        })(),\\r\\n        file: (a.pathname.match(\\u002F\\\\\\u002F([^\\\\\\u002F?#]+)$\\u002Fi) || [,''])[1],\\r\\n        hash: a.hash.replace('#',''),\\r\\n        path: a.pathname.replace(\\u002F^([^\\\\\\u002F])\\u002F,'\\u002F$1'),\\r\\n        relative: (a.href.match(\\u002Ftps?:\\\\\\u002F\\\\\\u002F[^\\\\\\u002F]+(.+)\\u002F) || [,''])[1],\\r\\n        segments: a.pathname.replace(\\u002F^\\\\\\u002F\\u002F,'').split('\\u002F')\\r\\n    };\\r\\n}\\r\\n\\r\\n$.createUrlObject=function(obj) {\\r\\n    if (window.createObjectURL != undefined) { \\u002F\\u002F basic\\r\\n        return window.createObjectURL(obj);\\r\\n    }  else if (window.URL != undefined) { \\u002F\\u002F mozilla(firefox)\\r\\n        return window.URL.createObjectURL(obj);\\r\\n    } else if (window.webkitURL != undefined) { \\u002F\\u002F webkit or chrome\\r\\n        return window.webkitURL.createObjectURL(obj);\\r\\n    }\\r\\n}\\r\\n\\r\\n$.revokeUrlObject=function(obj) {\\r\\n    if (window.createObjectURL != undefined) { \\u002F\\u002F basic\\r\\n        return window.revokeObjectURL(obj);\\r\\n    }  else if (window.URL != undefined) { \\u002F\\u002F mozilla(firefox)\\r\\n        return window.URL.revokeObjectURL(obj);\\r\\n    } else if (window.webkitURL != undefined) { \\u002F\\u002F webkit or chrome\\r\\n        return window.webkitURL.revokeObjectURL(obj);\\r\\n    }\\r\\n}\\r\\n\\r\\n$.basePath=function () {\\r\\n    var path=location.href;\\r\\n    var index=path.indexOf(\\\"\\u002Fcontroller\\u002F\\\");\\r\\n    return path.substring(0,index+\\\"\\u002Fcontroller\\u002F\\\".length)\\r\\n}\\r\\n\\r\\n$.rand=function (Min,Max) {\\r\\n    var Range = Max - Min;\\r\\n    var Rand = Math.random();\\r\\n    return(Min + Math.round(Rand * Range));\\r\\n}\\r\\n\\r\\n$.getCaretCoordinates=function (element, position, options) {\\r\\n    var properties = [\\r\\n        'direction',\\r\\n        'boxSizing',\\r\\n        'width',\\r\\n        'height',\\r\\n        'overflowX',\\r\\n        'overflowY',\\r\\n        'borderTopWidth',\\r\\n        'borderRightWidth',\\r\\n        'borderBottomWidth',\\r\\n        'borderLeftWidth',\\r\\n        'borderStyle',\\r\\n        'paddingTop',\\r\\n        'paddingRight',\\r\\n        'paddingBottom',\\r\\n        'paddingLeft',\\r\\n        'fontStyle',\\r\\n        'fontVariant',\\r\\n        'fontWeight',\\r\\n        'fontStretch',\\r\\n        'fontSize',\\r\\n        'fontSizeAdjust',\\r\\n        'lineHeight',\\r\\n        'fontFamily',\\r\\n        'textAlign',\\r\\n        'textTransform',\\r\\n        'textIndent',\\r\\n        'textDecoration',\\r\\n        'letterSpacing',\\r\\n        'wordSpacing',\\r\\n        'tabSize',\\r\\n        'MozTabSize'\\r\\n    ];\\r\\n    var isBrowser = (typeof window !== 'undefined');\\r\\n    var isFirefox = (isBrowser && window.mozInnerScreenX != null);\\r\\n    if (!isBrowser) {\\r\\n        throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\\r\\n    }\\r\\n    var debug = options && options.debug || false;\\r\\n    if (debug) {\\r\\n        var el = document.querySelector('#input-textarea-caret-position-mirror-div');\\r\\n        if (el) el.parentNode.removeChild(el);\\r\\n    }\\r\\n    var div = document.createElement('div');\\r\\n    div.id = 'input-textarea-caret-position-mirror-div';\\r\\n    document.body.appendChild(div);\\r\\n    var style = div.style;\\r\\n    var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  \\u002F\\u002F currentStyle for IE \\u003C 9\\r\\n    var isInput = element.nodeName === 'INPUT';\\r\\n    style.whiteSpace = 'pre-wrap';\\r\\n    if (!isInput)\\r\\n        style.wordWrap = 'break-word';\\r\\n    style.position = 'absolute';\\r\\n    if (!debug)\\r\\n        style.visibility = 'hidden';\\r\\n    properties.forEach(function (prop) {\\r\\n        if (isInput && prop === 'lineHeight') {\\r\\n            style.lineHeight = computed.height;\\r\\n        } else {\\r\\n            style[prop] = computed[prop];\\r\\n        }\\r\\n    });\\r\\n    if (isFirefox) {\\r\\n        if (element.scrollHeight \\u003E parseInt(computed.height))\\r\\n            style.overflowY = 'scroll';\\r\\n    } else {\\r\\n        style.overflow = 'hidden';\\r\\n    }\\r\\n    div.textContent = element.value.substring(0, position);\\r\\n    if (isInput)\\r\\n        div.textContent = div.textContent.replace(\\u002F\\\\s\\u002Fg, '\\\\u00a0');\\r\\n    var span = document.createElement('span');\\r\\n    span.textContent = element.value.substring(position) || '.';  \\u002F\\u002F || because a completely empty faux span doesn't render at all\\r\\n    div.appendChild(span);\\r\\n    var coordinates = {\\r\\n        top: span.offsetTop + parseInt(computed['borderTopWidth']),\\r\\n        left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\\r\\n        height: parseInt(computed['lineHeight'])\\r\\n    };\\r\\n    if (debug) {\\r\\n        span.style.backgroundColor = '#aaa';\\r\\n    } else {\\r\\n        document.body.removeChild(div);\\r\\n    }\\r\\n    return coordinates;\\r\\n}\\r\\n\\r\\n$.tagReplace=function (str) {\\r\\n    var tagsToReplace = {\\r\\n        '&': '&amp',\\r\\n        '\\u003C': '&lt',\\r\\n        '\\u003E': '&gt'\\r\\n    };\\r\\n    return str.replace(\\u002F[&\\u003C\\u003E]\\u002Fg, function (tag) {\\r\\n        return tagsToReplace[tag] || tag;\\r\\n    });\\r\\n}\\r\\n\\r\\n$.insertTextAtCursor=function (el, text) {\\r\\n    var val = el.value, endIndex, range;\\r\\n    if (typeof el.selectionStart != \\\"undefined\\\" && typeof el.selectionEnd != \\\"undefined\\\") {\\r\\n        endIndex = el.selectionEnd;\\r\\n        el.value = val.slice(0, el.selectionStart) + text + val.slice(endIndex);\\r\\n        el.selectionStart = el.selectionEnd = endIndex + text.length;\\r\\n    } else if (typeof document.selection != \\\"undefined\\\" && typeof document.selection.createRange != \\\"undefined\\\") {\\r\\n        el.focus();\\r\\n        range = document.selection.createRange();\\r\\n        range.collapse(false);\\r\\n        range.text = text;\\r\\n        range.select();\\r\\n    }\\r\\n}\\r\\n\\r\\n;(function(){\\r\\n    var bp = document.createElement('script');\\r\\n    var curProtocol = window.location.protocol.split(':')[0];\\r\\n    if (curProtocol === 'https') {\\r\\n        bp.src = 'https:\\u002F\\u002Fzz.bdstatic.com\\u002Flinksubmit\\u002Fpush.js';\\r\\n    }\\r\\n    else {\\r\\n        bp.src = 'http:\\u002F\\u002Fpush.zhanzhang.baidu.com\\u002Fpush.js';\\r\\n    }\\r\\n    var s = document.getElementsByTagName(\\\"script\\\")[0];\\r\\n    s.parentNode.insertBefore(bp, s);\\r\\n})();\\r\\n\\r\\nmodule.exports=$;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n\\u002F* WEBPACK VAR INJECTION *\\u002F}.call(exports, __webpack_require__(0)))\\n\\n\\u002F***\\u002F }),\\n\\u002F* 2 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"stream\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 3 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nlet url=sessionStorage.getItem(\\\"baseUrl\\\")\\r\\nmodule.exports={\\r\\n    baseUrl:(url && url.startsWith(\\\"http:\\u002F\\u002F\\\"))?url:\\\"http:\\u002F\\u002F\\\"+url,\\r\\n    host:(url && url.startsWith(\\\"http:\\u002F\\u002F\\\"))?url:\\\"http:\\u002F\\u002F\\\"+url,\\r\\n    online:window.debug?\\\"http:\\u002F\\u002Flocalhost:8090\\\":\\\"http:\\u002F\\u002Fdoclever.cn:8090\\\"\\r\\n}\\n\\n\\u002F***\\u002F }),\\n\\u002F* 4 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\n\\u002F\\u002F this module is a runtime utility for cleaner component module output and will\\n\\u002F\\u002F be included in the final webpack user bundle\\n\\nmodule.exports = function normalizeComponent (\\n  rawScriptExports,\\n  compiledTemplate,\\n  scopeId,\\n  cssModules\\n) {\\n  var esModule\\n  var scriptExports = rawScriptExports = rawScriptExports || {}\\n\\n  \\u002F\\u002F ES6 modules interop\\n  var type = typeof rawScriptExports.default\\n  if (type === 'object' || type === 'function') {\\n    esModule = rawScriptExports\\n    scriptExports = rawScriptExports.default\\n  }\\n\\n  \\u002F\\u002F Vue.extend constructor export interop\\n  var options = typeof scriptExports === 'function'\\n    ? scriptExports.options\\n    : scriptExports\\n\\n  \\u002F\\u002F render functions\\n  if (compiledTemplate) {\\n    options.render = compiledTemplate.render\\n    options.staticRenderFns = compiledTemplate.staticRenderFns\\n  }\\n\\n  \\u002F\\u002F scopedId\\n  if (scopeId) {\\n    options._scopeId = scopeId\\n  }\\n\\n  \\u002F\\u002F inject cssModules\\n  if (cssModules) {\\n    var computed = Object.create(options.computed || null)\\n    Object.keys(cssModules).forEach(function (key) {\\n      var module = cssModules[key]\\n      computed[key] = function () { return module }\\n    })\\n    options.computed = computed\\n  }\\n\\n  return {\\n    esModule: esModule,\\n    exports: scriptExports,\\n    options: options\\n  }\\n}\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 5 *\\u002F,\\n\\u002F* 6 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F**\\r\\n * Created by sunxin on 2017\\u002F2\\u002F20.\\r\\n *\\u002F\\r\\nvar config=__webpack_require__(3);\\r\\nvar local={};\\r\\nlocal.update=function (data,remember,pass) {\\r\\n    sessionStorage.setItem(\\\"login\\\",\\\"1\\\");\\r\\n    if(data._id!==undefined && data._id!==null)\\r\\n    {\\r\\n        local.set(\\\"id\\\",data._id);\\r\\n        global.api.cookie.set(\\\"docleveruserid\\\",data._id,1);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"id\\\");\\r\\n        global.api.cookie.remove(\\\"docleveruserid\\\");\\r\\n    }\\r\\n    if(data.name!==undefined && data.name!==null)\\r\\n    {\\r\\n        local.set(\\\"name\\\",data.name);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"name\\\");\\r\\n    }\\r\\n    if(data.photo!==undefined && data.photo!==null)\\r\\n    {\\r\\n        local.set(\\\"photo\\\",data.photo);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"photo\\\");\\r\\n    }\\r\\n    if(data.qq!==undefined && data.qq!==null)\\r\\n    {\\r\\n        local.set(\\\"qq\\\",data.qq);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"qq\\\");\\r\\n    }\\r\\n    if(data.email!==undefined && data.email!==null)\\r\\n    {\\r\\n        local.set(\\\"email\\\",data.email);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"email\\\");\\r\\n    }\\r\\n    if(data.phone!==undefined && data.phone!==null)\\r\\n    {\\r\\n        local.set(\\\"phone\\\",data.phone);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"phone\\\");\\r\\n    }\\r\\n    if(data.sex!==undefined && data.sex!==null)\\r\\n    {\\r\\n        local.set(\\\"sex\\\",data.sex);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"sex\\\");\\r\\n    }\\r\\n    if(data.age!==undefined && data.age!==null)\\r\\n    {\\r\\n        local.set(\\\"age\\\",data.age);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"age\\\");\\r\\n    }\\r\\n    if(data.company!==undefined && data.company!==null)\\r\\n    {\\r\\n        local.set(\\\"company\\\",data.company);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"company\\\");\\r\\n    }\\r\\n    if(data.loginCount!==undefined && data.loginCount!==null)\\r\\n    {\\r\\n        local.set(\\\"loginCount\\\",data.loginCount);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"loginCount\\\");\\r\\n    }\\r\\n    if(remember)\\r\\n    {\\r\\n        local.set(\\\"remember\\\",1);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"remember\\\");\\r\\n    }\\r\\n    if(pass)\\r\\n    {\\r\\n        local.set(\\\"password\\\",pass);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        local.remove(\\\"password\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\nlocal.get=function (key) {\\r\\n    return localStorage.getItem(key);\\r\\n}\\r\\n\\r\\nlocal.set=function (key,value) {\\r\\n    localStorage.setItem(key,value);\\r\\n    var event = document.createEvent('HTMLEvents');\\r\\n    event.initEvent(\\\"sessionChange\\\", false, false);\\r\\n    event.key = key;\\r\\n    event.value = value;\\r\\n    document.dispatchEvent(event);\\r\\n}\\r\\n\\r\\nlocal.clear=function () {\\r\\n    localStorage.clear();\\r\\n    var event = document.createEvent('HTMLEvents');\\r\\n    event.initEvent(\\\"sessionClear\\\", false, false);\\r\\n    document.dispatchEvent(event);\\r\\n}\\r\\n\\r\\nlocal.raw=function () {\\r\\n    let obj={};\\r\\n    for(var i=0;i\\u003ClocalStorage.length;i++)\\r\\n    {\\r\\n        obj[localStorage.key(i)]=localStorage.getItem(localStorage.key(i));\\r\\n    }\\r\\n    return obj;\\r\\n}\\r\\n\\r\\nlocal.remove=function (item) {\\r\\n    localStorage.removeItem(item);\\r\\n    var event = document.createEvent('HTMLEvents');\\r\\n    event.initEvent(\\\"sessionRemove\\\", false, false);\\r\\n    event.key = item;\\r\\n    document.dispatchEvent(event);\\r\\n}\\r\\n\\r\\nmodule.exports=local;\\n\\n\\u002F***\\u002F }),\\n\\u002F* 7 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"url\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 8 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\u002F*\\nobject-assign\\n(c) Sindre Sorhus\\n@license MIT\\n*\\u002F\\n\\n\\n\\u002F* eslint-disable no-unused-vars *\\u002F\\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\\n\\nfunction toObject(val) {\\n\\tif (val === null || val === undefined) {\\n\\t\\tthrow new TypeError('Object.assign cannot be called with null or undefined');\\n\\t}\\n\\n\\treturn Object(val);\\n}\\n\\nfunction shouldUseNative() {\\n\\ttry {\\n\\t\\tif (!Object.assign) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\\u002F\\u002F Detect buggy property enumeration order in older V8 versions.\\n\\n\\t\\t\\u002F\\u002F https:\\u002F\\u002Fbugs.chromium.org\\u002Fp\\u002Fv8\\u002Fissues\\u002Fdetail?id=4118\\n\\t\\tvar test1 = new String('abc');  \\u002F\\u002F eslint-disable-line no-new-wrappers\\n\\t\\ttest1[5] = 'de';\\n\\t\\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\\u002F\\u002F https:\\u002F\\u002Fbugs.chromium.org\\u002Fp\\u002Fv8\\u002Fissues\\u002Fdetail?id=3056\\n\\t\\tvar test2 = {};\\n\\t\\tfor (var i = 0; i \\u003C 10; i++) {\\n\\t\\t\\ttest2['_' + String.fromCharCode(i)] = i;\\n\\t\\t}\\n\\t\\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\\n\\t\\t\\treturn test2[n];\\n\\t\\t});\\n\\t\\tif (order2.join('') !== '0123456789') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\\u002F\\u002F https:\\u002F\\u002Fbugs.chromium.org\\u002Fp\\u002Fv8\\u002Fissues\\u002Fdetail?id=3056\\n\\t\\tvar test3 = {};\\n\\t\\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\\n\\t\\t\\ttest3[letter] = letter;\\n\\t\\t});\\n\\t\\tif (Object.keys(Object.assign({}, test3)).join('') !==\\n\\t\\t\\t\\t'abcdefghijklmnopqrst') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t} catch (err) {\\n\\t\\t\\u002F\\u002F We don't expect any of the above to throw, but better to be safe.\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\\n\\tvar from;\\n\\tvar to = toObject(target);\\n\\tvar symbols;\\n\\n\\tfor (var s = 1; s \\u003C arguments.length; s++) {\\n\\t\\tfrom = Object(arguments[s]);\\n\\n\\t\\tfor (var key in from) {\\n\\t\\t\\tif (hasOwnProperty.call(from, key)) {\\n\\t\\t\\t\\tto[key] = from[key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (getOwnPropertySymbols) {\\n\\t\\t\\tsymbols = getOwnPropertySymbols(from);\\n\\t\\t\\tfor (var i = 0; i \\u003C symbols.length; i++) {\\n\\t\\t\\t\\tif (propIsEnumerable.call(from, symbols[i])) {\\n\\t\\t\\t\\t\\tto[symbols[i]] = from[symbols[i]];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn to;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 9 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F Unique ID creation requires a high quality random # generator.  In node.js\\n\\u002F\\u002F this is pretty straight-forward - we use the crypto API.\\n\\nvar crypto = __webpack_require__(59);\\n\\nmodule.exports = function nodeRNG() {\\n  return crypto.randomBytes(16);\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 10 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\n\\u002F**\\n * Convert array of 16 byte values to UUID string format of the form:\\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\\n *\\u002F\\nvar byteToHex = [];\\nfor (var i = 0; i \\u003C 256; ++i) {\\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\\n}\\n\\nfunction bytesToUuid(buf, offset) {\\n  var i = offset || 0;\\n  var bth = byteToHex;\\n  return bth[buf[i++]] + bth[buf[i++]] +\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\n          bth[buf[i++]] + bth[buf[i++]] +\\n          bth[buf[i++]] + bth[buf[i++]] +\\n          bth[buf[i++]] + bth[buf[i++]];\\n}\\n\\nmodule.exports = bytesToUuid;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 11 *\\u002F,\\n\\u002F* 12 *\\u002F,\\n\\u002F* 13 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F* WEBPACK VAR INJECTION *\\u002F(function(Vue, _session, _$, _net) {const db=__webpack_require__(55)\\nconst config=__webpack_require__(3)\\nglobal.rootVue=new Vue({\\n    el:\\\"#app\\\",\\n    data:{\\n        envId:\\\"\\\",\\n        arrEnv:[],\\n        remember:0,\\n        username:\\\"\\\",\\n        password:\\\"\\\",\\n        addPending:false,\\n        showAdd:false,\\n        envEdit:{\\n            name:\\\"\\\",\\n            url:\\\"\\\"\\n        },\\n        objVersion:{},\\n        objRegister:{\\n            username:\\\"\\\",\\n            pwd:\\\"\\\",\\n            pwd1:\\\"\\\",\\n            email:\\\"\\\",\\n            question:\\\"\\\",\\n            answer:\\\"\\\"\\n        },\\n        showRegister:false,\\n        registerPending:false,\\n        member:\\\"\\\",\\n        arrMember:[],\\n        showApplyMember:false,\\n        memberEdit:{\\n            user:\\\"\\\",\\n            pass:\\\"\\\",\\n            name:\\\"\\\",\\n            remark:\\\"\\\"\\n        },\\n        reset:{\\n            question:\\\"\\\",\\n            pwd:\\\"\\\",\\n            pwd1:\\\"\\\",\\n            answer:\\\"\\\",\\n            resetPending:false,\\n            questionPending:false,\\n            step:0,\\n            username:\\\"\\\"\\n        },\\n        showReset:false\\n    },\\n    watch:{\\n        \\\"envId\\\":{\\n            handler:async function () {\\n                if(!this.envId)\\n                {\\n                    return;\\n                }\\n                await this.handleChangeEnvId();\\n            },\\n        }\\n    },\\n    methods:{\\n        handleUrl:function (local) {\\n            let url=\\\"\\\",envId;\\n            if(local)\\n            {\\n                envId=_session.get(\\\"env\\\");\\n            }\\n            else\\n            {\\n                envId=this.envId;\\n            }\\n            if(envId==\\\"doclever.cn\\\")\\n            {\\n                url=window.debug?\\\"http:\\u002F\\u002Flocalhost:8090\\\":\\\"http:\\u002F\\u002Fdoclever.cn:8090\\\"\\n            }\\n            else\\n            {\\n                for(let o of this.arrEnv)\\n                {\\n                    if(o.id==envId)\\n                    {\\n                        url=o.url;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!url.startsWith(\\\"http:\\u002F\\u002F\\\") && !url.startsWith(\\\"https:\\u002F\\u002F\\\"))\\n            {\\n                url=\\\"http:\\u002F\\u002F\\\"+url;\\n            }\\n            return url;\\n        },\\n        handleChangeEnvId:async function (local) {\\n            let tip;\\n            try\\n            {\\n                let url=this.handleUrl(local);\\n                url+=\\\"\\u002Fuser\\u002Fversion\\\";\\n                tip=_$.loading(\\\"正在连接服务器...\\\");\\n                let obj=await _net.get(`${url}`,null,null,null,1,5000);\\n                tip.close()\\n                this.objVersion=obj.data;\\n                _$.tip(\\\"连接成功\\\",1);\\n            }\\n            catch (err)\\n            {\\n                tip.close()\\n                this.objVersion={};\\n                _$.err(\\\"未连接到服务器\\\");\\n            }\\n        },\\n        add:function () {\\n            this.envEdit={\\n                name:\\\"\\\",\\n                url:\\\"\\\",\\n            }\\n            this.showAdd=true\\n        },\\n        addEnv:async function () {\\n            if(!this.envEdit.name)\\n            {\\n                _$.tip(\\\"请填入环境名称\\\",0);\\n                return false;\\n            }\\n            else if(!this.envEdit.url)\\n            {\\n                _$.tip(\\\"请填入服务器地址\\\",0);\\n                return false;\\n            }\\n            this.addPending=true;\\n            let obj;\\n            try\\n            {\\n                obj=await db.addEnv(this.envEdit.id,this.envEdit.name,this.envEdit.url);\\n            }\\n            catch (err)\\n            {\\n                this.addPending=false;\\n                _$.tip(err.msg,0);\\n                return;\\n            }\\n            _$.tip(\\\"修改成功\\\",1);\\n            this.addPending=false;\\n            if(this.envEdit.id)\\n            {\\n                for(let o of this.arrEnv)\\n                {\\n                    if(this.envEdit.id==o.id)\\n                    {\\n                        o.name=this.envEdit.name;\\n                        o.url=this.envEdit.url;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                this.arrEnv.push(obj);\\n            }\\n            this.showAdd=false;\\n        },\\n        removeEnv:async function (item,index) {\\n            let bOk=await _$.confirm(\\\"是否删除该环境\\\");\\n            if(bOk)\\n            {\\n                await db.delEnv(item.id);\\n                await this.$apiLogin.path.delEnv(item.id);\\n                this.arrEnv.splice(index,1);\\n                _$.tip(\\\"删除成功\\\",1);\\n            }\\n        },\\n        editEnv:function (item) {\\n            this.envEdit=_$.clone(item);\\n            this.showAdd=true;\\n        },\\n        refresh:async function () {\\n            await this.handleChangeEnvId();\\n        },\\n        register:async function () {\\n            var _this=this;\\n            if(!this.objRegister.username || !this.objRegister.pwd || !this.objRegister.pwd1 || !this.objRegister.question || !this.objRegister.answer || !this.objRegister.email)\\n            {\\n                this.$message.error(\\\"用户名密码,找回密码问题，找回密码答案,邮箱不能为空\\\");\\n                return;\\n            }\\n            else if(this.objRegister.pwd!=this.objRegister.pwd1)\\n            {\\n                this.$message.error(\\\"两次输入的密码不一致\\\");\\n                return;\\n            }\\n            else if(!(\\u002F^[A-Za-z\\\\d]+([-_.][A-Za-z\\\\d]+)*@([A-Za-z\\\\d]+[-.])+[A-Za-z\\\\d]{2,5}$\\u002F.test(this.objRegister.email)))\\n            {\\n                _$.tip(\\\"邮箱格式不正确\\\",0);\\n                return;\\n            }\\n            this.registerPending=true;\\n            let url=this.handleUrl();\\n            let data=await _net.post(url+\\\"\\u002Fuser\\u002Fsave\\\",{\\n                name:_this.objRegister.username,\\n                password:_this.objRegister.pwd,\\n                question:_this.objRegister.question,\\n                answer:_this.objRegister.answer,\\n                email:_this.objRegister.email\\n            },null,null,0,1)\\n            _this.registerPending=false;\\n            if(data.code==200)\\n            {\\n                _$.tip(\\\"注册成功\\\",1);\\n                this.showRegister=false;\\n            }\\n            else\\n            {\\n                _$.tip(data.msg,0);\\n            }\\n        },\\n        login:async function () {\\n            try\\n            {\\n                if(!this.username || !this.password)\\n                {\\n                    throw '用户名密码不能为空';\\n                }\\n                let url=this.handleUrl();\\n                let data=await _net.post(url+\\\"\\u002Fuser\\u002Flogin\\\",{\\n                    name:this.username,\\n                    password:this.password,\\n                },null,null,null,1,0)\\n                if(data.code!=200)\\n                {\\n                    throw \\\"用户名密码错误\\\"\\n                }\\n                let bNeeded=await this.$apiLogin.update.checkIfNeededUpdate(this.envId,this.objVersion.version);\\n                let contentPath;\\n                if(bNeeded && this.objVersion.url)\\n                {\\n                    contentPath=await (this.$apiLogin.update.updateEnv(this.envId,url+this.objVersion.url));\\n                }\\n                else\\n                {\\n                    contentPath=this.$apiLogin.path.getEnvPath(this.envId);\\n                }\\n                let online=false;\\n                if(!this.member && ((!window.debug && url.includes(\\\"doclever.cn\\\")) || (window.debug && url.includes(\\\"localhost:8090\\\"))))\\n                {\\n                    online=true;\\n                }\\n                let id=await this.memberLogin(online,data.data._id);\\n                _$.tip(\\\"登陆成功\\\",1);\\n                _session.clear()\\n                _session.update(data.data,this.remember,this.password);\\n                sessionStorage.setItem(\\\"env\\\",this.envId);\\n                if(this.remember)\\n                {\\n                    _session.set(\\\"env\\\",this.envId);\\n                    if(this.member)\\n                    {\\n                        _session.set(\\\"member\\\",this.member)\\n                    }\\n                }\\n                else\\n                {\\n                    _session.remove(\\\"env\\\");\\n                }\\n                sessionStorage.setItem(\\\"baseUrl\\\",url)\\n                sessionStorage.setItem(\\\"first\\\",\\\"1\\\");\\n                sessionStorage.setItem(\\\"loginUrl\\\",location.href);\\n                sessionStorage.setItem(\\\"version\\\",this.objVersion.version);\\n                setTimeout(()=\\u003E {\\n                    location.href=window.debug?`\\u002Fweb\\u002Fconsole\\u002Findex.html`:(contentPath+\\\"\\u002Fcontent\\u002Findex.html\\\");\\n                },1500);\\n            }\\n            catch (err)\\n            {\\n                _$.err(err);\\n            }\\n        },\\n        applyMember:async function () {\\n            let obj={};\\n            if(!this.memberEdit.user)\\n            {\\n                _$.tip(\\\"请输入用户名\\\",0);\\n                return;\\n            }\\n            else\\n            {\\n                obj.user=this.memberEdit.user;\\n            }\\n            if(!this.memberEdit.pass)\\n            {\\n                _$.tip(\\\"请输入密码\\\",0);\\n                return;\\n            }\\n            else\\n            {\\n                obj.pass=this.memberEdit.pass;\\n            }\\n            if(!this.memberEdit.name)\\n            {\\n                _$.tip(\\\"请输入主机名称\\\",0);\\n                return;\\n            }\\n            else\\n            {\\n                obj.name=this.memberEdit.name;\\n            }\\n            obj.mac=await this.$apiLogin.macAddress();\\n            if(this.memberEdit.remark)\\n            {\\n                obj.remark=this.memberEdit.remark;\\n            }\\n            let data=await _net.post(config.online+\\\"\\u002Fmember\\u002Fapply\\\",obj,{\\n                desktop:\\\"1\\\"\\n            },null,0,0,1);\\n            if(data.code==200 || data.code==56)\\n            {\\n                if(data.code==200)\\n                {\\n                    _$.tip(\\\"申请成功，等待管理员同意\\\",1);\\n                }\\n                else\\n                {\\n                    _$.tip(\\\"申请已通过\\\",1);\\n                }\\n                this.showApplyMember=false;\\n                db.editMember(obj.user,obj.pass);\\n                this.arrMember.push({\\n                    user:obj.user,\\n                    pass:obj.pass,\\n                    disabled:data.code==200?true:false\\n                })\\n            }\\n            else\\n            {\\n                _$.tip(data.msg,0);\\n            }\\n            this.memberEdit={\\n                user:\\\"\\\",\\n                pass:\\\"\\\",\\n                name:obj.mac,\\n                remark:\\\"\\\"\\n            }\\n        },\\n        getValidMember:async function()\\n        {\\n            let arr=await db.getAllMember();\\n            let mac=await this.$apiLogin.macAddress();\\n            let arr1=arr.map(function (obj) {\\n                return {\\n                    user:obj.user,\\n                    pass:obj.pass,\\n                    mac:mac\\n                }\\n            })\\n            let data=await _net.post(config.online+\\\"\\u002Fmember\\u002Fvalidmemeber\\\",{\\n                member:JSON.stringify(arr1)\\n            },{\\n                desktop:\\\"1\\\"\\n            },null,0,0,1);\\n            if(data.code==200)\\n            {\\n                for(let o of arr)\\n                {\\n                    if(data.data.includes(o.user))\\n                    {\\n                        o.disbaled=false;\\n                    }\\n                    else\\n                    {\\n                        o.disabled=true;\\n                    }\\n                }\\n                this.arrMember=arr;\\n            }\\n            else\\n            {\\n                _$.tip(data.msg,0);\\n            }\\n        },\\n        memberLogin:async function (online,userId,envId) {\\n            let id;\\n            if(!online)\\n            {\\n                if(!this.member)\\n                {\\n                    return;\\n                }\\n                let obj;\\n                for(let o of this.arrMember)\\n                {\\n                    if(this.member==o.user)\\n                    {\\n                        obj=o;\\n                        break;\\n                    }\\n                }\\n                if(!obj)\\n                {\\n                    return;\\n                }\\n                let mac=await this.$apiLogin.macAddress();\\n                let data=await _net.post(config.online+\\\"\\u002Fmember\\u002Flogin\\\",{\\n                    mac:mac,\\n                    user:online?this.username:obj.user,\\n                    pass:obj.pass\\n                },{\\n                    desktop:\\\"1\\\"\\n                },null,0,0,1);\\n                if(data.code!=200)\\n                {\\n                    $.tip(data.msg,0);\\n                    return;\\n                }\\n                id=data.data;\\n            }\\n            else\\n            {\\n                id=userId;\\n            }\\n            let objPlugin=await this.$apiLogin.update.handlePluginInfo(envId?envId:this.envId,id);\\n            let data=await _net.get(config.online+\\\"\\u002Fmember\\u002Fvalidplugin\\\",{\\n                content:JSON.stringify(objPlugin),\\n                version:this.objVersion.version\\n            },{\\n                desktop:\\\"1\\\"\\n            },null,1);\\n            if(data.code!=200)\\n            {\\n                $.tip(data.msg,0);\\n                return;\\n            }\\n            sessionStorage.setItem(\\\"member\\\",id);\\n            let arr=[];\\n            for(let o of data.data)\\n            {\\n                if(o.compatible)\\n                {\\n                    arr.push({\\n                        id:o.id,\\n                        version:o.version\\n                    })\\n                }\\n            }\\n            sessionStorage.setItem(\\\"plugin\\\",JSON.stringify(arr));\\n            sessionStorage.setItem(\\\"version\\\",this.objVersion.version);\\n            return id;\\n        },\\n        removeMember:async function(item,index)\\n        {\\n            let bRet=await _$.confirm(\\\"是否删除该绑定\\\");\\n            if(bRet)\\n            {\\n                if(!item.disabled)\\n                {\\n                    let bRet1=await $.confirm(\\\"是否解除与该会员的绑定\\\");\\n                    if(bRet1)\\n                    {\\n                        let mac=await this.$apiLogin.macAddress();\\n                        let obj=await _net.delete(config.online+\\\"\\u002Fmember\\u002Fclientbind\\\",{\\n                            mac:mac,\\n                            user:item.user,\\n                        },{\\n                            desktop:\\\"1\\\"\\n                        },null,1);\\n                        if(obj.code==200)\\n                        {\\n                            await this.$apiLogin.path.delPlugin(obj.data);\\n                        }\\n                    }\\n                }\\n                await db.removeMember(item.user);\\n                this.arrMember.splice(index,1);\\n                _$.tip(\\\"删除成功\\\",1);\\n            }\\n        },\\n        getQuestion:function () {\\n            var _this=this;\\n            if(!this.reset.username)\\n            {\\n                _$.tip(\\\"用户名不能为空\\\",0);\\n                return;\\n            }\\n            this.reset.questionPending=true;\\n            let url=this.handleUrl();\\n            _net.get(url+\\\"\\u002Fuser\\u002Fquestion\\\",{\\n                name:_this.reset.username,\\n            },null,null,1,0).then(function (data) {\\n                _this.reset.questionPending=false;\\n                if(data.code==200)\\n                {\\n                    _this.reset.step=1;\\n                    _this.reset.question=data.data;\\n                }\\n                else\\n                {\\n                    _$.notify(data.msg,0);\\n                }\\n            })\\n        },\\n        resetUser:function () {\\n            var _this=this;\\n            if(!this.reset.pwd || !this.reset.pwd1 || !this.reset.answer )\\n            {\\n                _$.tip(\\\"密码,确认密码,找回密码答案不能为空\\\",0);\\n                return;\\n            }\\n            else if(this.reset.pwd!=this.reset.pwd1)\\n            {\\n                _$.tip(\\\"两次输入的密码不一致\\\",0);\\n                return;\\n            }\\n            this.reset.questionPending=true;\\n            let url=this.handleUrl();\\n            _net.put(url+\\\"\\u002Fuser\\u002Freset\\\",{\\n                name:_this.reset.username,\\n                answer:_this.reset.answer,\\n                password:_this.reset.pwd\\n            },null,null,1).then(function (data) {\\n                _this.reset.questionPending=false;\\n                if(data.code==200)\\n                {\\n                    _$.notify(\\\"修改成功\\\",1);\\n                    _this.showReset=false;\\n                }\\n                else\\n                {\\n                    _$.notify(data.msg,0);\\n                }\\n            })\\n        }\\n    },\\n    created:async function () {\\n        this.getValidMember();\\n        this.memberEdit.name=this.$apiLogin.computeName();\\n        this.arrEnv=await db.getAllEnv();\\n        let tip;\\n        this.$on(\\\"startUpdate\\\",function () {\\n            tip=_$.loading(\\\"开始更新部署环境\\\");\\n        })\\n        this.$on(\\\"updateProcess\\\",function (val) {\\n            tip.message=`下载中，完成${parseInt(val*100)+\\\"%\\\"}`\\n        })\\n        this.$on(\\\"updateUnzip\\\",function () {\\n            tip.message=\\\"部署环境解压中\\\";\\n        })\\n        this.$on(\\\"finishUpdate\\\",function (val) {\\n            tip.close();\\n            _$.tip(\\\"更新完成\\\",1);\\n        })\\n        if(_session.get(\\\"env\\\") && _session.get(\\\"remember\\\") && _session.get(\\\"name\\\") && _session.get(\\\"password\\\"))\\n        {\\n            try\\n            {\\n                let bExist=false;\\n                this.member=_session.get(\\\"member\\\");\\n                for(let o of this.arrMember)\\n                {\\n                    if(o.user==this.member)\\n                    {\\n                        bExist=true;\\n                        break;\\n                    }\\n                }\\n                await this.handleChangeEnvId(1);\\n                let url=this.handleUrl(1);\\n                let data=await _net.post(url+\\\"\\u002Fuser\\u002Flogin\\\",{\\n                    name:_session.get(\\\"name\\\"),\\n                    password:_session.get(\\\"password\\\"),\\n                },null,null,null,1,0)\\n                if(data.code!=200)\\n                {\\n                    throw \\\"用户名密码错误\\\"\\n                }\\n                let bNeeded=await this.$apiLogin.update.checkIfNeededUpdate(_session.get(\\\"env\\\"),this.objVersion.version);\\n                let contentPath;\\n                if(bNeeded && this.objVersion.url)\\n                {\\n                    contentPath=await (this.$apiLogin.update.updateEnv(_session.get(\\\"env\\\"),url+this.objVersion.url));\\n                }\\n                else\\n                {\\n                    contentPath=this.$apiLogin.path.getEnvPath(_session.get(\\\"env\\\"));\\n                }\\n                let online=false;\\n                if(!this.member && ((!window.debug && url.includes(\\\"doclever.cn\\\")) || (window.debug && url.includes(\\\"localhost:8090\\\"))))\\n                {\\n                    online=true;\\n                }\\n                let id;\\n                if(online || (!online && bExist))\\n                {\\n                    id=await this.memberLogin(online,data.data._id,_session.get(\\\"env\\\"));\\n                }\\n                let password=_session.get(\\\"password\\\");\\n                let env=_session.get(\\\"env\\\");;\\n                _session.clear();\\n                _session.update(data.data,1,password);\\n                _session.set(\\\"env\\\",env);\\n                sessionStorage.setItem(\\\"env\\\",env);\\n                sessionStorage.setItem(\\\"baseUrl\\\",url)\\n                if((online || (!online && bExist)) && id)\\n                {\\n                    _session.set(\\\"member\\\",this.member)\\n                }\\n                sessionStorage.setItem(\\\"first\\\",\\\"1\\\");\\n                sessionStorage.setItem(\\\"loginUrl\\\",location.href);\\n                sessionStorage.setItem(\\\"version\\\",this.objVersion.version);\\n                location.href=window.debug?`\\u002Fweb\\u002Fconsole\\u002Findex.html`:(contentPath+\\\"\\u002Fcontent\\u002Findex.html\\\");\\n            }\\n            catch (err)\\n            {\\n                _$.err(err);\\n                _$.stopLoading();\\n            }\\n        }\\n        else\\n        {\\n            _$.stopLoading();\\n        }\\n    },\\n})\\n_$.ready(function () {\\n    _$.startLoading();\\n})\\n\\u002F* WEBPACK VAR INJECTION *\\u002F}.call(exports, __webpack_require__(0), __webpack_require__(6), __webpack_require__(1), __webpack_require__(29)))\\n\\n\\u002F***\\u002F }),\\n\\u002F* 14 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\n\\u002F* styles *\\u002F\\n__webpack_require__(15)\\n\\nvar Component = __webpack_require__(4)(\\n  \\u002F* script *\\u002F\\n  __webpack_require__(20),\\n  \\u002F* template *\\u002F\\n  __webpack_require__(21),\\n  \\u002F* scopeId *\\u002F\\n  null,\\n  \\u002F* cssModules *\\u002F\\n  null\\n)\\nComponent.options.__file = \\\"\\u002FUsers\\u002Fsunxin\\u002Fnew\\u002FClient\\u002Fweb\\u002Fcomponent\\u002FmultiMenu.vue\\\"\\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \\\"default\\\" && key !== \\\"__esModule\\\"})) {console.error(\\\"named exports are not supported in *.vue files.\\\")}\\nif (Component.options.functional) {console.error(\\\"[vue-loader] multiMenu.vue: functional components are not supported with templates, they should use render functions.\\\")}\\n\\n\\u002F* hot reload *\\u002F\\nif (false) {(function () {\\n  var hotAPI = require(\\\"vue-hot-reload-api\\\")\\n  hotAPI.install(require(\\\"vue\\\"), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-0e92e7d5\\\", Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-0e92e7d5\\\", Component.options)\\n  }\\n})()}\\n\\nmodule.exports = Component.exports\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 15 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F style-loader: Adds some css to the DOM by adding a \\u003Cstyle\\u003E tag\\n\\n\\u002F\\u002F load the styles\\nvar content = __webpack_require__(16);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n\\u002F\\u002F add the styles to the DOM\\nvar update = __webpack_require__(18)(\\\"16ae5186\\\", content, false);\\n\\u002F\\u002F Hot Module Replacement\\nif(false) {\\n \\u002F\\u002F When the styles change, update the \\u003Cstyle\\u003E tags\\n if(!content.locals) {\\n   module.hot.accept(\\\"!!..\\u002F..\\u002Fnode_modules\\u002Fcss-loader\\u002Findex.js?sourceMap!..\\u002F..\\u002Fnode_modules\\u002Fvue-loader\\u002Flib\\u002Fstyle-compiler\\u002Findex.js?{\\\\\\\"id\\\\\\\":\\\\\\\"data-v-0e92e7d5\\\\\\\",\\\\\\\"scoped\\\\\\\":false,\\\\\\\"hasInlineConfig\\\\\\\":false}!..\\u002F..\\u002Fnode_modules\\u002Fvue-loader\\u002Flib\\u002Fselector.js?type=styles&index=0!.\\u002FmultiMenu.vue\\\", function() {\\n     var newContent = require(\\\"!!..\\u002F..\\u002Fnode_modules\\u002Fcss-loader\\u002Findex.js?sourceMap!..\\u002F..\\u002Fnode_modules\\u002Fvue-loader\\u002Flib\\u002Fstyle-compiler\\u002Findex.js?{\\\\\\\"id\\\\\\\":\\\\\\\"data-v-0e92e7d5\\\\\\\",\\\\\\\"scoped\\\\\\\":false,\\\\\\\"hasInlineConfig\\\\\\\":false}!..\\u002F..\\u002Fnode_modules\\u002Fvue-loader\\u002Flib\\u002Fselector.js?type=styles&index=0!.\\u002FmultiMenu.vue\\\");\\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n     update(newContent);\\n   });\\n }\\n \\u002F\\u002F When the module is disposed, remove the \\u003Cstyle\\u003E tags\\n module.hot.dispose(function() { update(); });\\n}\\n\\n\\u002F***\\u002F }),\\n\\u002F* 16 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nexports = module.exports = __webpack_require__(17)(true);\\n\\u002F\\u002F imports\\n\\n\\n\\u002F\\u002F module\\nexports.push([module.i, \\\"\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\", \\\"\\\", {\\\"version\\\":3,\\\"sources\\\":[],\\\"names\\\":[],\\\"mappings\\\":\\\"\\\",\\\"file\\\":\\\"multiMenu.vue\\\",\\\"sourceRoot\\\":\\\"\\\"}]);\\n\\n\\u002F\\u002F exports\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 17 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\n\\u002F*\\n\\tMIT License http:\\u002F\\u002Fwww.opensource.org\\u002Flicenses\\u002Fmit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*\\u002F\\n\\u002F\\u002F css base code, injected by the css-loader\\nmodule.exports = function(useSourceMap) {\\n\\tvar list = [];\\n\\n\\t\\u002F\\u002F return the list of modules as css string\\n\\tlist.toString = function toString() {\\n\\t\\treturn this.map(function (item) {\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\n\\t\\t\\tif(item[2]) {\\n\\t\\t\\t\\treturn \\\"@media \\\" + item[2] + \\\"{\\\" + content + \\\"}\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn content;\\n\\t\\t\\t}\\n\\t\\t}).join(\\\"\\\");\\n\\t};\\n\\n\\t\\u002F\\u002F import a list of modules into the list\\n\\tlist.i = function(modules, mediaQuery) {\\n\\t\\tif(typeof modules === \\\"string\\\")\\n\\t\\t\\tmodules = [[null, modules, \\\"\\\"]];\\n\\t\\tvar alreadyImportedModules = {};\\n\\t\\tfor(var i = 0; i \\u003C this.length; i++) {\\n\\t\\t\\tvar id = this[i][0];\\n\\t\\t\\tif(typeof id === \\\"number\\\")\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\n\\t\\t}\\n\\t\\tfor(i = 0; i \\u003C modules.length; i++) {\\n\\t\\t\\tvar item = modules[i];\\n\\t\\t\\t\\u002F\\u002F skip already imported module\\n\\t\\t\\t\\u002F\\u002F this implementation is not 100% perfect for weird media query combinations\\n\\t\\t\\t\\u002F\\u002F  when a module is imported multiple times with different media queries.\\n\\t\\t\\t\\u002F\\u002F  I hope this will never occur (Hey this way we have smaller bundles)\\n\\t\\t\\tif(typeof item[0] !== \\\"number\\\" || !alreadyImportedModules[item[0]]) {\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\n\\t\\t\\t\\t} else if(mediaQuery) {\\n\\t\\t\\t\\t\\titem[2] = \\\"(\\\" + item[2] + \\\") and (\\\" + mediaQuery + \\\")\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlist.push(item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn list;\\n};\\n\\nfunction cssWithMappingToString(item, useSourceMap) {\\n\\tvar content = item[1] || '';\\n\\tvar cssMapping = item[3];\\n\\tif (!cssMapping) {\\n\\t\\treturn content;\\n\\t}\\n\\n\\tif (useSourceMap && typeof btoa === 'function') {\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\n\\t\\t\\treturn '\\u002F*# sourceURL=' + cssMapping.sourceRoot + source + ' *\\u002F'\\n\\t\\t});\\n\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\\\n');\\n\\t}\\n\\n\\treturn [content].join('\\\\n');\\n}\\n\\n\\u002F\\u002F Adapted from convert-source-map (MIT)\\nfunction toComment(sourceMap) {\\n\\t\\u002F\\u002F eslint-disable-next-line no-undef\\n\\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\\n\\tvar data = 'sourceMappingURL=data:application\\u002Fjson;charset=utf-8;base64,' + base64;\\n\\n\\treturn '\\u002F*# ' + data + ' *\\u002F';\\n}\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 18 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F*\\n  MIT License http:\\u002F\\u002Fwww.opensource.org\\u002Flicenses\\u002Fmit-license.php\\n  Author Tobias Koppers @sokra\\n  Modified by Evan You @yyx990803\\n*\\u002F\\n\\nvar hasDocument = typeof document !== 'undefined'\\n\\nif (typeof DEBUG !== 'undefined' && DEBUG) {\\n  if (!hasDocument) {\\n    throw new Error(\\n    'vue-style-loader cannot be used in a non-browser environment. ' +\\n    \\\"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\\\"\\n  ) }\\n}\\n\\nvar listToStyles = __webpack_require__(19)\\n\\n\\u002F*\\ntype StyleObject = {\\n  id: number;\\n  parts: Array\\u003CStyleObjectPart\\u003E\\n}\\n\\ntype StyleObjectPart = {\\n  css: string;\\n  media: string;\\n  sourceMap: ?string\\n}\\n*\\u002F\\n\\nvar stylesInDom = {\\u002F*\\n  [id: number]: {\\n    id: number,\\n    refs: number,\\n    parts: Array\\u003C(obj?: StyleObjectPart) =\\u003E void\\u003E\\n  }\\n*\\u002F}\\n\\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\\nvar singletonElement = null\\nvar singletonCounter = 0\\nvar isProduction = false\\nvar noop = function () {}\\n\\n\\u002F\\u002F Force single-tag solution on IE6-9, which has a hard limit on the # of \\u003Cstyle\\u003E\\n\\u002F\\u002F tags it will allow on a page\\nvar isOldIE = typeof navigator !== 'undefined' && \\u002Fmsie [6-9]\\\\b\\u002F.test(navigator.userAgent.toLowerCase())\\n\\nmodule.exports = function (parentId, list, _isProduction) {\\n  isProduction = _isProduction\\n\\n  var styles = listToStyles(parentId, list)\\n  addStylesToDom(styles)\\n\\n  return function update (newList) {\\n    var mayRemove = []\\n    for (var i = 0; i \\u003C styles.length; i++) {\\n      var item = styles[i]\\n      var domStyle = stylesInDom[item.id]\\n      domStyle.refs--\\n      mayRemove.push(domStyle)\\n    }\\n    if (newList) {\\n      styles = listToStyles(parentId, newList)\\n      addStylesToDom(styles)\\n    } else {\\n      styles = []\\n    }\\n    for (var i = 0; i \\u003C mayRemove.length; i++) {\\n      var domStyle = mayRemove[i]\\n      if (domStyle.refs === 0) {\\n        for (var j = 0; j \\u003C domStyle.parts.length; j++) {\\n          domStyle.parts[j]()\\n        }\\n        delete stylesInDom[domStyle.id]\\n      }\\n    }\\n  }\\n}\\n\\nfunction addStylesToDom (styles \\u002F* Array\\u003CStyleObject\\u003E *\\u002F) {\\n  for (var i = 0; i \\u003C styles.length; i++) {\\n    var item = styles[i]\\n    var domStyle = stylesInDom[item.id]\\n    if (domStyle) {\\n      domStyle.refs++\\n      for (var j = 0; j \\u003C domStyle.parts.length; j++) {\\n        domStyle.parts[j](item.parts[j])\\n      }\\n      for (; j \\u003C item.parts.length; j++) {\\n        domStyle.parts.push(addStyle(item.parts[j]))\\n      }\\n      if (domStyle.parts.length \\u003E item.parts.length) {\\n        domStyle.parts.length = item.parts.length\\n      }\\n    } else {\\n      var parts = []\\n      for (var j = 0; j \\u003C item.parts.length; j++) {\\n        parts.push(addStyle(item.parts[j]))\\n      }\\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\\n    }\\n  }\\n}\\n\\nfunction createStyleElement () {\\n  var styleElement = document.createElement('style')\\n  styleElement.type = 'text\\u002Fcss'\\n  head.appendChild(styleElement)\\n  return styleElement\\n}\\n\\nfunction addStyle (obj \\u002F* StyleObjectPart *\\u002F) {\\n  var update, remove\\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\\\"' + obj.id + '\\\"]')\\n\\n  if (styleElement) {\\n    if (isProduction) {\\n      \\u002F\\u002F has SSR styles and in production mode.\\n      \\u002F\\u002F simply do nothing.\\n      return noop\\n    } else {\\n      \\u002F\\u002F has SSR styles but in dev mode.\\n      \\u002F\\u002F for some reason Chrome can't handle source map in server-rendered\\n      \\u002F\\u002F style tags - source maps in \\u003Cstyle\\u003E only works if the style tag is\\n      \\u002F\\u002F created and inserted dynamically. So we remove the server rendered\\n      \\u002F\\u002F styles and inject new ones.\\n      styleElement.parentNode.removeChild(styleElement)\\n    }\\n  }\\n\\n  if (isOldIE) {\\n    \\u002F\\u002F use singleton mode for IE9.\\n    var styleIndex = singletonCounter++\\n    styleElement = singletonElement || (singletonElement = createStyleElement())\\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\\n  } else {\\n    \\u002F\\u002F use multi-style-tag mode in all other cases\\n    styleElement = createStyleElement()\\n    update = applyToTag.bind(null, styleElement)\\n    remove = function () {\\n      styleElement.parentNode.removeChild(styleElement)\\n    }\\n  }\\n\\n  update(obj)\\n\\n  return function updateStyle (newObj \\u002F* StyleObjectPart *\\u002F) {\\n    if (newObj) {\\n      if (newObj.css === obj.css &&\\n          newObj.media === obj.media &&\\n          newObj.sourceMap === obj.sourceMap) {\\n        return\\n      }\\n      update(obj = newObj)\\n    } else {\\n      remove()\\n    }\\n  }\\n}\\n\\nvar replaceText = (function () {\\n  var textStore = []\\n\\n  return function (index, replacement) {\\n    textStore[index] = replacement\\n    return textStore.filter(Boolean).join('\\\\n')\\n  }\\n})()\\n\\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\\n  var css = remove ? '' : obj.css\\n\\n  if (styleElement.styleSheet) {\\n    styleElement.styleSheet.cssText = replaceText(index, css)\\n  } else {\\n    var cssNode = document.createTextNode(css)\\n    var childNodes = styleElement.childNodes\\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\\n    if (childNodes.length) {\\n      styleElement.insertBefore(cssNode, childNodes[index])\\n    } else {\\n      styleElement.appendChild(cssNode)\\n    }\\n  }\\n}\\n\\nfunction applyToTag (styleElement, obj) {\\n  var css = obj.css\\n  var media = obj.media\\n  var sourceMap = obj.sourceMap\\n\\n  if (media) {\\n    styleElement.setAttribute('media', media)\\n  }\\n\\n  if (sourceMap) {\\n    \\u002F\\u002F https:\\u002F\\u002Fdeveloper.chrome.com\\u002Fdevtools\\u002Fdocs\\u002Fjavascript-debugging\\n    \\u002F\\u002F this makes source maps inside style tags work properly in Chrome\\n    css += '\\\\n\\u002F*# sourceURL=' + sourceMap.sources[0] + ' *\\u002F'\\n    \\u002F\\u002F http:\\u002F\\u002Fstackoverflow.com\\u002Fa\\u002F26603875\\n    css += '\\\\n\\u002F*# sourceMappingURL=data:application\\u002Fjson;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' *\\u002F'\\n  }\\n\\n  if (styleElement.styleSheet) {\\n    styleElement.styleSheet.cssText = css\\n  } else {\\n    while (styleElement.firstChild) {\\n      styleElement.removeChild(styleElement.firstChild)\\n    }\\n    styleElement.appendChild(document.createTextNode(css))\\n  }\\n}\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 19 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\n\\u002F**\\n * Translates the list format produced by css-loader into something\\n * easier to manipulate.\\n *\\u002F\\nmodule.exports = function listToStyles (parentId, list) {\\n  var styles = []\\n  var newStyles = {}\\n  for (var i = 0; i \\u003C list.length; i++) {\\n    var item = list[i]\\n    var id = item[0]\\n    var css = item[1]\\n    var media = item[2]\\n    var sourceMap = item[3]\\n    var part = {\\n      id: parentId + ':' + i,\\n      css: css,\\n      media: media,\\n      sourceMap: sourceMap\\n    }\\n    if (!newStyles[id]) {\\n      styles.push(newStyles[id] = { id: id, parts: [part] })\\n    } else {\\n      newStyles[id].parts.push(part)\\n    }\\n  }\\n  return styles\\n}\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 20 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\u002F* WEBPACK VAR INJECTION *\\u002F(function(_$) {\\n\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\nmodule.exports = {\\n    name: \\\"multimenu\\\",\\n    props: {\\n        val: {\\n            type: Array,\\n            default: []\\n        },\\n        source: {\\n            type: Array,\\n            default: []\\n        },\\n        xy: {\\n            type: Object\\n        }\\n    },\\n    data: function data() {\\n        return {\\n            closeHandle: this.close.bind(this),\\n            arr: function () {\\n                var arr = _$.clone(this.source);\\n                arr.forEach(function (obj) {\\n                    obj.select = 0;\\n                });\\n                return arr;\\n            }.call(this),\\n            selItem: null\\n        };\\n    },\\n    methods: {\\n        enter: function enter(item) {\\n            if (this.selItem) {\\n                this.selItem.select = 0;\\n            }\\n            item.select = 1;\\n            this.selItem = item;\\n            if (item.data && item.data.length \\u003E 0) {\\n                this.$emit(\\\"level\\\", this.val.length + 2);\\n            } else {\\n                this.$emit(\\\"level\\\", this.val.length + 1);\\n            }\\n        },\\n        leave: function leave(item, event) {\\n            var ele = event.relatedTarget;\\n            if (event.relatedTarget == this.$refs.menu.$el) {\\n                item.select = 1;\\n            } else if (ele.hasAttribute(\\\"menuIndex\\\")) {\\n                var index = ele.getAttribute(\\\"menuIndex\\\");\\n                if (index \\u003E this.val.length + 1) {\\n                    item.select = 1;\\n                } else {\\n                    item.select = 0;\\n                }\\n            } else {\\n                item.select = 0;\\n            }\\n        },\\n        close: function close() {\\n            if (this.val.length == 0) {\\n                this.$el.parentNode.removeChild(this.$el);\\n                this.$destroy();\\n            }\\n        },\\n        select: function select(item) {\\n            this.$emit(\\\"click\\\", this.val.concat([item.value]));\\n        },\\n        click: function click(arr) {\\n            this.$emit(\\\"click\\\", arr);\\n        },\\n        level: function level(_level) {\\n            this.$emit(\\\"level\\\", _level);\\n        }\\n    },\\n    created: function created() {\\n        if (this.val.length == 0) {\\n            document.addEventListener(\\\"click\\\", this.closeHandle, false);\\n        }\\n    },\\n    mounted: function mounted() {\\n        if (this.val.length == 0) {\\n            document.addEventListener(\\\"keydown\\\", this.closeHandle, false);\\n        }\\n    },\\n    beforeDestroy: function beforeDestroy() {\\n        if (this.val.length == 0) {\\n            document.removeEventListener(\\\"click\\\", this.closeHandle);\\n            document.removeEventListener(\\\"keydown\\\", this.closeHandle);\\n        }\\n    }\\n};\\n\\u002F* WEBPACK VAR INJECTION *\\u002F}.call(exports, __webpack_require__(1)))\\n\\n\\u002F***\\u002F }),\\n\\u002F* 21 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\\n  return _c('el-row', {\\n    staticClass: \\\"row\\\",\\n    staticStyle: {\\n      \\\"font-size\\\": \\\"14px\\\",\\n      \\\"position\\\": \\\"absolute\\\",\\n      \\\"width\\\": \\\"auto\\\",\\n      \\\"z-index\\\": \\\"10000\\\",\\n      \\\"border-radius\\\": \\\"3px\\\",\\n      \\\"box-shadow\\\": \\\"0 2px 12px 0 rgba(0,0,0,.1)\\\",\\n      \\\"border\\\": \\\"1px solid #e4e7ed\\\"\\n    },\\n    attrs: {\\n      \\\"menuIndex\\\": _vm.val.length + 1\\n    }\\n  }, [_c('el-col', {\\n    ref: \\\"menu\\\",\\n    staticClass: \\\"col\\\",\\n    staticStyle: {\\n      \\\"width\\\": \\\"150px\\\",\\n      \\\"background\\\": \\\"white\\\",\\n      \\\"height\\\": \\\"200px\\\",\\n      \\\"overflow-y\\\": \\\"auto\\\"\\n    },\\n    attrs: {\\n      \\\"menuIndex\\\": _vm.val.length + 1\\n    }\\n  }, _vm._l((_vm.arr), function(item) {\\n    return _c('el-row', {\\n      staticClass: \\\"row\\\",\\n      staticStyle: {\\n        \\\"height\\\": \\\"35px\\\",\\n        \\\"line-height\\\": \\\"35px\\\"\\n      },\\n      style: ({\\n        backgroundColor: item.select ? '#F3F3F3' : ''\\n      }),\\n      attrs: {\\n        \\\"menuIndex\\\": _vm.val.length + 1\\n      },\\n      nativeOn: {\\n        \\\"mouseenter\\\": function($event) {\\n          _vm.enter(item)\\n        },\\n        \\\"mouseleave\\\": function($event) {\\n          _vm.leave(item, $event)\\n        },\\n        \\\"click\\\": function($event) {\\n          _vm.select(item)\\n        }\\n      }\\n    }, [_c('el-col', {\\n      staticClass: \\\"col\\\",\\n      staticStyle: {\\n        \\\"padding-left\\\": \\\"10px\\\",\\n        \\\"overflow\\\": \\\"hidden\\\",\\n        \\\"text-overflow\\\": \\\"ellipsis\\\"\\n      },\\n      style: ({\\n        width: item.data ? '80%' : '100%'\\n      }),\\n      attrs: {\\n        \\\"menuIndex\\\": _vm.val.length + 1,\\n        \\\"title\\\": item.label\\n      }\\n    }, [_vm._v(\\\"\\\\n                \\\" + _vm._s(item.label) + \\\"\\\\n            \\\")]), _vm._v(\\\" \\\"), (item.data) ? _c('el-col', {\\n      staticClass: \\\"col\\\",\\n      staticStyle: {\\n        \\\"width\\\": \\\"20%\\\",\\n        \\\"text-align\\\": \\\"center\\\",\\n        \\\"padding-right\\\": \\\"10px\\\",\\n        \\\"color\\\": \\\"gray\\\"\\n      },\\n      attrs: {\\n        \\\"menuIndex\\\": _vm.val.length + 1\\n      }\\n    }, [_vm._v(\\\"\\\\n                \\u003E\\\\n            \\\")]) : _vm._e()], 1)\\n  })), _vm._v(\\\" \\\"), _vm._l((_vm.arr), function(item, index) {\\n    return [(item.data && item.data.length \\u003E 0 && item.select) ? _c('multimenu', {\\n      key: String(index),\\n      style: ({\\n        left: '150px',\\n        top: 0\\n      }),\\n      attrs: {\\n        \\\"val\\\": _vm.val.concat(item.value),\\n        \\\"source\\\": item.data\\n      },\\n      on: {\\n        \\\"click\\\": _vm.click,\\n        \\\"level\\\": _vm.level\\n      }\\n    }) : _vm._e()]\\n  })], 2)\\n},staticRenderFns: []}\\nmodule.exports.render._withStripped = true\\nif (false) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n     require(\\\"vue-hot-reload-api\\\").rerender(\\\"data-v-0e92e7d5\\\", module.exports)\\n  }\\n}\\n\\n\\u002F***\\u002F }),\\n\\u002F* 22 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nvar Component = __webpack_require__(4)(\\n  \\u002F* script *\\u002F\\n  __webpack_require__(23),\\n  \\u002F* template *\\u002F\\n  __webpack_require__(25),\\n  \\u002F* scopeId *\\u002F\\n  null,\\n  \\u002F* cssModules *\\u002F\\n  null\\n)\\nComponent.options.__file = \\\"\\u002FUsers\\u002Fsunxin\\u002Fnew\\u002FClient\\u002Fweb\\u002Fcomponent\\u002FinputMul.vue\\\"\\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \\\"default\\\" && key !== \\\"__esModule\\\"})) {console.error(\\\"named exports are not supported in *.vue files.\\\")}\\nif (Component.options.functional) {console.error(\\\"[vue-loader] inputMul.vue: functional components are not supported with templates, they should use render functions.\\\")}\\n\\n\\u002F* hot reload *\\u002F\\nif (false) {(function () {\\n  var hotAPI = require(\\\"vue-hot-reload-api\\\")\\n  hotAPI.install(require(\\\"vue\\\"), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-624794e6\\\", Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-624794e6\\\", Component.options)\\n  }\\n})()}\\n\\nmodule.exports = Component.exports\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 23 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\nvar dragFile = __webpack_require__(24);\\nmodule.exports = {\\n    props: [\\\"source\\\", \\\"placeholder\\\", \\\"hudremove\\\"],\\n    data: function data() {\\n        return {\\n            text: this.source,\\n            hud: this.hudremove === undefined ? true : Boolean(this.hudremove),\\n            showDialog: false\\n        };\\n    },\\n    directives: {\\n        drag: dragFile\\n    },\\n    methods: {\\n        save: function save() {\\n            this.$emit(\\\"save\\\", this.text);\\n        }\\n    }\\n};\\n\\n\\u002F***\\u002F }),\\n\\u002F* 24 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F* WEBPACK VAR INJECTION *\\u002F(function(_$) {\\u002F**\\r\\n * Created by sunxin on 2017\\u002F5\\u002F21.\\r\\n *\\u002F\\r\\nvar obj={\\r\\n    bind:function (el,binding,vnode) {\\r\\n        el.draggable=true;\\r\\n        var area=el.getElementsByTagName(\\\"textarea\\\")[0];\\r\\n        area.placeholder+=\\\"(支持将文件拖入输入框内)\\\"\\r\\n        el.addEventListener(\\\"dragenter\\\", function(e){\\r\\n            area.style.backgroundColor = 'rgba(88,183,255,0.6)';\\r\\n            e.stopPropagation();\\r\\n            e.preventDefault();\\r\\n        }, false);\\r\\n        el.addEventListener(\\\"dragleave\\\", function(e){\\r\\n            area.style.backgroundColor = 'white';\\r\\n        }, false);\\r\\n        el.addEventListener(\\\"dragover\\\", function(e){\\r\\n            e.stopPropagation();\\r\\n            e.preventDefault();\\r\\n        }, false);\\r\\n        el.addEventListener(\\\"drop\\\", function(e){\\r\\n            area.style.backgroundColor = 'white';\\r\\n            e.stopPropagation();\\r\\n            e.preventDefault();\\r\\n            var file=e.dataTransfer.files[0];\\r\\n            if(file.type.indexOf(\\\"text\\\")==-1 && file.type.indexOf(\\\"json\\\")==-1 && file.type!=\\\"\\\")\\r\\n            {\\r\\n                _$.tip(\\\"文件类型不正确\\\",0);\\r\\n                return;\\r\\n            }\\r\\n            var reader = new FileReader();\\r\\n            reader.onload = function(e) {\\r\\n                vnode.context[binding.value]=reader.result;\\r\\n            };\\r\\n            reader.onerror=function () {\\r\\n                _$.tip(\\\"读取文件错误\\\",0);\\r\\n            }\\r\\n            reader.readAsText(file);\\r\\n        }, false);\\r\\n    },\\r\\n    unbind:function (el) {\\r\\n\\r\\n    },\\r\\n    update:function (el,binding) {\\r\\n\\r\\n    }\\r\\n}\\r\\n\\r\\nmodule.exports=obj;\\n\\u002F* WEBPACK VAR INJECTION *\\u002F}.call(exports, __webpack_require__(1)))\\n\\n\\u002F***\\u002F }),\\n\\u002F* 25 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\\n  return _c('el-dialog', {\\n    ref: \\\"box\\\",\\n    attrs: {\\n      \\\"title\\\": \\\"DOClever\\\",\\n      \\\"width\\\": \\\"50%\\\",\\n      \\\"modal\\\": _vm.hud,\\n      \\\"visible\\\": _vm.showDialog,\\n      \\\"append-to-body\\\": \\\"\\\"\\n    },\\n    on: {\\n      \\\"update:visible\\\": function($event) {\\n        _vm.showDialog = $event\\n      }\\n    }\\n  }, [_c('el-row', {\\n    staticClass: \\\"row\\\",\\n    staticStyle: {\\n      \\\"background-color\\\": \\\"white\\\",\\n      \\\"height\\\": \\\"100%\\\",\\n      \\\"padding\\\": \\\"20px\\\"\\n    }\\n  }, [_c('el-input', {\\n    directives: [{\\n      name: \\\"drag\\\",\\n      rawName: \\\"v-drag\\\",\\n      value: ('text'),\\n      expression: \\\"'text'\\\"\\n    }],\\n    attrs: {\\n      \\\"type\\\": \\\"textarea\\\",\\n      \\\"rows\\\": 6,\\n      \\\"placeholder\\\": _vm.placeholder\\n    },\\n    model: {\\n      value: (_vm.text),\\n      callback: function($$v) {\\n        _vm.text = $$v\\n      },\\n      expression: \\\"text\\\"\\n    }\\n  })], 1), _vm._v(\\\" \\\"), _c('el-row', {\\n    staticClass: \\\"dialog-footer\\\",\\n    attrs: {\\n      \\\"slot\\\": \\\"footer\\\"\\n    },\\n    slot: \\\"footer\\\"\\n  }, [_c('el-button', {\\n    attrs: {\\n      \\\"type\\\": \\\"primary\\\"\\n    },\\n    on: {\\n      \\\"click\\\": _vm.save\\n    }\\n  }, [_vm._v(\\\"\\\\n            保存\\\\n        \\\")])], 1)], 1)\\n},staticRenderFns: []}\\nmodule.exports.render._withStripped = true\\nif (false) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n     require(\\\"vue-hot-reload-api\\\").rerender(\\\"data-v-624794e6\\\", module.exports)\\n  }\\n}\\n\\n\\u002F***\\u002F }),\\n\\u002F* 26 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nvar Component = __webpack_require__(4)(\\n  \\u002F* script *\\u002F\\n  __webpack_require__(27),\\n  \\u002F* template *\\u002F\\n  __webpack_require__(28),\\n  \\u002F* scopeId *\\u002F\\n  null,\\n  \\u002F* cssModules *\\u002F\\n  null\\n)\\nComponent.options.__file = \\\"\\u002FUsers\\u002Fsunxin\\u002Fnew\\u002FClient\\u002Fweb\\u002Fcomponent\\u002FinputTwo.vue\\\"\\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \\\"default\\\" && key !== \\\"__esModule\\\"})) {console.error(\\\"named exports are not supported in *.vue files.\\\")}\\nif (Component.options.functional) {console.error(\\\"[vue-loader] inputTwo.vue: functional components are not supported with templates, they should use render functions.\\\")}\\n\\n\\u002F* hot reload *\\u002F\\nif (false) {(function () {\\n  var hotAPI = require(\\\"vue-hot-reload-api\\\")\\n  hotAPI.install(require(\\\"vue\\\"), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-44bbcc15\\\", Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-44bbcc15\\\", Component.options)\\n  }\\n})()}\\n\\nmodule.exports = Component.exports\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 27 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\nmodule.exports = {\\n    props: [\\\"name1\\\", \\\"name2\\\", \\\"placeholder1\\\", \\\"placeholder2\\\", \\\"text1\\\", \\\"text2\\\", \\\"hudremove\\\"],\\n    data: function data() {\\n        return {\\n            data: {\\n                labelTitle: this.name1,\\n                labelContent: this.name2,\\n                placeholderTitle: this.placeholder1,\\n                placeholderContent: this.placeholder2,\\n                textTitle: this.text1,\\n                textContent: this.text2\\n            },\\n            hud: this.hudremove === undefined ? true : Boolean(this.hudremove),\\n            showDialog: false\\n        };\\n    },\\n    methods: {\\n        save: function save() {\\n            this.$emit(\\\"save\\\", this.data.textTitle, this.data.textContent);\\n        }\\n    }\\n};\\n\\n\\u002F***\\u002F }),\\n\\u002F* 28 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\\n  return _c('el-dialog', {\\n    ref: \\\"box\\\",\\n    attrs: {\\n      \\\"title\\\": \\\"DOClever\\\",\\n      \\\"size\\\": \\\"50%\\\",\\n      \\\"modal\\\": _vm.hud,\\n      \\\"visible\\\": _vm.showDialog,\\n      \\\"append-to-body\\\": \\\"\\\"\\n    },\\n    on: {\\n      \\\"update:visible\\\": function($event) {\\n        _vm.showDialog = $event\\n      }\\n    }\\n  }, [_c('el-form', {\\n    attrs: {\\n      \\\"label-width\\\": \\\"100px\\\"\\n    }\\n  }, [_c('el-form-item', {\\n    staticStyle: {\\n      \\\"text-align\\\": \\\"center\\\"\\n    },\\n    attrs: {\\n      \\\"label\\\": _vm.data.labelTitle\\n    }\\n  }, [_c('el-input', {\\n    attrs: {\\n      \\\"size\\\": \\\"small\\\",\\n      \\\"placeholder\\\": _vm.data.placeholderTitle\\n    },\\n    model: {\\n      value: (_vm.data.textTitle),\\n      callback: function($$v) {\\n        _vm.$set(_vm.data, \\\"textTitle\\\", $$v)\\n      },\\n      expression: \\\"data.textTitle\\\"\\n    }\\n  })], 1), _vm._v(\\\" \\\"), _c('el-form-item', {\\n    staticStyle: {\\n      \\\"text-align\\\": \\\"center\\\"\\n    },\\n    attrs: {\\n      \\\"label\\\": _vm.data.labelContent\\n    }\\n  }, [_c('el-input', {\\n    attrs: {\\n      \\\"size\\\": \\\"small\\\",\\n      \\\"type\\\": \\\"textarea\\\",\\n      \\\"rows\\\": 6,\\n      \\\"placeholder\\\": _vm.data.placeholderContent\\n    },\\n    model: {\\n      value: (_vm.data.textContent),\\n      callback: function($$v) {\\n        _vm.$set(_vm.data, \\\"textContent\\\", $$v)\\n      },\\n      expression: \\\"data.textContent\\\"\\n    }\\n  })], 1)], 1), _vm._v(\\\" \\\"), _c('el-row', {\\n    staticClass: \\\"dialog-footer\\\",\\n    attrs: {\\n      \\\"slot\\\": \\\"footer\\\"\\n    },\\n    slot: \\\"footer\\\"\\n  }, [_c('el-button', {\\n    attrs: {\\n      \\\"type\\\": \\\"primary\\\"\\n    },\\n    on: {\\n      \\\"click\\\": _vm.save\\n    }\\n  }, [_vm._v(\\\"\\\\n            保存\\\\n        \\\")])], 1)], 1)\\n},staticRenderFns: []}\\nmodule.exports.render._withStripped = true\\nif (false) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n     require(\\\"vue-hot-reload-api\\\").rerender(\\\"data-v-44bbcc15\\\", module.exports)\\n  }\\n}\\n\\n\\u002F***\\u002F }),\\n\\u002F* 29 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F* WEBPACK VAR INJECTION *\\u002F(function(Vue, _session, _$) {\\u002F**\\r\\n * Created by sunxin on 2017\\u002F2\\u002F20.\\r\\n *\\u002F\\r\\nvar config=__webpack_require__(3);\\r\\nvar resource=__webpack_require__(30)\\r\\nVue.use(resource)\\r\\nvar net={};\\r\\nfunction getAllHeaders(obj) {\\r\\n    var result={};\\r\\n    for(var key in obj.map)\\r\\n    {\\r\\n        if(obj.map.hasOwnProperty(key))\\r\\n        {\\r\\n            result[key.toLowerCase()]=obj.map[key][0];\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\nfunction handleVersionHeaders(headers) {\\r\\n    var header=headers || {};\\r\\n    if(_session.get(\\\"versionId\\\"))\\r\\n    {\\r\\n        header[\\\"docleverversion\\\"]=_session.get(\\\"versionId\\\");\\r\\n    }\\r\\n    if(_session.get(\\\"snapshotId\\\"))\\r\\n    {\\r\\n        header[\\\"docleversnapshot\\\"]=_session.get(\\\"snapshotId\\\");\\r\\n    }\\r\\n    return header;\\r\\n}\\r\\n\\r\\nfunction convertHeader(data) {\\r\\n    if(data.length\\u003E0)\\r\\n    {\\r\\n        var obj={};\\r\\n        var arr=data.split(\\\"\\\\r\\\\n\\\");\\r\\n        for(var i=0;i\\u003Carr.length;i++)\\r\\n        {\\r\\n            var index=arr[i].indexOf(\\\":\\\")\\r\\n            if(index\\u003E-1)\\r\\n            {\\r\\n                obj[arr[i].substr(0,index)]=arr[i].substr(index+1);\\r\\n            }\\r\\n        }\\r\\n        return obj;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return {};\\r\\n    }\\r\\n}\\r\\nnet.get=function (path,params,headers,beforeFunc,full,timeout) {\\r\\n    headers=handleVersionHeaders(headers);\\r\\n    if(!params)\\r\\n    {\\r\\n        params={};\\r\\n    }\\r\\n    params.sbdoctimestamps=(new Date()).getTime()\\r\\n    let query={\\r\\n        headers:headers,\\r\\n        params:params,\\r\\n        before:beforeFunc,\\r\\n        credentials:true\\r\\n    }\\r\\n    if(timeout)\\r\\n    {\\r\\n        query.timeout=timeout;\\r\\n    }\\r\\n    return Vue.http.get(full?path:(config.baseUrl+path),query).then(function (res) {\\r\\n        var json=res.body;\\r\\n        if(full)\\r\\n        {\\r\\n            if(json.code!=200)\\r\\n            {\\r\\n                throw \\\"error\\\";\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return json;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            if(json.code==13)\\r\\n            {\\r\\n                location.href=\\\"\\u002Fhtml\\u002Fweb\\u002Flogin\\u002Flogin.html\\\"\\r\\n            }\\r\\n            else if(json.code==35)\\r\\n            {\\r\\n                _session.remove(\\\"versionId\\\");\\r\\n                _session.remove(\\\"versionName\\\");\\r\\n                _session.remove(\\\"versionDis\\\");\\r\\n                location.reload();\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return json;\\r\\n            }\\r\\n        }\\r\\n\\r\\n    })\\r\\n}\\r\\n\\r\\nnet.post=function (path,data,headers,beforeFunc,run,bNet,full) {\\r\\n    if(!run)\\r\\n    {\\r\\n        headers=handleVersionHeaders(headers);\\r\\n    }\\r\\n    var bEncode=false,bFind=false;\\r\\n    if(headers)\\r\\n    {\\r\\n        for(var key in headers)\\r\\n        {\\r\\n            if(key.toLowerCase()==\\\"content-type\\\")\\r\\n            {\\r\\n                bFind=true;\\r\\n                if(headers[key].toLowerCase()==\\\"application\\u002Fx-www-form-urlencoded\\\")\\r\\n                {\\r\\n                    bEncode=true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    if(data)\\r\\n    {\\r\\n        if(bEncode || !bFind)\\r\\n        {\\r\\n            data=_$.param(data,1);\\r\\n            if(!bFind)\\r\\n            {\\r\\n                if(headers)\\r\\n                {\\r\\n                    headers[\\\"content-type\\\"]=\\\"application\\u002Fx-www-form-urlencoded\\\"\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    headers={\\r\\n                        \\\"content-type\\\":\\\"application\\u002Fx-www-form-urlencoded\\\"\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        data=\\\"\\\"\\r\\n    }\\r\\n    return Vue.http.post(full?path:(bNet?path:(config.baseUrl+path)),data,{\\r\\n        headers:headers,\\r\\n        before:beforeFunc,\\r\\n        credentials:true\\r\\n    }).then(function (res) {\\r\\n        if(full)\\r\\n        {\\r\\n            return res.body;\\r\\n        }\\r\\n        else if(run)\\r\\n        {\\r\\n            var resObj;\\r\\n            if(typeof (res.body)==\\\"string\\\")\\r\\n            {\\r\\n                var strStr=res.body;\\r\\n                try\\r\\n                {\\r\\n                    resObj=JSON.parse(strStr);\\r\\n                }\\r\\n                catch (err)\\r\\n                {\\r\\n                    resObj=strStr;\\r\\n                }\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                if(typeof (res.body)==\\\"object\\\" && (res.body instanceof Blob) && res.body.size\\u003C=1024*5)\\r\\n                {\\r\\n                    return new Promise(function (resolve,reject) {\\r\\n                        var reader = new FileReader();\\r\\n                        reader.onload = function(){\\r\\n                            var content = reader.result;\\r\\n                            if(\\u002Fapplication\\\\\\u002Fxml\\u002Fi.test(res.headers.map[\\\"content-type\\\"][0]) || \\u002Ftext\\\\\\u002Fxml\\u002Fi.test(res.headers.map[\\\"content-type\\\"][0]))\\r\\n                            {\\r\\n                                resObj=content;\\r\\n                            }\\r\\n                            else\\r\\n                            {\\r\\n                                try\\r\\n                                {\\r\\n                                    resObj=JSON.parse(content);\\r\\n                                }\\r\\n                                catch (err)\\r\\n                                {\\r\\n                                    resObj=res.body;\\r\\n                                }\\r\\n                            }\\r\\n                            var obj={\\r\\n                                data:resObj,\\r\\n                                status:res.status,\\r\\n                                header:getAllHeaders(res.headers),\\r\\n                            }\\r\\n                            resolve(obj);\\r\\n                        };\\r\\n                        reader.onerror = function(event){\\r\\n                            resObj=res.body;\\r\\n                            var obj={\\r\\n                                data:resObj,\\r\\n                                status:res.status,\\r\\n                                header:getAllHeaders(res.headers),\\r\\n                            }\\r\\n                            resolve(obj);\\r\\n                        };\\r\\n                        reader.readAsText(res.body);\\r\\n                    })\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    resObj=res.body;\\r\\n                }\\r\\n            }\\r\\n            var obj={\\r\\n                data:resObj,\\r\\n                status:res.status,\\r\\n                header:getAllHeaders(res.headers),\\r\\n            }\\r\\n            return obj;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            var json=res.body;\\r\\n            if(json.code==13)\\r\\n            {\\r\\n                location.href=\\\"\\u002Fhtml\\u002Fweb\\u002Flogin\\u002Flogin.html\\\"\\r\\n            }\\r\\n            else if(json.code==35)\\r\\n            {\\r\\n                _session.remove(\\\"versionId\\\");\\r\\n                _session.remove(\\\"versionName\\\");\\r\\n                _session.remove(\\\"versionDis\\\");\\r\\n                location.reload();\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return json;\\r\\n            }\\r\\n        }\\r\\n    },function (res) {\\r\\n        if(run)\\r\\n        {\\r\\n            var obj={\\r\\n                data:res.body,\\r\\n                status:res.status,\\r\\n                header:getAllHeaders(res.headers),\\r\\n            }\\r\\n            return obj;\\r\\n        }\\r\\n    })\\r\\n}\\r\\n\\r\\nnet.put=function (path,data,headers,beforeFunc,full) {\\r\\n    headers=handleVersionHeaders(headers);\\r\\n    var bEncode=false,bFind=false;\\r\\n    if(headers)\\r\\n    {\\r\\n        for(var key in headers)\\r\\n        {\\r\\n            if(key.toLowerCase()==\\\"content-type\\\")\\r\\n            {\\r\\n                bFind=true;\\r\\n                if(headers[key].toLowerCase()==\\\"application\\u002Fx-www-form-urlencoded\\\")\\r\\n                {\\r\\n                    bEncode=true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    if(data)\\r\\n    {\\r\\n        if(bEncode || !bFind)\\r\\n        {\\r\\n            data=_$.param(data,1);\\r\\n            if(!bFind)\\r\\n            {\\r\\n                if(headers)\\r\\n                {\\r\\n                    headers[\\\"content-type\\\"]=\\\"application\\u002Fx-www-form-urlencoded\\\"\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    headers={\\r\\n                        \\\"content-type\\\":\\\"application\\u002Fx-www-form-urlencoded\\\"\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        data=\\\"\\\"\\r\\n    }\\r\\n    return Vue.http.put(full?path:(config.baseUrl+path),data,{\\r\\n        headers:headers,\\r\\n        before:beforeFunc,\\r\\n        credentials:true\\r\\n    }).then(function (res) {\\r\\n        var json=res.body;\\r\\n        if(full)\\r\\n        {\\r\\n            return json;\\r\\n        }\\r\\n        else if(json.code==13)\\r\\n        {\\r\\n            location.href=\\\"\\u002Fhtml\\u002Fweb\\u002Flogin\\u002Flogin.html\\\"\\r\\n        }\\r\\n        else if(json.code==35)\\r\\n        {\\r\\n            _session.remove(\\\"versionId\\\");\\r\\n            _session.remove(\\\"versionName\\\");\\r\\n            _session.remove(\\\"versionDis\\\");\\r\\n            location.reload();\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return json;\\r\\n        }\\r\\n    })\\r\\n}\\r\\n\\r\\nnet.delete=function (path,params,headers,beforeFunc,full) {\\r\\n    headers=handleVersionHeaders(headers);\\r\\n    return Vue.http.delete(full?path:(config.baseUrl+path),{\\r\\n        headers:headers,\\r\\n        params:params,\\r\\n        before:beforeFunc,\\r\\n        credentials:true\\r\\n    }).then(function (res) {\\r\\n        var json=res.body;\\r\\n        if(full)\\r\\n        {\\r\\n            return json;\\r\\n        }\\r\\n        if(json.code==13)\\r\\n        {\\r\\n            location.href=\\\"\\u002Fhtml\\u002Fweb\\u002Flogin\\u002Flogin.html\\\"\\r\\n        }\\r\\n        else if(json.code==35)\\r\\n        {\\r\\n            _session.remove(\\\"versionId\\\");\\r\\n            _session.remove(\\\"versionName\\\");\\r\\n            _session.remove(\\\"versionDis\\\");\\r\\n            location.reload();\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return json;\\r\\n        }\\r\\n    })\\r\\n}\\r\\n\\r\\nnet.upload=function (method,path,data,headers,beforeFunc,run,bNet) {\\r\\n    if(!run)\\r\\n    {\\r\\n        headers=handleVersionHeaders(headers);\\r\\n    }\\r\\n    var form;\\r\\n    if(typeof(data)==\\\"string\\\" || (data instanceof ArrayBuffer))\\r\\n    {\\r\\n        form=data;\\r\\n        if(headers)\\r\\n        {\\r\\n            var bFind=false;\\r\\n            for(var key in headers)\\r\\n            {\\r\\n                if(key.toLowerCase()==\\\"content-type\\\")\\r\\n                {\\r\\n                    bFind=true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            if(!bFind)\\r\\n            {\\r\\n                if(typeof(data)==\\\"string\\\")\\r\\n                {\\r\\n                    var bJson=true;\\r\\n                    try {\\r\\n                        JSON.parse(data);\\r\\n                    }\\r\\n                    catch(e) {\\r\\n                        bJson=false;\\r\\n                    }\\r\\n                    if(bJson)\\r\\n                    {\\r\\n                        headers[\\\"content-type\\\"]=\\\"application\\u002Fjson\\\"\\r\\n                    }\\r\\n                    else\\r\\n                    {\\r\\n                        headers[\\\"content-type\\\"]=\\\"text\\u002Fplain\\\";\\r\\n                    }\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    headers[\\\"content-type\\\"]=\\\"application\\u002Fx-www-form-urlencoded\\\"\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            if(typeof(data)==\\\"string\\\")\\r\\n            {\\r\\n                var bJson=true;\\r\\n                try {\\r\\n                    JSON.parse(data);\\r\\n                }\\r\\n                catch(e) {\\r\\n                    bJson=false;\\r\\n                }\\r\\n                if(bJson)\\r\\n                {\\r\\n                    headers={\\r\\n                        \\\"content-type\\\":\\\"application\\u002Fjson\\\"\\r\\n                    }\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    headers={\\r\\n                        \\\"content-type\\\":\\\"text\\u002Fplain\\\"\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                headers={\\r\\n                    \\\"content-type\\\":\\\"application\\u002Fx-www-form-urlencoded\\\"\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        form=new FormData();\\r\\n        for(var key in data)\\r\\n        {\\r\\n            form.append(key,data[key]);\\r\\n        }\\r\\n    }\\r\\n    if(!run)\\r\\n    {\\r\\n        var request;\\r\\n        if(method.toLowerCase()==\\\"post\\\")\\r\\n        {\\r\\n            request=Vue.http.post;\\r\\n        }\\r\\n        else if(method.toLowerCase()==\\\"put\\\")\\r\\n        {\\r\\n            request=Vue.http.put;\\r\\n        }\\r\\n        else if(method.toLowerCase()==\\\"patch\\\")\\r\\n        {\\r\\n            request=Vue.http.patch;\\r\\n        }\\r\\n        return request.call(Vue.http,config.baseUrl+path,form,{\\r\\n            headers:headers,\\r\\n            before:beforeFunc,\\r\\n            credentials:true\\r\\n        }).then(function (res) {\\r\\n            var json=res.body;\\r\\n            if(json.code==13)\\r\\n            {\\r\\n                location.href=\\\"\\u002Fhtml\\u002Fweb\\u002Flogin\\u002Flogin.html\\\"\\r\\n            }\\r\\n            else if(json.code==35)\\r\\n            {\\r\\n                _session.remove(\\\"versionId\\\");\\r\\n                _session.remove(\\\"versionName\\\");\\r\\n                _session.remove(\\\"versionDis\\\");\\r\\n                location.reload();\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return json;\\r\\n            }\\r\\n        })\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return new Promise(function (resolve,reject) {\\r\\n            var xhr=new XMLHttpRequest();\\r\\n            xhr.withCredentials=true;\\r\\n            xhr.open(method,bNet?path:(config.baseUrl+path),true);\\r\\n            if(headers)\\r\\n            {\\r\\n                for(var key in headers)\\r\\n                {\\r\\n                    xhr.setRequestHeader(key,headers[key]);\\r\\n                }\\r\\n            }\\r\\n            xhr.onreadystatechange=function () {\\r\\n                if(xhr.readyState == 4) {\\r\\n                    var resObj;\\r\\n                    if(xhr.responseType==\\\"string\\\" || xhr.responseType==\\\"\\\" || xhr.responseType==\\\"json\\\")\\r\\n                    {\\r\\n                        var strStr=xhr.responseText;\\r\\n                        try\\r\\n                        {\\r\\n                            resObj=JSON.parse(strStr);\\r\\n                        }\\r\\n                        catch (err)\\r\\n                        {\\r\\n                            resObj=strStr;\\r\\n                        }\\r\\n                    }\\r\\n                    else\\r\\n                    {\\r\\n                        if((xhr.responseType==\\\"blob\\\" || xhr.responseType==\\\"arraybuffer\\\" || xhr.responseType==\\\"document\\\") &&  xhr.response.size\\u003C=1024*5)\\r\\n                        {\\r\\n                            var reader = new FileReader();\\r\\n                            reader.onload = function(){\\r\\n                                var content = reader.result;\\r\\n                                if(\\u002Fapplication\\\\\\u002Fxml\\u002Fi.test(xhr.getResponseHeader(\\\"content-type\\\")) || \\u002Ftext\\\\\\u002Fxml\\u002Fi.test(xhr.getResponseHeader(\\\"content-type\\\")))\\r\\n                                {\\r\\n                                    resObj=content;\\r\\n                                }\\r\\n                                else\\r\\n                                {\\r\\n                                    try\\r\\n                                    {\\r\\n                                        resObj=JSON.parse(content);\\r\\n                                    }\\r\\n                                    catch (err)\\r\\n                                    {\\r\\n                                        resObj=xhr.response;\\r\\n                                    }\\r\\n                                }\\r\\n                                var obj={\\r\\n                                    data:resObj,\\r\\n                                    status:xhr.status,\\r\\n                                    header:convertHeader(xhr.getAllResponseHeaders()),\\r\\n                                }\\r\\n                                resolve(obj);\\r\\n                            };\\r\\n                            reader.onerror = function(event){\\r\\n                                resObj=xhr.response;\\r\\n                                var obj={\\r\\n                                    data:resObj,\\r\\n                                    status:xhr.status,\\r\\n                                    header:convertHeader(xhr.getAllResponseHeaders()),\\r\\n                                }\\r\\n                                resolve(obj);\\r\\n                            };\\r\\n                            reader.readAsText(xhr.response);\\r\\n                            return;\\r\\n                        }\\r\\n                        else\\r\\n                        {\\r\\n                            resObj=xhr.response;\\r\\n                        }\\r\\n                    }\\r\\n                    var obj={\\r\\n                        data:resObj,\\r\\n                        status:xhr.status,\\r\\n                        header:convertHeader(xhr.getAllResponseHeaders()),\\r\\n                    }\\r\\n                    resolve(obj)\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n            xhr.send(form);\\r\\n        })\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nmodule.exports=net;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n\\u002F* WEBPACK VAR INJECTION *\\u002F}.call(exports, __webpack_require__(0), __webpack_require__(6), __webpack_require__(1)))\\n\\n\\u002F***\\u002F }),\\n\\u002F* 30 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\u002F*!\\n * vue-resource v1.2.0\\n * https:\\u002F\\u002Fgithub.com\\u002Fpagekit\\u002Fvue-resource\\n * Released under the MIT License.\\n *\\u002F\\n\\n\\n\\n\\u002F**\\n * Promises\\u002FA+ polyfill v1.1.4 (https:\\u002F\\u002Fgithub.com\\u002Fbramstein\\u002Fpromis)\\n *\\u002F\\n\\nvar RESOLVED = 0;\\nvar REJECTED = 1;\\nvar PENDING  = 2;\\n\\nfunction Promise$1(executor) {\\n\\n    this.state = PENDING;\\n    this.value = undefined;\\n    this.deferred = [];\\n\\n    var promise = this;\\n\\n    try {\\n        executor(function (x) {\\n            promise.resolve(x);\\n        }, function (r) {\\n            promise.reject(r);\\n        });\\n    } catch (e) {\\n        promise.reject(e);\\n    }\\n}\\n\\nPromise$1.reject = function (r) {\\n    return new Promise$1(function (resolve, reject) {\\n        reject(r);\\n    });\\n};\\n\\nPromise$1.resolve = function (x) {\\n    return new Promise$1(function (resolve, reject) {\\n        resolve(x);\\n    });\\n};\\n\\nPromise$1.all = function all(iterable) {\\n    return new Promise$1(function (resolve, reject) {\\n        var count = 0, result = [];\\n\\n        if (iterable.length === 0) {\\n            resolve(result);\\n        }\\n\\n        function resolver(i) {\\n            return function (x) {\\n                result[i] = x;\\n                count += 1;\\n\\n                if (count === iterable.length) {\\n                    resolve(result);\\n                }\\n            };\\n        }\\n\\n        for (var i = 0; i \\u003C iterable.length; i += 1) {\\n            Promise$1.resolve(iterable[i]).then(resolver(i), reject);\\n        }\\n    });\\n};\\n\\nPromise$1.race = function race(iterable) {\\n    return new Promise$1(function (resolve, reject) {\\n        for (var i = 0; i \\u003C iterable.length; i += 1) {\\n            Promise$1.resolve(iterable[i]).then(resolve, reject);\\n        }\\n    });\\n};\\n\\nvar p$1 = Promise$1.prototype;\\n\\np$1.resolve = function resolve(x) {\\n    var promise = this;\\n\\n    if (promise.state === PENDING) {\\n        if (x === promise) {\\n            throw new TypeError('Promise settled with itself.');\\n        }\\n\\n        var called = false;\\n\\n        try {\\n            var then = x && x['then'];\\n\\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\\n                then.call(x, function (x) {\\n                    if (!called) {\\n                        promise.resolve(x);\\n                    }\\n                    called = true;\\n\\n                }, function (r) {\\n                    if (!called) {\\n                        promise.reject(r);\\n                    }\\n                    called = true;\\n                });\\n                return;\\n            }\\n        } catch (e) {\\n            if (!called) {\\n                promise.reject(e);\\n            }\\n            return;\\n        }\\n\\n        promise.state = RESOLVED;\\n        promise.value = x;\\n        promise.notify();\\n    }\\n};\\n\\np$1.reject = function reject(reason) {\\n    var promise = this;\\n\\n    if (promise.state === PENDING) {\\n        if (reason === promise) {\\n            throw new TypeError('Promise settled with itself.');\\n        }\\n\\n        promise.state = REJECTED;\\n        promise.value = reason;\\n        promise.notify();\\n    }\\n};\\n\\np$1.notify = function notify() {\\n    var promise = this;\\n\\n    nextTick(function () {\\n        if (promise.state !== PENDING) {\\n            while (promise.deferred.length) {\\n                var deferred = promise.deferred.shift(),\\n                    onResolved = deferred[0],\\n                    onRejected = deferred[1],\\n                    resolve = deferred[2],\\n                    reject = deferred[3];\\n\\n                try {\\n                    if (promise.state === RESOLVED) {\\n                        if (typeof onResolved === 'function') {\\n                            resolve(onResolved.call(undefined, promise.value));\\n                        } else {\\n                            resolve(promise.value);\\n                        }\\n                    } else if (promise.state === REJECTED) {\\n                        if (typeof onRejected === 'function') {\\n                            resolve(onRejected.call(undefined, promise.value));\\n                        } else {\\n                            reject(promise.value);\\n                        }\\n                    }\\n                } catch (e) {\\n                    reject(e);\\n                }\\n            }\\n        }\\n    });\\n};\\n\\np$1.then = function then(onResolved, onRejected) {\\n    var promise = this;\\n\\n    return new Promise$1(function (resolve, reject) {\\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\\n        promise.notify();\\n    });\\n};\\n\\np$1.catch = function (onRejected) {\\n    return this.then(undefined, onRejected);\\n};\\n\\n\\u002F**\\n * Promise adapter.\\n *\\u002F\\n\\nif (typeof Promise === 'undefined') {\\n    window.Promise = Promise$1;\\n}\\n\\nfunction PromiseObj(executor, context) {\\n\\n    if (executor instanceof Promise) {\\n        this.promise = executor;\\n    } else {\\n        this.promise = new Promise(executor.bind(context));\\n    }\\n\\n    this.context = context;\\n}\\n\\nPromiseObj.all = function (iterable, context) {\\n    return new PromiseObj(Promise.all(iterable), context);\\n};\\n\\nPromiseObj.resolve = function (value, context) {\\n    return new PromiseObj(Promise.resolve(value), context);\\n};\\n\\nPromiseObj.reject = function (reason, context) {\\n    return new PromiseObj(Promise.reject(reason), context);\\n};\\n\\nPromiseObj.race = function (iterable, context) {\\n    return new PromiseObj(Promise.race(iterable), context);\\n};\\n\\nvar p = PromiseObj.prototype;\\n\\np.bind = function (context) {\\n    this.context = context;\\n    return this;\\n};\\n\\np.then = function (fulfilled, rejected) {\\n\\n    if (fulfilled && fulfilled.bind && this.context) {\\n        fulfilled = fulfilled.bind(this.context);\\n    }\\n\\n    if (rejected && rejected.bind && this.context) {\\n        rejected = rejected.bind(this.context);\\n    }\\n\\n    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);\\n};\\n\\np.catch = function (rejected) {\\n\\n    if (rejected && rejected.bind && this.context) {\\n        rejected = rejected.bind(this.context);\\n    }\\n\\n    return new PromiseObj(this.promise.catch(rejected), this.context);\\n};\\n\\np.finally = function (callback) {\\n\\n    return this.then(function (value) {\\n            callback.call(this);\\n            return value;\\n        }, function (reason) {\\n            callback.call(this);\\n            return Promise.reject(reason);\\n        }\\n    );\\n};\\n\\n\\u002F**\\n * Utility functions.\\n *\\u002F\\n\\nvar debug = false;\\nvar util = {};\\nvar ref = {};\\nvar hasOwnProperty = ref.hasOwnProperty;\\n\\nvar ref$1 = [];\\nvar slice = ref$1.slice;\\n\\nvar inBrowser = typeof window !== 'undefined';\\n\\nvar Util = function (Vue) {\\n    util = Vue.util;\\n    debug = Vue.config.debug || !Vue.config.silent;\\n};\\n\\nfunction warn(msg) {\\n    if (typeof console !== 'undefined' && debug) {\\n        console.warn('[VueResource warn]: ' + msg);\\n    }\\n}\\n\\nfunction error(msg) {\\n    if (typeof console !== 'undefined') {\\n        console.error(msg);\\n    }\\n}\\n\\nfunction nextTick(cb, ctx) {\\n    return util.nextTick(cb, ctx);\\n}\\n\\nfunction trim(str) {\\n    return str ? str.replace(\\u002F^\\\\s*|\\\\s*$\\u002Fg, '') : '';\\n}\\n\\nfunction toLower(str) {\\n    return str ? str.toLowerCase() : '';\\n}\\n\\nfunction toUpper(str) {\\n    return str ? str.toUpperCase() : '';\\n}\\n\\nvar isArray = Array.isArray;\\n\\nfunction isString(val) {\\n    return typeof val === 'string';\\n}\\n\\n\\n\\nfunction isFunction(val) {\\n    return typeof val === 'function';\\n}\\n\\nfunction isObject(obj) {\\n    return obj !== null && typeof obj === 'object';\\n}\\n\\nfunction isPlainObject(obj) {\\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\\n}\\n\\nfunction isBlob(obj) {\\n    return typeof Blob !== 'undefined' && obj instanceof Blob;\\n}\\n\\nfunction isFormData(obj) {\\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\\n}\\n\\nfunction when(value, fulfilled, rejected) {\\n\\n    var promise = PromiseObj.resolve(value);\\n\\n    if (arguments.length \\u003C 2) {\\n        return promise;\\n    }\\n\\n    return promise.then(fulfilled, rejected);\\n}\\n\\nfunction options(fn, obj, opts) {\\n\\n    opts = opts || {};\\n\\n    if (isFunction(opts)) {\\n        opts = opts.call(obj);\\n    }\\n\\n    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});\\n}\\n\\nfunction each(obj, iterator) {\\n\\n    var i, key;\\n\\n    if (isArray(obj)) {\\n        for (i = 0; i \\u003C obj.length; i++) {\\n            iterator.call(obj[i], obj[i], i);\\n        }\\n    } else if (isObject(obj)) {\\n        for (key in obj) {\\n            if (hasOwnProperty.call(obj, key)) {\\n                iterator.call(obj[key], obj[key], key);\\n            }\\n        }\\n    }\\n\\n    return obj;\\n}\\n\\nvar assign = Object.assign || _assign;\\n\\nfunction merge(target) {\\n\\n    var args = slice.call(arguments, 1);\\n\\n    args.forEach(function (source) {\\n        _merge(target, source, true);\\n    });\\n\\n    return target;\\n}\\n\\nfunction defaults(target) {\\n\\n    var args = slice.call(arguments, 1);\\n\\n    args.forEach(function (source) {\\n\\n        for (var key in source) {\\n            if (target[key] === undefined) {\\n                target[key] = source[key];\\n            }\\n        }\\n\\n    });\\n\\n    return target;\\n}\\n\\nfunction _assign(target) {\\n\\n    var args = slice.call(arguments, 1);\\n\\n    args.forEach(function (source) {\\n        _merge(target, source);\\n    });\\n\\n    return target;\\n}\\n\\nfunction _merge(target, source, deep) {\\n    for (var key in source) {\\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\\n                target[key] = {};\\n            }\\n            if (isArray(source[key]) && !isArray(target[key])) {\\n                target[key] = [];\\n            }\\n            _merge(target[key], source[key], deep);\\n        } else if (source[key] !== undefined) {\\n            target[key] = source[key];\\n        }\\n    }\\n}\\n\\n\\u002F**\\n * Root Prefix Transform.\\n *\\u002F\\n\\nvar root = function (options$$1, next) {\\n\\n    var url = next(options$$1);\\n\\n    if (isString(options$$1.root) && !url.match(\\u002F^(https?:)?\\\\\\u002F\\u002F)) {\\n        url = options$$1.root + '\\u002F' + url;\\n    }\\n\\n    return url;\\n};\\n\\n\\u002F**\\n * Query Parameter Transform.\\n *\\u002F\\n\\nvar query = function (options$$1, next) {\\n\\n    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);\\n\\n    each(options$$1.params, function (value, key) {\\n        if (urlParams.indexOf(key) === -1) {\\n            query[key] = value;\\n        }\\n    });\\n\\n    query = Url.params(query);\\n\\n    if (query) {\\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\\n    }\\n\\n    return url;\\n};\\n\\n\\u002F**\\n * URL Template v2.0.6 (https:\\u002F\\u002Fgithub.com\\u002Fbramstein\\u002Furl-template)\\n *\\u002F\\n\\nfunction expand(url, params, variables) {\\n\\n    var tmpl = parse(url), expanded = tmpl.expand(params);\\n\\n    if (variables) {\\n        variables.push.apply(variables, tmpl.vars);\\n    }\\n\\n    return expanded;\\n}\\n\\nfunction parse(template) {\\n\\n    var operators = ['+', '#', '.', '\\u002F', ';', '?', '&'], variables = [];\\n\\n    return {\\n        vars: variables,\\n        expand: function expand(context) {\\n            return template.replace(\\u002F\\\\{([^\\\\{\\\\}]+)\\\\}|([^\\\\{\\\\}]+)\\u002Fg, function (_, expression, literal) {\\n                if (expression) {\\n\\n                    var operator = null, values = [];\\n\\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\\n                        operator = expression.charAt(0);\\n                        expression = expression.substr(1);\\n                    }\\n\\n                    expression.split(\\u002F,\\u002Fg).forEach(function (variable) {\\n                        var tmp = \\u002F([^:\\\\*]*)(?::(\\\\d+)|(\\\\*))?\\u002F.exec(variable);\\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\\n                        variables.push(tmp[1]);\\n                    });\\n\\n                    if (operator && operator !== '+') {\\n\\n                        var separator = ',';\\n\\n                        if (operator === '?') {\\n                            separator = '&';\\n                        } else if (operator !== '#') {\\n                            separator = operator;\\n                        }\\n\\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\\n                    } else {\\n                        return values.join(',');\\n                    }\\n\\n                } else {\\n                    return encodeReserved(literal);\\n                }\\n            });\\n        }\\n    };\\n}\\n\\nfunction getValues(context, operator, key, modifier) {\\n\\n    var value = context[key], result = [];\\n\\n    if (isDefined(value) && value !== '') {\\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\\n            value = value.toString();\\n\\n            if (modifier && modifier !== '*') {\\n                value = value.substring(0, parseInt(modifier, 10));\\n            }\\n\\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\\n        } else {\\n            if (modifier === '*') {\\n                if (Array.isArray(value)) {\\n                    value.filter(isDefined).forEach(function (value) {\\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\\n                    });\\n                } else {\\n                    Object.keys(value).forEach(function (k) {\\n                        if (isDefined(value[k])) {\\n                            result.push(encodeValue(operator, value[k], k));\\n                        }\\n                    });\\n                }\\n            } else {\\n                var tmp = [];\\n\\n                if (Array.isArray(value)) {\\n                    value.filter(isDefined).forEach(function (value) {\\n                        tmp.push(encodeValue(operator, value));\\n                    });\\n                } else {\\n                    Object.keys(value).forEach(function (k) {\\n                        if (isDefined(value[k])) {\\n                            tmp.push(encodeURIComponent(k));\\n                            tmp.push(encodeValue(operator, value[k].toString()));\\n                        }\\n                    });\\n                }\\n\\n                if (isKeyOperator(operator)) {\\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\\n                } else if (tmp.length !== 0) {\\n                    result.push(tmp.join(','));\\n                }\\n            }\\n        }\\n    } else {\\n        if (operator === ';') {\\n            result.push(encodeURIComponent(key));\\n        } else if (value === '' && (operator === '&' || operator === '?')) {\\n            result.push(encodeURIComponent(key) + '=');\\n        } else if (value === '') {\\n            result.push('');\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nfunction isDefined(value) {\\n    return value !== undefined && value !== null;\\n}\\n\\nfunction isKeyOperator(operator) {\\n    return operator === ';' || operator === '&' || operator === '?';\\n}\\n\\nfunction encodeValue(operator, value, key) {\\n\\n    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);\\n\\n    if (key) {\\n        return encodeURIComponent(key) + '=' + value;\\n    } else {\\n        return value;\\n    }\\n}\\n\\nfunction encodeReserved(str) {\\n    return str.split(\\u002F(%[0-9A-Fa-f]{2})\\u002Fg).map(function (part) {\\n        if (!\\u002F%[0-9A-Fa-f]\\u002F.test(part)) {\\n            part = encodeURI(part);\\n        }\\n        return part;\\n    }).join('');\\n}\\n\\n\\u002F**\\n * URL Template (RFC 6570) Transform.\\n *\\u002F\\n\\nvar template = function (options) {\\n\\n    var variables = [], url = expand(options.url, options.params, variables);\\n\\n    variables.forEach(function (key) {\\n        delete options.params[key];\\n    });\\n\\n    return url;\\n};\\n\\n\\u002F**\\n * Service for URL templating.\\n *\\u002F\\n\\nfunction Url(url, params) {\\n\\n    var self = this || {}, options$$1 = url, transform;\\n\\n    if (isString(url)) {\\n        options$$1 = {url: url, params: params};\\n    }\\n\\n    options$$1 = merge({}, Url.options, self.$options, options$$1);\\n\\n    Url.transforms.forEach(function (handler) {\\n        transform = factory(handler, transform, self.$vm);\\n    });\\n\\n    return transform(options$$1);\\n}\\n\\n\\u002F**\\n * Url options.\\n *\\u002F\\n\\nUrl.options = {\\n    url: '',\\n    root: null,\\n    params: {}\\n};\\n\\n\\u002F**\\n * Url transforms.\\n *\\u002F\\n\\nUrl.transforms = [template, query, root];\\n\\n\\u002F**\\n * Encodes a Url parameter string.\\n *\\n * @param {Object} obj\\n *\\u002F\\n\\nUrl.params = function (obj) {\\n\\n    var params = [], escape = encodeURIComponent;\\n\\n    params.add = function (key, value) {\\n\\n        if (isFunction(value)) {\\n            value = value();\\n        }\\n\\n        if (value === null) {\\n            value = '';\\n        }\\n\\n        this.push(escape(key) + '=' + escape(value));\\n    };\\n\\n    serialize(params, obj);\\n\\n    return params.join('&').replace(\\u002F%20\\u002Fg, '+');\\n};\\n\\n\\u002F**\\n * Parse a URL and return its components.\\n *\\n * @param {String} url\\n *\\u002F\\n\\nUrl.parse = function (url) {\\n\\n    var el = document.createElement('a');\\n\\n    if (document.documentMode) {\\n        el.href = url;\\n        url = el.href;\\n    }\\n\\n    el.href = url;\\n\\n    return {\\n        href: el.href,\\n        protocol: el.protocol ? el.protocol.replace(\\u002F:$\\u002F, '') : '',\\n        port: el.port,\\n        host: el.host,\\n        hostname: el.hostname,\\n        pathname: el.pathname.charAt(0) === '\\u002F' ? el.pathname : '\\u002F' + el.pathname,\\n        search: el.search ? el.search.replace(\\u002F^\\\\?\\u002F, '') : '',\\n        hash: el.hash ? el.hash.replace(\\u002F^#\\u002F, '') : ''\\n    };\\n};\\n\\nfunction factory(handler, next, vm) {\\n    return function (options$$1) {\\n        return handler.call(vm, options$$1, next);\\n    };\\n}\\n\\nfunction serialize(params, obj, scope) {\\n\\n    var array = isArray(obj), plain = isPlainObject(obj), hash;\\n\\n    each(obj, function (value, key) {\\n\\n        hash = isObject(value) || isArray(value);\\n\\n        if (scope) {\\n            key = scope + '[' + (plain || hash ? key : '') + ']';\\n        }\\n\\n        if (!scope && array) {\\n            params.add(value.name, value.value);\\n        } else if (hash) {\\n            serialize(params, value, key);\\n        } else {\\n            params.add(key, value);\\n        }\\n    });\\n}\\n\\n\\u002F**\\n * XDomain client (Internet Explorer).\\n *\\u002F\\n\\nvar xdrClient = function (request) {\\n    return new PromiseObj(function (resolve) {\\n\\n        var xdr = new XDomainRequest(), handler = function (ref) {\\n            var type = ref.type;\\n\\n\\n            var status = 0;\\n\\n            if (type === 'load') {\\n                status = 200;\\n            } else if (type === 'error') {\\n                status = 500;\\n            }\\n\\n            resolve(request.respondWith(xdr.responseText, {status: status}));\\n        };\\n\\n        request.abort = function () { return xdr.abort(); };\\n\\n        xdr.open(request.method, request.getUrl());\\n\\n        if (request.timeout) {\\n            xdr.timeout = request.timeout;\\n        }\\n\\n        xdr.onload = handler;\\n        xdr.onabort = handler;\\n        xdr.onerror = handler;\\n        xdr.ontimeout = handler;\\n        xdr.onprogress = function () {};\\n        xdr.send(request.getBody());\\n    });\\n};\\n\\n\\u002F**\\n * CORS Interceptor.\\n *\\u002F\\n\\nvar SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();\\n\\nvar cors = function (request, next) {\\n\\n    if (inBrowser) {\\n\\n        var orgUrl = Url.parse(location.href);\\n        var reqUrl = Url.parse(request.getUrl());\\n\\n        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {\\n\\n            request.crossOrigin = true;\\n            request.emulateHTTP = false;\\n\\n            if (!SUPPORTS_CORS) {\\n                request.client = xdrClient;\\n            }\\n        }\\n    }\\n\\n    next();\\n};\\n\\n\\u002F**\\n * Body Interceptor.\\n *\\u002F\\n\\nvar body = function (request, next) {\\n\\n    if (isFormData(request.body)) {\\n\\n        request.headers.delete('Content-Type');\\n\\n    } else if (isObject(request.body) || isArray(request.body)) {\\n\\n        if (request.emulateJSON) {\\n            request.body = Url.params(request.body);\\n            request.headers.set('Content-Type', 'application\\u002Fx-www-form-urlencoded');\\n        } else {\\n            request.body = JSON.stringify(request.body);\\n        }\\n    }\\n\\n    next(function (response) {\\n\\n        Object.defineProperty(response, 'data', {\\n\\n            get: function get() {\\n                return this.body;\\n            },\\n\\n            set: function set(body) {\\n                this.body = body;\\n            }\\n\\n        });\\n\\n        return response.bodyText ? when(response.text(), function (text) {\\n\\n            var type = response.headers.get('Content-Type') || '';\\n\\n            if (type.indexOf('application\\u002Fjson') === 0 || isJson(text)) {\\n\\n                try {\\n                    response.body = JSON.parse(text);\\n                } catch (e) {\\n                    response.body = null;\\n                }\\n\\n            } else {\\n                response.body = text;\\n            }\\n\\n            return response;\\n\\n        }) : response;\\n\\n    });\\n};\\n\\nfunction isJson(str) {\\n\\n    var start = str.match(\\u002F^\\\\[|^\\\\{(?!\\\\{)\\u002F), end = {'[': \\u002F]$\\u002F, '{': \\u002F}$\\u002F};\\n\\n    return start && end[start[0]].test(str);\\n}\\n\\n\\u002F**\\n * JSONP client (Browser).\\n *\\u002F\\n\\nvar jsonpClient = function (request) {\\n    return new PromiseObj(function (resolve) {\\n\\n        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;\\n\\n        handler = function (ref) {\\n            var type = ref.type;\\n\\n\\n            var status = 0;\\n\\n            if (type === 'load' && body !== null) {\\n                status = 200;\\n            } else if (type === 'error') {\\n                status = 500;\\n            }\\n\\n            if (status && window[callback]) {\\n                delete window[callback];\\n                document.body.removeChild(script);\\n            }\\n\\n            resolve(request.respondWith(body, {status: status}));\\n        };\\n\\n        window[callback] = function (result) {\\n            body = JSON.stringify(result);\\n        };\\n\\n        request.abort = function () {\\n            handler({type: 'abort'});\\n        };\\n\\n        request.params[name] = callback;\\n\\n        if (request.timeout) {\\n            setTimeout(request.abort, request.timeout);\\n        }\\n\\n        script = document.createElement('script');\\n        script.src = request.getUrl();\\n        script.type = 'text\\u002Fjavascript';\\n        script.async = true;\\n        script.onload = handler;\\n        script.onerror = handler;\\n\\n        document.body.appendChild(script);\\n    });\\n};\\n\\n\\u002F**\\n * JSONP Interceptor.\\n *\\u002F\\n\\nvar jsonp = function (request, next) {\\n\\n    if (request.method == 'JSONP') {\\n        request.client = jsonpClient;\\n    }\\n\\n    next();\\n};\\n\\n\\u002F**\\n * Before Interceptor.\\n *\\u002F\\n\\nvar before = function (request, next) {\\n\\n    if (isFunction(request.before)) {\\n        request.before.call(this, request);\\n    }\\n\\n    next();\\n};\\n\\n\\u002F**\\n * HTTP method override Interceptor.\\n *\\u002F\\n\\nvar method = function (request, next) {\\n\\n    if (request.emulateHTTP && \\u002F^(PUT|PATCH|DELETE)$\\u002Fi.test(request.method)) {\\n        request.headers.set('X-HTTP-Method-Override', request.method);\\n        request.method = 'POST';\\n    }\\n\\n    next();\\n};\\n\\n\\u002F**\\n * Header Interceptor.\\n *\\u002F\\n\\nvar header = function (request, next) {\\n\\n    var headers = assign({}, Http.headers.common,\\n        !request.crossOrigin ? Http.headers.custom : {},\\n        Http.headers[toLower(request.method)]\\n    );\\n\\n    each(headers, function (value, name) {\\n        if (!request.headers.has(name)) {\\n            request.headers.set(name, value);\\n        }\\n    });\\n\\n    next();\\n};\\n\\n\\u002F**\\n * XMLHttp client (Browser).\\n *\\u002F\\n\\nvar SUPPORTS_BLOB = typeof Blob !== 'undefined' && typeof FileReader !== 'undefined';\\n\\nvar xhrClient = function (request) {\\n    return new PromiseObj(function (resolve) {\\n\\n        var xhr = new XMLHttpRequest(), handler = function (event) {\\n\\n            var response = request.respondWith(\\n                'response' in xhr ? xhr.response : xhr.responseText, {\\n                    status: xhr.status === 1223 ? 204 : xhr.status, \\u002F\\u002F IE9 status bug\\n                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)\\n                }\\n            );\\n\\n            each(trim(xhr.getAllResponseHeaders()).split('\\\\n'), function (row) {\\n                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));\\n            });\\n\\n            resolve(response);\\n        };\\n\\n        request.abort = function () { return xhr.abort(); };\\n\\n        if (request.progress) {\\n            if (request.method === 'GET') {\\n                xhr.addEventListener('progress', request.progress);\\n            } else if (\\u002F^(POST|PUT)$\\u002Fi.test(request.method)) {\\n                xhr.upload.addEventListener('progress', request.progress);\\n            }\\n        }\\n\\n        xhr.open(request.method, request.getUrl(), true);\\n\\n        if (request.timeout) {\\n            xhr.timeout = request.timeout;\\n        }\\n\\n        if (request.credentials === true) {\\n            xhr.withCredentials = true;\\n        }\\n\\n        if (!request.crossOrigin) {\\n            request.headers.set('X-Requested-With', 'XMLHttpRequest');\\n        }\\n\\n        if ('responseType' in xhr && SUPPORTS_BLOB) {\\n            xhr.responseType = 'blob';\\n        }\\n\\n        request.headers.forEach(function (value, name) {\\n            xhr.setRequestHeader(name, value);\\n        });\\n\\n        xhr.onload = handler;\\n        xhr.onabort = handler;\\n        xhr.onerror = handler;\\n        xhr.ontimeout = handler;\\n        xhr.send(request.getBody());\\n    });\\n};\\n\\n\\u002F**\\n * Http client (Node).\\n *\\u002F\\n\\nvar nodeClient = function (request) {\\n\\n    var client = __webpack_require__(31);\\n\\n    return new PromiseObj(function (resolve) {\\n\\n        var url = request.getUrl();\\n        var body = request.getBody();\\n        var method = request.method;\\n        var headers = {}, handler;\\n\\n        request.headers.forEach(function (value, name) {\\n            headers[name] = value;\\n        });\\n\\n        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {\\n\\n            var response = request.respondWith(resp.body, {\\n                    status: resp.statusCode,\\n                    statusText: trim(resp.statusMessage)\\n                }\\n            );\\n\\n            each(resp.headers, function (value, name) {\\n                response.headers.set(name, value);\\n            });\\n\\n            resolve(response);\\n\\n        }, function (error$$1) { return handler(error$$1.response); });\\n    });\\n};\\n\\n\\u002F**\\n * Base client.\\n *\\u002F\\n\\nvar Client = function (context) {\\n\\n    var reqHandlers = [sendRequest], resHandlers = [], handler;\\n\\n    if (!isObject(context)) {\\n        context = null;\\n    }\\n\\n    function Client(request) {\\n        return new PromiseObj(function (resolve) {\\n\\n            function exec() {\\n\\n                handler = reqHandlers.pop();\\n\\n                if (isFunction(handler)) {\\n                    handler.call(context, request, next);\\n                } else {\\n                    warn((\\\"Invalid interceptor of type \\\" + (typeof handler) + \\\", must be a function\\\"));\\n                    next();\\n                }\\n            }\\n\\n            function next(response) {\\n\\n                if (isFunction(response)) {\\n\\n                    resHandlers.unshift(response);\\n\\n                } else if (isObject(response)) {\\n\\n                    resHandlers.forEach(function (handler) {\\n                        response = when(response, function (response) {\\n                            return handler.call(context, response) || response;\\n                        });\\n                    });\\n\\n                    when(response, resolve);\\n\\n                    return;\\n                }\\n\\n                exec();\\n            }\\n\\n            exec();\\n\\n        }, context);\\n    }\\n\\n    Client.use = function (handler) {\\n        reqHandlers.push(handler);\\n    };\\n\\n    return Client;\\n};\\n\\nfunction sendRequest(request, resolve) {\\n\\n    var client = request.client || (inBrowser ? xhrClient : nodeClient);\\n\\n    resolve(client(request));\\n}\\n\\n\\u002F**\\n * HTTP Headers.\\n *\\u002F\\n\\nvar Headers = function Headers(headers) {\\n    var this$1 = this;\\n\\n\\n    this.map = {};\\n\\n    each(headers, function (value, name) { return this$1.append(name, value); });\\n};\\n\\nHeaders.prototype.has = function has (name) {\\n    return getName(this.map, name) !== null;\\n};\\n\\nHeaders.prototype.get = function get (name) {\\n\\n    var list = this.map[getName(this.map, name)];\\n\\n    return list ? list[0] : null;\\n};\\n\\nHeaders.prototype.getAll = function getAll (name) {\\n    return this.map[getName(this.map, name)] || [];\\n};\\n\\nHeaders.prototype.set = function set (name, value) {\\n    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];\\n};\\n\\nHeaders.prototype.append = function append (name, value){\\n\\n    var list = this.getAll(name);\\n\\n    if (list.length) {\\n        list.push(trim(value));\\n    } else {\\n        this.set(name, value);\\n    }\\n};\\n\\nHeaders.prototype.delete = function delete$1 (name){\\n    delete this.map[getName(this.map, name)];\\n};\\n\\nHeaders.prototype.deleteAll = function deleteAll (){\\n    this.map = {};\\n};\\n\\nHeaders.prototype.forEach = function forEach (callback, thisArg) {\\n        var this$1 = this;\\n\\n    each(this.map, function (list, name) {\\n        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });\\n    });\\n};\\n\\nfunction getName(map, name) {\\n    return Object.keys(map).reduce(function (prev, curr) {\\n        return toLower(name) === toLower(curr) ? curr : prev;\\n    }, null);\\n}\\n\\nfunction normalizeName(name) {\\n\\n    if (\\u002F[^a-z0-9\\\\-#$%&'*+.\\\\^_`|~]\\u002Fi.test(name)) {\\n        throw new TypeError('Invalid character in header field name');\\n    }\\n\\n    return trim(name);\\n}\\n\\n\\u002F**\\n * HTTP Response.\\n *\\u002F\\n\\nvar Response = function Response(body, ref) {\\n    var url = ref.url;\\n    var headers = ref.headers;\\n    var status = ref.status;\\n    var statusText = ref.statusText;\\n\\n\\n    this.url = url;\\n    this.ok = status \\u003E= 200 && status \\u003C 300;\\n    this.status = status || 0;\\n    this.statusText = statusText || '';\\n    this.headers = new Headers(headers);\\n    this.body = body;\\n\\n    if (isString(body)) {\\n\\n        this.bodyText = body;\\n\\n    } else if (isBlob(body)) {\\n\\n        this.bodyBlob = body;\\n\\n        if (isBlobText(body)) {\\n            this.bodyText = blobText(body);\\n        }\\n    }\\n};\\n\\nResponse.prototype.blob = function blob () {\\n    return when(this.bodyBlob);\\n};\\n\\nResponse.prototype.text = function text () {\\n    return when(this.bodyText);\\n};\\n\\nResponse.prototype.json = function json () {\\n    return when(this.text(), function (text) { return JSON.parse(text); });\\n};\\n\\nfunction blobText(body) {\\n    return new PromiseObj(function (resolve) {\\n\\n        var reader = new FileReader();\\n\\n        reader.readAsText(body);\\n        reader.onload = function () {\\n            resolve(reader.result);\\n        };\\n\\n    });\\n}\\n\\nfunction isBlobText(body) {\\n    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;\\n}\\n\\n\\u002F**\\n * HTTP Request.\\n *\\u002F\\n\\nvar Request = function Request(options$$1) {\\n\\n    this.body = null;\\n    this.params = {};\\n\\n    assign(this, options$$1, {\\n        method: toUpper(options$$1.method || 'GET')\\n    });\\n\\n    if (!(this.headers instanceof Headers)) {\\n        this.headers = new Headers(this.headers);\\n    }\\n};\\n\\nRequest.prototype.getUrl = function getUrl (){\\n    return Url(this);\\n};\\n\\nRequest.prototype.getBody = function getBody (){\\n    return this.body;\\n};\\n\\nRequest.prototype.respondWith = function respondWith (body, options$$1) {\\n    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));\\n};\\n\\n\\u002F**\\n * Service for sending network requests.\\n *\\u002F\\n\\nvar COMMON_HEADERS = {'Accept': 'application\\u002Fjson, text\\u002Fplain, *\\u002F*'};\\nvar JSON_CONTENT_TYPE = {'Content-Type': 'application\\u002Fjson;charset=utf-8'};\\n\\nfunction Http(options$$1) {\\n\\n    var self = this || {}, client = Client(self.$vm);\\n\\n    defaults(options$$1 || {}, self.$options, Http.options);\\n\\n    Http.interceptors.forEach(function (handler) {\\n        client.use(handler);\\n    });\\n\\n    return client(new Request(options$$1)).then(function (response) {\\n\\n        return response.ok ? response : PromiseObj.reject(response);\\n\\n    }, function (response) {\\n\\n        if (response instanceof Error) {\\n            error(response);\\n        }\\n\\n        return PromiseObj.reject(response);\\n    });\\n}\\n\\nHttp.options = {};\\n\\nHttp.headers = {\\n    put: JSON_CONTENT_TYPE,\\n    post: JSON_CONTENT_TYPE,\\n    patch: JSON_CONTENT_TYPE,\\n    delete: JSON_CONTENT_TYPE,\\n    common: COMMON_HEADERS,\\n    custom: {}\\n};\\n\\nHttp.interceptors = [before, method, body, jsonp, header, cors];\\n\\n['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {\\n\\n    Http[method$$1] = function (url, options$$1) {\\n        return this(assign(options$$1 || {}, {url: url, method: method$$1}));\\n    };\\n\\n});\\n\\n['post', 'put', 'patch'].forEach(function (method$$1) {\\n\\n    Http[method$$1] = function (url, body$$1, options$$1) {\\n        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body$$1}));\\n    };\\n\\n});\\n\\n\\u002F**\\n * Service for interacting with RESTful services.\\n *\\u002F\\n\\nfunction Resource(url, params, actions, options$$1) {\\n\\n    var self = this || {}, resource = {};\\n\\n    actions = assign({},\\n        Resource.actions,\\n        actions\\n    );\\n\\n    each(actions, function (action, name) {\\n\\n        action = merge({url: url, params: assign({}, params)}, options$$1, action);\\n\\n        resource[name] = function () {\\n            return (self.$http || Http)(opts(action, arguments));\\n        };\\n    });\\n\\n    return resource;\\n}\\n\\nfunction opts(action, args) {\\n\\n    var options$$1 = assign({}, action), params = {}, body;\\n\\n    switch (args.length) {\\n\\n        case 2:\\n\\n            params = args[0];\\n            body = args[1];\\n\\n            break;\\n\\n        case 1:\\n\\n            if (\\u002F^(POST|PUT|PATCH)$\\u002Fi.test(options$$1.method)) {\\n                body = args[0];\\n            } else {\\n                params = args[0];\\n            }\\n\\n            break;\\n\\n        case 0:\\n\\n            break;\\n\\n        default:\\n\\n            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';\\n    }\\n\\n    options$$1.body = body;\\n    options$$1.params = assign({}, options$$1.params, params);\\n\\n    return options$$1;\\n}\\n\\nResource.actions = {\\n\\n    get: {method: 'GET'},\\n    save: {method: 'POST'},\\n    query: {method: 'GET'},\\n    update: {method: 'PUT'},\\n    remove: {method: 'DELETE'},\\n    delete: {method: 'DELETE'}\\n\\n};\\n\\n\\u002F**\\n * Install plugin.\\n *\\u002F\\n\\nfunction plugin(Vue) {\\n\\n    if (plugin.installed) {\\n        return;\\n    }\\n\\n    Util(Vue);\\n\\n    Vue.url = Url;\\n    Vue.http = Http;\\n    Vue.resource = Resource;\\n    Vue.Promise = PromiseObj;\\n\\n    Object.defineProperties(Vue.prototype, {\\n\\n        $url: {\\n            get: function get() {\\n                return options(Vue.url, this, this.$options.url);\\n            }\\n        },\\n\\n        $http: {\\n            get: function get() {\\n                return options(Vue.http, this, this.$options.http);\\n            }\\n        },\\n\\n        $resource: {\\n            get: function get() {\\n                return Vue.resource.bind(this);\\n            }\\n        },\\n\\n        $promise: {\\n            get: function get() {\\n                var this$1 = this;\\n\\n                return function (executor) { return new Vue.Promise(executor, this$1); };\\n            }\\n        }\\n\\n    });\\n}\\n\\nif (typeof window !== 'undefined' && window.Vue) {\\n    window.Vue.use(plugin);\\n}\\n\\nmodule.exports = plugin;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 31 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nconst EventEmitter = __webpack_require__(32);\\nconst http = __webpack_require__(33);\\nconst https = __webpack_require__(34);\\nconst PassThrough = __webpack_require__(2).PassThrough;\\nconst urlLib = __webpack_require__(7);\\nconst querystring = __webpack_require__(35);\\nconst duplexer3 = __webpack_require__(36);\\nconst isStream = __webpack_require__(37);\\nconst getStream = __webpack_require__(38);\\nconst timedOut = __webpack_require__(42);\\nconst urlParseLax = __webpack_require__(43);\\nconst lowercaseKeys = __webpack_require__(45);\\nconst isRedirect = __webpack_require__(46);\\nconst unzipResponse = __webpack_require__(47);\\nconst createErrorClass = __webpack_require__(49);\\nconst isRetryAllowed = __webpack_require__(51);\\nconst Buffer = __webpack_require__(52).Buffer;\\nconst pkg = __webpack_require__(54);\\n\\nfunction requestAsEventEmitter(opts) {\\n\\topts = opts || {};\\n\\n\\tconst ee = new EventEmitter();\\n\\tconst requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);\\n\\tlet redirectCount = 0;\\n\\tlet retryCount = 0;\\n\\tlet redirectUrl;\\n\\n\\tconst get = opts =\\u003E {\\n\\t\\tconst fn = opts.protocol === 'https:' ? https : http;\\n\\n\\t\\tconst req = fn.request(opts, res =\\u003E {\\n\\t\\t\\tconst statusCode = res.statusCode;\\n\\n\\t\\t\\tif (isRedirect(statusCode) && opts.followRedirect && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) {\\n\\t\\t\\t\\tres.resume();\\n\\n\\t\\t\\t\\tif (++redirectCount \\u003E 10) {\\n\\t\\t\\t\\t\\tee.emit('error', new got.MaxRedirectsError(statusCode, opts), null, res);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tconst bufferString = Buffer.from(res.headers.location, 'binary').toString();\\n\\n\\t\\t\\t\\tredirectUrl = urlLib.resolve(urlLib.format(opts), bufferString);\\n\\t\\t\\t\\tconst redirectOpts = Object.assign({}, opts, urlLib.parse(redirectUrl));\\n\\n\\t\\t\\t\\tee.emit('redirect', res, redirectOpts);\\n\\n\\t\\t\\t\\tget(redirectOpts);\\n\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsetImmediate(() =\\u003E {\\n\\t\\t\\t\\tconst response = typeof unzipResponse === 'function' && req.method !== 'HEAD' ? unzipResponse(res) : res;\\n\\t\\t\\t\\tresponse.url = redirectUrl || requestUrl;\\n\\t\\t\\t\\tresponse.requestUrl = requestUrl;\\n\\n\\t\\t\\t\\tee.emit('response', response);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treq.once('error', err =\\u003E {\\n\\t\\t\\tconst backoff = opts.retries(++retryCount, err);\\n\\n\\t\\t\\tif (backoff) {\\n\\t\\t\\t\\tsetTimeout(get, backoff, opts);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tee.emit('error', new got.RequestError(err, opts));\\n\\t\\t});\\n\\n\\t\\tif (opts.gotTimeout) {\\n\\t\\t\\ttimedOut(req, opts.gotTimeout);\\n\\t\\t}\\n\\n\\t\\tsetImmediate(() =\\u003E {\\n\\t\\t\\tee.emit('request', req);\\n\\t\\t});\\n\\t};\\n\\n\\tget(opts);\\n\\treturn ee;\\n}\\n\\nfunction asPromise(opts) {\\n\\treturn new Promise((resolve, reject) =\\u003E {\\n\\t\\tconst ee = requestAsEventEmitter(opts);\\n\\n\\t\\tee.on('request', req =\\u003E {\\n\\t\\t\\tif (isStream(opts.body)) {\\n\\t\\t\\t\\topts.body.pipe(req);\\n\\t\\t\\t\\topts.body = undefined;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\treq.end(opts.body);\\n\\t\\t});\\n\\n\\t\\tee.on('response', res =\\u003E {\\n\\t\\t\\tconst stream = opts.encoding === null ? getStream.buffer(res) : getStream(res, opts);\\n\\n\\t\\t\\tstream\\n\\t\\t\\t\\t.catch(err =\\u003E reject(new got.ReadError(err, opts)))\\n\\t\\t\\t\\t.then(data =\\u003E {\\n\\t\\t\\t\\t\\tconst statusCode = res.statusCode;\\n\\t\\t\\t\\t\\tconst limitStatusCode = opts.followRedirect ? 299 : 399;\\n\\n\\t\\t\\t\\t\\tres.body = data;\\n\\n\\t\\t\\t\\t\\tif (opts.json && res.body) {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tres.body = JSON.parse(res.body);\\n\\t\\t\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t\\t\\tthrow new got.ParseError(e, statusCode, opts, data);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (statusCode \\u003C 200 || statusCode \\u003E limitStatusCode) {\\n\\t\\t\\t\\t\\t\\tthrow new got.HTTPError(statusCode, opts);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tresolve(res);\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.catch(err =\\u003E {\\n\\t\\t\\t\\t\\tObject.defineProperty(err, 'response', {value: res});\\n\\t\\t\\t\\t\\treject(err);\\n\\t\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tee.on('error', reject);\\n\\t});\\n}\\n\\nfunction asStream(opts) {\\n\\tconst input = new PassThrough();\\n\\tconst output = new PassThrough();\\n\\tconst proxy = duplexer3(input, output);\\n\\n\\tif (opts.json) {\\n\\t\\tthrow new Error('got can not be used as stream when options.json is used');\\n\\t}\\n\\n\\tif (opts.body) {\\n\\t\\tproxy.write = () =\\u003E {\\n\\t\\t\\tthrow new Error('got\\\\'s stream is not writable when options.body is used');\\n\\t\\t};\\n\\t}\\n\\n\\tconst ee = requestAsEventEmitter(opts);\\n\\n\\tee.on('request', req =\\u003E {\\n\\t\\tproxy.emit('request', req);\\n\\n\\t\\tif (isStream(opts.body)) {\\n\\t\\t\\topts.body.pipe(req);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (opts.body) {\\n\\t\\t\\treq.end(opts.body);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\\n\\t\\t\\tinput.pipe(req);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\treq.end();\\n\\t});\\n\\n\\tee.on('response', res =\\u003E {\\n\\t\\tconst statusCode = res.statusCode;\\n\\n\\t\\tres.pipe(output);\\n\\n\\t\\tif (statusCode \\u003C 200 || statusCode \\u003E 299) {\\n\\t\\t\\tproxy.emit('error', new got.HTTPError(statusCode, opts), null, res);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tproxy.emit('response', res);\\n\\t});\\n\\n\\tee.on('redirect', proxy.emit.bind(proxy, 'redirect'));\\n\\tee.on('error', proxy.emit.bind(proxy, 'error'));\\n\\n\\treturn proxy;\\n}\\n\\nfunction normalizeArguments(url, opts) {\\n\\tif (typeof url !== 'string' && typeof url !== 'object') {\\n\\t\\tthrow new Error(`Parameter \\\\`url\\\\` must be a string or object, not ${typeof url}`);\\n\\t}\\n\\n\\tif (typeof url === 'string') {\\n\\t\\turl = url.replace(\\u002F^unix:\\u002F, 'http:\\u002F\\u002F$&');\\n\\t\\turl = urlParseLax(url);\\n\\n\\t\\tif (url.auth) {\\n\\t\\t\\tthrow new Error('Basic authentication must be done with auth option');\\n\\t\\t}\\n\\t}\\n\\n\\topts = Object.assign(\\n\\t\\t{\\n\\t\\t\\tprotocol: 'http:',\\n\\t\\t\\tpath: '',\\n\\t\\t\\tretries: 5\\n\\t\\t},\\n\\t\\turl,\\n\\t\\topts\\n\\t);\\n\\n\\topts.headers = Object.assign({\\n\\t\\t'user-agent': `${pkg.name}\\u002F${pkg.version} (https:\\u002F\\u002Fgithub.com\\u002Fsindresorhus\\u002Fgot)`,\\n\\t\\t'accept-encoding': 'gzip,deflate'\\n\\t}, lowercaseKeys(opts.headers));\\n\\n\\tconst query = opts.query;\\n\\n\\tif (query) {\\n\\t\\tif (typeof query !== 'string') {\\n\\t\\t\\topts.query = querystring.stringify(query);\\n\\t\\t}\\n\\n\\t\\topts.path = `${opts.path.split('?')[0]}?${opts.query}`;\\n\\t\\tdelete opts.query;\\n\\t}\\n\\n\\tif (opts.json && opts.headers.accept === undefined) {\\n\\t\\topts.headers.accept = 'application\\u002Fjson';\\n\\t}\\n\\n\\tlet body = opts.body;\\n\\n\\tif (body) {\\n\\t\\tif (typeof body !== 'string' && !(body !== null && typeof body === 'object')) {\\n\\t\\t\\tthrow new Error('options.body must be a ReadableStream, string, Buffer or plain Object');\\n\\t\\t}\\n\\n\\t\\topts.method = opts.method || 'POST';\\n\\n\\t\\tif (isStream(body) && typeof body.getBoundary === 'function') {\\n\\t\\t\\t\\u002F\\u002F Special case for https:\\u002F\\u002Fgithub.com\\u002Fform-data\\u002Fform-data\\n\\t\\t\\topts.headers['content-type'] = opts.headers['content-type'] || `multipart\\u002Fform-data; boundary=${body.getBoundary()}`;\\n\\t\\t} else if (body !== null && typeof body === 'object' && !Buffer.isBuffer(body) && !isStream(body)) {\\n\\t\\t\\topts.headers['content-type'] = opts.headers['content-type'] || 'application\\u002Fx-www-form-urlencoded';\\n\\t\\t\\tbody = opts.body = querystring.stringify(body);\\n\\t\\t}\\n\\n\\t\\tif (opts.headers['content-length'] === undefined && opts.headers['transfer-encoding'] === undefined && !isStream(body)) {\\n\\t\\t\\tconst length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;\\n\\t\\t\\topts.headers['content-length'] = length;\\n\\t\\t}\\n\\t}\\n\\n\\topts.method = (opts.method || 'GET').toUpperCase();\\n\\n\\tif (opts.hostname === 'unix') {\\n\\t\\tconst matches = \\u002F(.+):(.+)\\u002F.exec(opts.path);\\n\\n\\t\\tif (matches) {\\n\\t\\t\\topts.socketPath = matches[1];\\n\\t\\t\\topts.path = matches[2];\\n\\t\\t\\topts.host = null;\\n\\t\\t}\\n\\t}\\n\\n\\tif (typeof opts.retries !== 'function') {\\n\\t\\tconst retries = opts.retries;\\n\\n\\t\\topts.retries = (iter, err) =\\u003E {\\n\\t\\t\\tif (iter \\u003E retries || !isRetryAllowed(err)) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst noise = Math.random() * 100;\\n\\n\\t\\t\\treturn ((1 \\u003C\\u003C iter) * 1000) + noise;\\n\\t\\t};\\n\\t}\\n\\n\\tif (opts.followRedirect === undefined) {\\n\\t\\topts.followRedirect = true;\\n\\t}\\n\\n\\tif (opts.timeout) {\\n\\t\\topts.gotTimeout = opts.timeout;\\n\\t\\tdelete opts.timeout;\\n\\t}\\n\\n\\treturn opts;\\n}\\n\\nfunction got(url, opts) {\\n\\ttry {\\n\\t\\treturn asPromise(normalizeArguments(url, opts));\\n\\t} catch (err) {\\n\\t\\treturn Promise.reject(err);\\n\\t}\\n}\\n\\nconst helpers = [\\n\\t'get',\\n\\t'post',\\n\\t'put',\\n\\t'patch',\\n\\t'head',\\n\\t'delete'\\n];\\n\\nhelpers.forEach(el =\\u003E {\\n\\tgot[el] = (url, opts) =\\u003E got(url, Object.assign({}, opts, {method: el}));\\n});\\n\\ngot.stream = (url, opts) =\\u003E asStream(normalizeArguments(url, opts));\\n\\nfor (const el of helpers) {\\n\\tgot.stream[el] = (url, opts) =\\u003E got.stream(url, Object.assign({}, opts, {method: el}));\\n}\\n\\nfunction stdError(error, opts) {\\n\\tif (error.code !== undefined) {\\n\\t\\tthis.code = error.code;\\n\\t}\\n\\n\\tObject.assign(this, {\\n\\t\\tmessage: error.message,\\n\\t\\thost: opts.host,\\n\\t\\thostname: opts.hostname,\\n\\t\\tmethod: opts.method,\\n\\t\\tpath: opts.path\\n\\t});\\n}\\n\\ngot.RequestError = createErrorClass('RequestError', stdError);\\ngot.ReadError = createErrorClass('ReadError', stdError);\\ngot.ParseError = createErrorClass('ParseError', function (e, statusCode, opts, data) {\\n\\tstdError.call(this, e, opts);\\n\\tthis.statusCode = statusCode;\\n\\tthis.statusMessage = http.STATUS_CODES[this.statusCode];\\n\\tthis.message = `${e.message} in \\\"${urlLib.format(opts)}\\\": \\\\n${data.slice(0, 77)}...`;\\n});\\n\\ngot.HTTPError = createErrorClass('HTTPError', function (statusCode, opts) {\\n\\tstdError.call(this, {}, opts);\\n\\tthis.statusCode = statusCode;\\n\\tthis.statusMessage = http.STATUS_CODES[this.statusCode];\\n\\tthis.message = `Response code ${this.statusCode} (${this.statusMessage})`;\\n});\\n\\ngot.MaxRedirectsError = createErrorClass('MaxRedirectsError', function (statusCode, opts) {\\n\\tstdError.call(this, {}, opts);\\n\\tthis.statusCode = statusCode;\\n\\tthis.statusMessage = http.STATUS_CODES[this.statusCode];\\n\\tthis.message = 'Redirected 10 times. Aborting.';\\n});\\n\\nmodule.exports = got;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 32 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"events\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 33 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"http\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 34 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"https\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 35 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"querystring\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 36 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar stream = __webpack_require__(2);\\n\\nfunction DuplexWrapper(options, writable, readable) {\\n  if (typeof readable === \\\"undefined\\\") {\\n    readable = writable;\\n    writable = options;\\n    options = null;\\n  }\\n\\n  stream.Duplex.call(this, options);\\n\\n  if (typeof readable.read !== \\\"function\\\") {\\n    readable = (new stream.Readable(options)).wrap(readable);\\n  }\\n\\n  this._writable = writable;\\n  this._readable = readable;\\n  this._waiting = false;\\n\\n  var self = this;\\n\\n  writable.once(\\\"finish\\\", function() {\\n    self.end();\\n  });\\n\\n  this.once(\\\"finish\\\", function() {\\n    writable.end();\\n  });\\n\\n  readable.on(\\\"readable\\\", function() {\\n    if (self._waiting) {\\n      self._waiting = false;\\n      self._read();\\n    }\\n  });\\n\\n  readable.once(\\\"end\\\", function() {\\n    self.push(null);\\n  });\\n\\n  if (!options || typeof options.bubbleErrors === \\\"undefined\\\" || options.bubbleErrors) {\\n    writable.on(\\\"error\\\", function(err) {\\n      self.emit(\\\"error\\\", err);\\n    });\\n\\n    readable.on(\\\"error\\\", function(err) {\\n      self.emit(\\\"error\\\", err);\\n    });\\n  }\\n}\\n\\nDuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});\\n\\nDuplexWrapper.prototype._write = function _write(input, encoding, done) {\\n  this._writable.write(input, encoding, done);\\n};\\n\\nDuplexWrapper.prototype._read = function _read() {\\n  var buf;\\n  var reads = 0;\\n  while ((buf = this._readable.read()) !== null) {\\n    this.push(buf);\\n    reads++;\\n  }\\n  if (reads === 0) {\\n    this._waiting = true;\\n  }\\n};\\n\\nmodule.exports = function duplex2(options, writable, readable) {\\n  return new DuplexWrapper(options, writable, readable);\\n};\\n\\nmodule.exports.DuplexWrapper = DuplexWrapper;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 37 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar isStream = module.exports = function (stream) {\\n\\treturn stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';\\n};\\n\\nisStream.writable = function (stream) {\\n\\treturn isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';\\n};\\n\\nisStream.readable = function (stream) {\\n\\treturn isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';\\n};\\n\\nisStream.duplex = function (stream) {\\n\\treturn isStream.writable(stream) && isStream.readable(stream);\\n};\\n\\nisStream.transform = function (stream) {\\n\\treturn isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 38 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nvar Promise = __webpack_require__(39);\\nvar objectAssign = __webpack_require__(8);\\nvar bufferStream = __webpack_require__(41);\\n\\nfunction getStream(inputStream, opts) {\\n\\tif (!inputStream) {\\n\\t\\treturn Promise.reject(new Error('Expected a stream'));\\n\\t}\\n\\n\\topts = objectAssign({maxBuffer: Infinity}, opts);\\n\\tvar maxBuffer = opts.maxBuffer;\\n\\tvar stream;\\n\\tvar clean;\\n\\n\\tvar p = new Promise(function (resolve, reject) {\\n\\t\\tstream = bufferStream(opts);\\n\\t\\tinputStream.once('error', error);\\n\\t\\tinputStream.pipe(stream);\\n\\n\\t\\tstream.on('data', function () {\\n\\t\\t\\tif (stream.getBufferedLength() \\u003E maxBuffer) {\\n\\t\\t\\t\\treject(new Error('maxBuffer exceeded'));\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tstream.once('error', error);\\n\\t\\tstream.on('end', resolve);\\n\\n\\t\\tclean = function () {\\n\\t\\t\\t\\u002F\\u002F some streams doesn't implement the stream.Readable interface correctly\\n\\t\\t\\tif (inputStream.unpipe) {\\n\\t\\t\\t\\tinputStream.unpipe(stream);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tfunction error(err) {\\n\\t\\t\\tif (err) { \\u002F\\u002F null check\\n\\t\\t\\t\\terr.bufferedData = stream.getBufferedValue();\\n\\t\\t\\t}\\n\\t\\t\\treject(err);\\n\\t\\t}\\n\\t});\\n\\n\\tp.then(clean, clean);\\n\\n\\treturn p.then(function () {\\n\\t\\treturn stream.getBufferedValue();\\n\\t});\\n}\\n\\nmodule.exports = getStream;\\n\\nmodule.exports.buffer = function (stream, opts) {\\n\\treturn getStream(stream, objectAssign({}, opts, {encoding: 'buffer'}));\\n};\\n\\nmodule.exports.array = function (stream, opts) {\\n\\treturn getStream(stream, objectAssign({}, opts, {array: true}));\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 39 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nmodule.exports = typeof Promise === 'function' ? Promise : __webpack_require__(40);\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 40 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar PENDING = 'pending';\\nvar SETTLED = 'settled';\\nvar FULFILLED = 'fulfilled';\\nvar REJECTED = 'rejected';\\nvar NOOP = function () {};\\nvar isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';\\n\\nvar asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;\\nvar asyncQueue = [];\\nvar asyncTimer;\\n\\nfunction asyncFlush() {\\n\\t\\u002F\\u002F run promise callbacks\\n\\tfor (var i = 0; i \\u003C asyncQueue.length; i++) {\\n\\t\\tasyncQueue[i][0](asyncQueue[i][1]);\\n\\t}\\n\\n\\t\\u002F\\u002F reset async asyncQueue\\n\\tasyncQueue = [];\\n\\tasyncTimer = false;\\n}\\n\\nfunction asyncCall(callback, arg) {\\n\\tasyncQueue.push([callback, arg]);\\n\\n\\tif (!asyncTimer) {\\n\\t\\tasyncTimer = true;\\n\\t\\tasyncSetTimer(asyncFlush, 0);\\n\\t}\\n}\\n\\nfunction invokeResolver(resolver, promise) {\\n\\tfunction resolvePromise(value) {\\n\\t\\tresolve(promise, value);\\n\\t}\\n\\n\\tfunction rejectPromise(reason) {\\n\\t\\treject(promise, reason);\\n\\t}\\n\\n\\ttry {\\n\\t\\tresolver(resolvePromise, rejectPromise);\\n\\t} catch (e) {\\n\\t\\trejectPromise(e);\\n\\t}\\n}\\n\\nfunction invokeCallback(subscriber) {\\n\\tvar owner = subscriber.owner;\\n\\tvar settled = owner._state;\\n\\tvar value = owner._data;\\n\\tvar callback = subscriber[settled];\\n\\tvar promise = subscriber.then;\\n\\n\\tif (typeof callback === 'function') {\\n\\t\\tsettled = FULFILLED;\\n\\t\\ttry {\\n\\t\\t\\tvalue = callback(value);\\n\\t\\t} catch (e) {\\n\\t\\t\\treject(promise, e);\\n\\t\\t}\\n\\t}\\n\\n\\tif (!handleThenable(promise, value)) {\\n\\t\\tif (settled === FULFILLED) {\\n\\t\\t\\tresolve(promise, value);\\n\\t\\t}\\n\\n\\t\\tif (settled === REJECTED) {\\n\\t\\t\\treject(promise, value);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction handleThenable(promise, value) {\\n\\tvar resolved;\\n\\n\\ttry {\\n\\t\\tif (promise === value) {\\n\\t\\t\\tthrow new TypeError('A promises callback cannot return that same promise.');\\n\\t\\t}\\n\\n\\t\\tif (value && (typeof value === 'function' || typeof value === 'object')) {\\n\\t\\t\\t\\u002F\\u002F then should be retrieved only once\\n\\t\\t\\tvar then = value.then;\\n\\n\\t\\t\\tif (typeof then === 'function') {\\n\\t\\t\\t\\tthen.call(value, function (val) {\\n\\t\\t\\t\\t\\tif (!resolved) {\\n\\t\\t\\t\\t\\t\\tresolved = true;\\n\\n\\t\\t\\t\\t\\t\\tif (value === val) {\\n\\t\\t\\t\\t\\t\\t\\tfulfill(promise, val);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresolve(promise, val);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, function (reason) {\\n\\t\\t\\t\\t\\tif (!resolved) {\\n\\t\\t\\t\\t\\t\\tresolved = true;\\n\\n\\t\\t\\t\\t\\t\\treject(promise, reason);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} catch (e) {\\n\\t\\tif (!resolved) {\\n\\t\\t\\treject(promise, e);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nfunction resolve(promise, value) {\\n\\tif (promise === value || !handleThenable(promise, value)) {\\n\\t\\tfulfill(promise, value);\\n\\t}\\n}\\n\\nfunction fulfill(promise, value) {\\n\\tif (promise._state === PENDING) {\\n\\t\\tpromise._state = SETTLED;\\n\\t\\tpromise._data = value;\\n\\n\\t\\tasyncCall(publishFulfillment, promise);\\n\\t}\\n}\\n\\nfunction reject(promise, reason) {\\n\\tif (promise._state === PENDING) {\\n\\t\\tpromise._state = SETTLED;\\n\\t\\tpromise._data = reason;\\n\\n\\t\\tasyncCall(publishRejection, promise);\\n\\t}\\n}\\n\\nfunction publish(promise) {\\n\\tpromise._then = promise._then.forEach(invokeCallback);\\n}\\n\\nfunction publishFulfillment(promise) {\\n\\tpromise._state = FULFILLED;\\n\\tpublish(promise);\\n}\\n\\nfunction publishRejection(promise) {\\n\\tpromise._state = REJECTED;\\n\\tpublish(promise);\\n\\tif (!promise._handled && isNode) {\\n\\t\\tglobal.process.emit('unhandledRejection', promise._data, promise);\\n\\t}\\n}\\n\\nfunction notifyRejectionHandled(promise) {\\n\\tglobal.process.emit('rejectionHandled', promise);\\n}\\n\\n\\u002F**\\n * @class\\n *\\u002F\\nfunction Promise(resolver) {\\n\\tif (typeof resolver !== 'function') {\\n\\t\\tthrow new TypeError('Promise resolver ' + resolver + ' is not a function');\\n\\t}\\n\\n\\tif (this instanceof Promise === false) {\\n\\t\\tthrow new TypeError('Failed to construct \\\\'Promise\\\\': Please use the \\\\'new\\\\' operator, this object constructor cannot be called as a function.');\\n\\t}\\n\\n\\tthis._then = [];\\n\\n\\tinvokeResolver(resolver, this);\\n}\\n\\nPromise.prototype = {\\n\\tconstructor: Promise,\\n\\n\\t_state: PENDING,\\n\\t_then: null,\\n\\t_data: undefined,\\n\\t_handled: false,\\n\\n\\tthen: function (onFulfillment, onRejection) {\\n\\t\\tvar subscriber = {\\n\\t\\t\\towner: this,\\n\\t\\t\\tthen: new this.constructor(NOOP),\\n\\t\\t\\tfulfilled: onFulfillment,\\n\\t\\t\\trejected: onRejection\\n\\t\\t};\\n\\n\\t\\tif ((onRejection || onFulfillment) && !this._handled) {\\n\\t\\t\\tthis._handled = true;\\n\\t\\t\\tif (this._state === REJECTED && isNode) {\\n\\t\\t\\t\\tasyncCall(notifyRejectionHandled, this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (this._state === FULFILLED || this._state === REJECTED) {\\n\\t\\t\\t\\u002F\\u002F already resolved, call callback async\\n\\t\\t\\tasyncCall(invokeCallback, subscriber);\\n\\t\\t} else {\\n\\t\\t\\t\\u002F\\u002F subscribe\\n\\t\\t\\tthis._then.push(subscriber);\\n\\t\\t}\\n\\n\\t\\treturn subscriber.then;\\n\\t},\\n\\n\\tcatch: function (onRejection) {\\n\\t\\treturn this.then(null, onRejection);\\n\\t}\\n};\\n\\nPromise.all = function (promises) {\\n\\tif (!Array.isArray(promises)) {\\n\\t\\tthrow new TypeError('You must pass an array to Promise.all().');\\n\\t}\\n\\n\\treturn new Promise(function (resolve, reject) {\\n\\t\\tvar results = [];\\n\\t\\tvar remaining = 0;\\n\\n\\t\\tfunction resolver(index) {\\n\\t\\t\\tremaining++;\\n\\t\\t\\treturn function (value) {\\n\\t\\t\\t\\tresults[index] = value;\\n\\t\\t\\t\\tif (!--remaining) {\\n\\t\\t\\t\\t\\tresolve(results);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tfor (var i = 0, promise; i \\u003C promises.length; i++) {\\n\\t\\t\\tpromise = promises[i];\\n\\n\\t\\t\\tif (promise && typeof promise.then === 'function') {\\n\\t\\t\\t\\tpromise.then(resolver(i), reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresults[i] = promise;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!remaining) {\\n\\t\\t\\tresolve(results);\\n\\t\\t}\\n\\t});\\n};\\n\\nPromise.race = function (promises) {\\n\\tif (!Array.isArray(promises)) {\\n\\t\\tthrow new TypeError('You must pass an array to Promise.race().');\\n\\t}\\n\\n\\treturn new Promise(function (resolve, reject) {\\n\\t\\tfor (var i = 0, promise; i \\u003C promises.length; i++) {\\n\\t\\t\\tpromise = promises[i];\\n\\n\\t\\t\\tif (promise && typeof promise.then === 'function') {\\n\\t\\t\\t\\tpromise.then(resolve, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresolve(promise);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\nPromise.resolve = function (value) {\\n\\tif (value && typeof value === 'object' && value.constructor === Promise) {\\n\\t\\treturn value;\\n\\t}\\n\\n\\treturn new Promise(function (resolve) {\\n\\t\\tresolve(value);\\n\\t});\\n};\\n\\nPromise.reject = function (reason) {\\n\\treturn new Promise(function (resolve, reject) {\\n\\t\\treject(reason);\\n\\t});\\n};\\n\\nmodule.exports = Promise;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 41 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nvar PassThrough = __webpack_require__(2).PassThrough;\\nvar objectAssign = __webpack_require__(8);\\n\\nmodule.exports = function (opts) {\\n\\topts = objectAssign({}, opts);\\n\\n\\tvar array = opts.array;\\n\\tvar encoding = opts.encoding;\\n\\n\\tvar buffer = encoding === 'buffer';\\n\\tvar objectMode = false;\\n\\n\\tif (array) {\\n\\t\\tobjectMode = !(encoding || buffer);\\n\\t} else {\\n\\t\\tencoding = encoding || 'utf8';\\n\\t}\\n\\n\\tif (buffer) {\\n\\t\\tencoding = null;\\n\\t}\\n\\n\\tvar len = 0;\\n\\tvar ret = [];\\n\\n\\tvar stream = new PassThrough({objectMode: objectMode});\\n\\n\\tif (encoding) {\\n\\t\\tstream.setEncoding(encoding);\\n\\t}\\n\\n\\tstream.on('data', function (chunk) {\\n\\t\\tret.push(chunk);\\n\\n\\t\\tif (objectMode) {\\n\\t\\t\\tlen = ret.length;\\n\\t\\t} else {\\n\\t\\t\\tlen += chunk.length;\\n\\t\\t}\\n\\t});\\n\\n\\tstream.getBufferedValue = function () {\\n\\t\\tif (array) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t\\treturn buffer ? Buffer.concat(ret, len) : ret.join('');\\n\\t};\\n\\n\\tstream.getBufferedLength = function () {\\n\\t\\treturn len;\\n\\t};\\n\\n\\treturn stream;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 42 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nmodule.exports = function (req, time) {\\n\\tif (req.timeoutTimer) {\\n\\t\\treturn req;\\n\\t}\\n\\n\\tvar delays = isNaN(time) ? time : {socket: time, connect: time};\\n\\tvar host = req._headers ? (' to ' + req._headers.host) : '';\\n\\n\\tif (delays.connect !== undefined) {\\n\\t\\treq.timeoutTimer = setTimeout(function timeoutHandler() {\\n\\t\\t\\treq.abort();\\n\\t\\t\\tvar e = new Error('Connection timed out on request' + host);\\n\\t\\t\\te.code = 'ETIMEDOUT';\\n\\t\\t\\treq.emit('error', e);\\n\\t\\t}, delays.connect);\\n\\t}\\n\\n\\t\\u002F\\u002F Clear the connection timeout timer once a socket is assigned to the\\n\\t\\u002F\\u002F request and is connected.\\n\\treq.on('socket', function assign(socket) {\\n\\t\\t\\u002F\\u002F Socket may come from Agent pool and may be already connected.\\n\\t\\tif (!(socket.connecting || socket._connecting)) {\\n\\t\\t\\tconnect();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tsocket.once('connect', connect);\\n\\t});\\n\\n\\tfunction clear() {\\n\\t\\tif (req.timeoutTimer) {\\n\\t\\t\\tclearTimeout(req.timeoutTimer);\\n\\t\\t\\treq.timeoutTimer = null;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction connect() {\\n\\t\\tclear();\\n\\n\\t\\tif (delays.socket !== undefined) {\\n\\t\\t\\t\\u002F\\u002F Abort the request if there is no activity on the socket for more\\n\\t\\t\\t\\u002F\\u002F than `delays.socket` milliseconds.\\n\\t\\t\\treq.setTimeout(delays.socket, function socketTimeoutHandler() {\\n\\t\\t\\t\\treq.abort();\\n\\t\\t\\t\\tvar e = new Error('Socket timed out on request' + host);\\n\\t\\t\\t\\te.code = 'ESOCKETTIMEDOUT';\\n\\t\\t\\t\\treq.emit('error', e);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t}\\n\\n\\treturn req.on('error', clear);\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 43 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nvar url = __webpack_require__(7);\\nvar prependHttp = __webpack_require__(44);\\n\\nmodule.exports = function (x) {\\n\\tvar withProtocol = prependHttp(x);\\n\\tvar parsed = url.parse(withProtocol);\\n\\n\\tif (withProtocol !== x) {\\n\\t\\tparsed.protocol = null;\\n\\t}\\n\\n\\treturn parsed;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 44 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nmodule.exports = function (url) {\\n\\tif (typeof url !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string, got ' + typeof url);\\n\\t}\\n\\n\\turl = url.trim();\\n\\n\\tif (\\u002F^\\\\.*\\\\\\u002F|^(?!localhost)\\\\w+:\\u002F.test(url)) {\\n\\t\\treturn url;\\n\\t}\\n\\n\\treturn url.replace(\\u002F^(?!(?:\\\\w+:)?\\\\\\u002F\\\\\\u002F)\\u002F, 'http:\\u002F\\u002F');\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 45 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nmodule.exports = function (obj) {\\n\\tvar ret = {};\\n\\tvar keys = Object.keys(Object(obj));\\n\\n\\tfor (var i = 0; i \\u003C keys.length; i++) {\\n\\t\\tret[keys[i].toLowerCase()] = obj[keys[i]];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 46 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nmodule.exports = function (x) {\\n\\tif (typeof x !== 'number') {\\n\\t\\tthrow new TypeError('Expected a number');\\n\\t}\\n\\n\\treturn x === 300 ||\\n\\t\\tx === 301 ||\\n\\t\\tx === 302 ||\\n\\t\\tx === 303 ||\\n\\t\\tx === 305 ||\\n\\t\\tx === 307 ||\\n\\t\\tx === 308;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 47 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nconst PassThrough = __webpack_require__(2).PassThrough;\\nconst zlib = __webpack_require__(48);\\n\\nmodule.exports = res =\\u003E {\\n\\t\\u002F\\u002F TODO: use Array#includes when targeting Node.js 6\\n\\tif (['gzip', 'deflate'].indexOf(res.headers['content-encoding']) === -1) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tconst unzip = zlib.createUnzip();\\n\\tconst stream = new PassThrough();\\n\\n\\tstream.httpVersion = res.httpVersion;\\n\\tstream.headers = res.headers;\\n\\tstream.rawHeaders = res.rawHeaders;\\n\\tstream.trailers = res.trailers;\\n\\tstream.rawTrailers = res.rawTrailers;\\n\\tstream.setTimeout = res.setTimeout.bind(res);\\n\\tstream.statusCode = res.statusCode;\\n\\tstream.statusMessage = res.statusMessage;\\n\\tstream.socket = res.socket;\\n\\n\\tunzip.on('error', err =\\u003E {\\n\\t\\tif (err.code === 'Z_BUF_ERROR') {\\n\\t\\t\\tstream.end();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tstream.emit('error', err);\\n\\t});\\n\\n\\tres.pipe(unzip).pipe(stream);\\n\\n\\treturn stream;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 48 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"zlib\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 49 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\nvar captureStackTrace = __webpack_require__(50);\\n\\nfunction inherits(ctor, superCtor) {\\n\\tctor.super_ = superCtor;\\n\\tctor.prototype = Object.create(superCtor.prototype, {\\n\\t\\tconstructor: {\\n\\t\\t\\tvalue: ctor,\\n\\t\\t\\tenumerable: false,\\n\\t\\t\\twritable: true,\\n\\t\\t\\tconfigurable: true\\n\\t\\t}\\n\\t});\\n}\\n\\nmodule.exports = function createErrorClass(className, setup) {\\n\\tif (typeof className !== 'string') {\\n\\t\\tthrow new TypeError('Expected className to be a string');\\n\\t}\\n\\n\\tif (\\u002F[^0-9a-zA-Z_$]\\u002F.test(className)) {\\n\\t\\tthrow new Error('className contains invalid characters');\\n\\t}\\n\\n\\tsetup = setup || function (message) {\\n\\t\\tthis.message = message;\\n\\t};\\n\\n\\tvar ErrorClass = function () {\\n\\t\\tObject.defineProperty(this, 'name', {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tvalue: className,\\n\\t\\t\\twritable: true\\n\\t\\t});\\n\\n\\t\\tcaptureStackTrace(this, this.constructor);\\n\\n\\t\\tsetup.apply(this, arguments);\\n\\t};\\n\\n\\tinherits(ErrorClass, Error);\\n\\n\\treturn ErrorClass;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 50 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nmodule.exports = Error.captureStackTrace || function (error) {\\n\\tvar container = new Error();\\n\\n\\tObject.defineProperty(error, 'stack', {\\n\\t\\tconfigurable: true,\\n\\t\\tget: function getStack() {\\n\\t\\t\\tvar stack = container.stack;\\n\\n\\t\\t\\tObject.defineProperty(this, 'stack', {\\n\\t\\t\\t\\tvalue: stack\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn stack;\\n\\t\\t}\\n\\t});\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 51 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar WHITELIST = [\\n\\t'ETIMEDOUT',\\n\\t'ECONNRESET',\\n\\t'EADDRINUSE',\\n\\t'ESOCKETTIMEDOUT',\\n\\t'ECONNREFUSED',\\n\\t'EPIPE'\\n];\\n\\nvar BLACKLIST = [\\n\\t'ENOTFOUND',\\n\\t'ENETUNREACH',\\n\\n\\t\\u002F\\u002F SSL errors from https:\\u002F\\u002Fgithub.com\\u002Fnodejs\\u002Fnode\\u002Fblob\\u002Fed3d8b13ee9a705d89f9e0397d9e96519e7e47ac\\u002Fsrc\\u002Fnode_crypto.cc#L1950\\n\\t'UNABLE_TO_GET_ISSUER_CERT',\\n\\t'UNABLE_TO_GET_CRL',\\n\\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\\n\\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\\n\\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\\n\\t'CERT_SIGNATURE_FAILURE',\\n\\t'CRL_SIGNATURE_FAILURE',\\n\\t'CERT_NOT_YET_VALID',\\n\\t'CERT_HAS_EXPIRED',\\n\\t'CRL_NOT_YET_VALID',\\n\\t'CRL_HAS_EXPIRED',\\n\\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\\n\\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\\n\\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\\n\\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\\n\\t'OUT_OF_MEM',\\n\\t'DEPTH_ZERO_SELF_SIGNED_CERT',\\n\\t'SELF_SIGNED_CERT_IN_CHAIN',\\n\\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\\n\\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\\n\\t'CERT_CHAIN_TOO_LONG',\\n\\t'CERT_REVOKED',\\n\\t'INVALID_CA',\\n\\t'PATH_LENGTH_EXCEEDED',\\n\\t'INVALID_PURPOSE',\\n\\t'CERT_UNTRUSTED',\\n\\t'CERT_REJECTED'\\n];\\n\\nmodule.exports = function (err) {\\n\\tif (!err || !err.code) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (WHITELIST.indexOf(err.code) !== -1) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (BLACKLIST.indexOf(err.code) !== -1) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 52 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F* eslint-disable node\\u002Fno-deprecated-api *\\u002F\\nvar buffer = __webpack_require__(53)\\nvar Buffer = buffer.Buffer\\n\\n\\u002F\\u002F alternative to using Object.keys for old browsers\\nfunction copyProps (src, dst) {\\n  for (var key in src) {\\n    dst[key] = src[key]\\n  }\\n}\\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\\n  module.exports = buffer\\n} else {\\n  \\u002F\\u002F Copy properties from require('buffer')\\n  copyProps(buffer, exports)\\n  exports.Buffer = SafeBuffer\\n}\\n\\nfunction SafeBuffer (arg, encodingOrOffset, length) {\\n  return Buffer(arg, encodingOrOffset, length)\\n}\\n\\n\\u002F\\u002F Copy static methods from Buffer\\ncopyProps(Buffer, SafeBuffer)\\n\\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\\n  if (typeof arg === 'number') {\\n    throw new TypeError('Argument must not be a number')\\n  }\\n  return Buffer(arg, encodingOrOffset, length)\\n}\\n\\nSafeBuffer.alloc = function (size, fill, encoding) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('Argument must be a number')\\n  }\\n  var buf = Buffer(size)\\n  if (fill !== undefined) {\\n    if (typeof encoding === 'string') {\\n      buf.fill(fill, encoding)\\n    } else {\\n      buf.fill(fill)\\n    }\\n  } else {\\n    buf.fill(0)\\n  }\\n  return buf\\n}\\n\\nSafeBuffer.allocUnsafe = function (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('Argument must be a number')\\n  }\\n  return Buffer(size)\\n}\\n\\nSafeBuffer.allocUnsafeSlow = function (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('Argument must be a number')\\n  }\\n  return buffer.SlowBuffer(size)\\n}\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 53 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"buffer\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 54 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = {\\\"_args\\\":[[\\\"got@6.7.1\\\",\\\"\\u002FUsers\\u002Fsunxin\\u002Fnew\\u002FClient\\\"]],\\\"_from\\\":\\\"got@6.7.1\\\",\\\"_id\\\":\\\"got@6.7.1\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha1-JAzQV4WpoY5WHcG0S0HHY+8ejbA=\\\",\\\"_location\\\":\\\"\\u002Fgot\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"got@6.7.1\\\",\\\"name\\\":\\\"got\\\",\\\"escapedName\\\":\\\"got\\\",\\\"rawSpec\\\":\\\"6.7.1\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"6.7.1\\\"},\\\"_requiredBy\\\":[\\\"\\u002Fvue-resource\\\"],\\\"_resolved\\\":\\\"https:\\u002F\\u002Fregistry.npmjs.org\\u002Fgot\\u002F-\\u002Fgot-6.7.1.tgz\\\",\\\"_spec\\\":\\\"6.7.1\\\",\\\"_where\\\":\\\"\\u002FUsers\\u002Fsunxin\\u002Fnew\\u002FClient\\\",\\\"ava\\\":{\\\"concurrency\\\":4},\\\"browser\\\":{\\\"unzip-response\\\":false},\\\"bugs\\\":{\\\"url\\\":\\\"https:\\u002F\\u002Fgithub.com\\u002Fsindresorhus\\u002Fgot\\u002Fissues\\\"},\\\"dependencies\\\":{\\\"create-error-class\\\":\\\"^3.0.0\\\",\\\"duplexer3\\\":\\\"^0.1.4\\\",\\\"get-stream\\\":\\\"^3.0.0\\\",\\\"is-redirect\\\":\\\"^1.0.0\\\",\\\"is-retry-allowed\\\":\\\"^1.0.0\\\",\\\"is-stream\\\":\\\"^1.0.0\\\",\\\"lowercase-keys\\\":\\\"^1.0.0\\\",\\\"safe-buffer\\\":\\\"^5.0.1\\\",\\\"timed-out\\\":\\\"^4.0.0\\\",\\\"unzip-response\\\":\\\"^2.0.1\\\",\\\"url-parse-lax\\\":\\\"^1.0.0\\\"},\\\"description\\\":\\\"Simplified HTTP requests\\\",\\\"devDependencies\\\":{\\\"ava\\\":\\\"^0.17.0\\\",\\\"coveralls\\\":\\\"^2.11.4\\\",\\\"form-data\\\":\\\"^2.1.1\\\",\\\"get-port\\\":\\\"^2.0.0\\\",\\\"into-stream\\\":\\\"^3.0.0\\\",\\\"nyc\\\":\\\"^10.0.0\\\",\\\"pem\\\":\\\"^1.4.4\\\",\\\"pify\\\":\\\"^2.3.0\\\",\\\"tempfile\\\":\\\"^1.1.1\\\",\\\"xo\\\":\\\"*\\\"},\\\"engines\\\":{\\\"node\\\":\\\"\\u003E=4\\\"},\\\"files\\\":[\\\"index.js\\\"],\\\"homepage\\\":\\\"https:\\u002F\\u002Fgithub.com\\u002Fsindresorhus\\u002Fgot#readme\\\",\\\"keywords\\\":[\\\"http\\\",\\\"https\\\",\\\"get\\\",\\\"got\\\",\\\"url\\\",\\\"uri\\\",\\\"request\\\",\\\"util\\\",\\\"utility\\\",\\\"simple\\\",\\\"curl\\\",\\\"wget\\\",\\\"fetch\\\"],\\\"license\\\":\\\"MIT\\\",\\\"maintainers\\\":[{\\\"name\\\":\\\"Sindre Sorhus\\\",\\\"email\\\":\\\"sindresorhus@gmail.com\\\",\\\"url\\\":\\\"sindresorhus.com\\\"},{\\\"name\\\":\\\"Vsevolod Strukchinsky\\\",\\\"email\\\":\\\"floatdrop@gmail.com\\\",\\\"url\\\":\\\"github.com\\u002Ffloatdrop\\\"}],\\\"name\\\":\\\"got\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https:\\u002F\\u002Fgithub.com\\u002Fsindresorhus\\u002Fgot.git\\\"},\\\"scripts\\\":{\\\"coveralls\\\":\\\"nyc report --reporter=text-lcov | coveralls\\\",\\\"test\\\":\\\"xo && nyc ava\\\"},\\\"version\\\":\\\"6.7.1\\\",\\\"xo\\\":{\\\"esnext\\\":true}}\\n\\n\\u002F***\\u002F }),\\n\\u002F* 55 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nconst dexie=__webpack_require__(56).default;\\nconst uuid=__webpack_require__(57);\\nfunction db() {\\n    let db=new dexie(\\\"doclever\\\");\\n    db.version(1).stores({\\n        env:\\\"id,name,url\\\",\\n        member:\\\"user,pass\\\"\\n    })\\n    this.addEnv=async function (id,name,url) {\\n        let arr=await this.getAllEnv();\\n        let obj={\\n            name:name,\\n            url:url\\n        };\\n        if(id)\\n        {\\n            obj.id=id;\\n        }\\n        else\\n        {\\n            obj.id=uuid();\\n        }\\n        await db.env.put(obj)\\n        return obj;\\n    }\\n    this.delEnv=function (id) {\\n        return db.env.delete(id)\\n    }\\n    this.getAllEnv=function () {\\n        return db.env.toArray();\\n    }\\n    this.getEnv=function (id) {\\n        return db.env.get(id)\\n    }\\n    this.editMember=async function (user,pass) {\\n        let arr=await db.member.toArray();\\n        let obj;\\n        for(let o of arr)\\n        {\\n            if(o.user==user)\\n            {\\n                obj=o;\\n                break;\\n            }\\n        }\\n        if(obj)\\n        {\\n            obj.pass=pass;\\n            await db.member.put(obj);\\n        }\\n        else\\n        {\\n            obj={\\n                user:user,\\n                pass:pass,\\n            }\\n            await db.member.put(obj);\\n        }\\n    }\\n    this.getAllMember=function () {\\n        return db.member.toArray();\\n    }\\n    this.removeMember=function (user) {\\n        return db.env.delete(user)\\n    }\\n}\\nmodule.exports=new db();\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 56 *\\u002F\\n\\u002F***\\u002F (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n\\u002F*\\n * Dexie.js - a minimalistic wrapper for IndexedDB\\n * ===============================================\\n *\\n * By David Fahlander, david.fahlander@gmail.com\\n *\\n * Version {version}, {date}\\n *\\n * http:\\u002F\\u002Fdexie.org\\n *\\n * Apache License Version 2.0, January 2004, http:\\u002F\\u002Fwww.apache.org\\u002Flicenses\\u002F\\n *\\u002F\\n \\nvar keys = Object.keys;\\nvar isArray = Array.isArray;\\nvar _global = typeof self !== 'undefined' ? self :\\n    typeof window !== 'undefined' ? window :\\n        global;\\nfunction extend(obj, extension) {\\n    if (typeof extension !== 'object')\\n        return obj;\\n    keys(extension).forEach(function (key) {\\n        obj[key] = extension[key];\\n    });\\n    return obj;\\n}\\nvar getProto = Object.getPrototypeOf;\\nvar _hasOwn = {}.hasOwnProperty;\\nfunction hasOwn(obj, prop) {\\n    return _hasOwn.call(obj, prop);\\n}\\nfunction props(proto, extension) {\\n    if (typeof extension === 'function')\\n        extension = extension(getProto(proto));\\n    keys(extension).forEach(function (key) {\\n        setProp(proto, key, extension[key]);\\n    });\\n}\\nvar defineProperty = Object.defineProperty;\\nfunction setProp(obj, prop, functionOrGetSet, options) {\\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \\\"get\\\") && typeof functionOrGetSet.get === 'function' ?\\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\\n}\\nfunction derive(Child) {\\n    return {\\n        from: function (Parent) {\\n            Child.prototype = Object.create(Parent.prototype);\\n            setProp(Child.prototype, \\\"constructor\\\", Child);\\n            return {\\n                extend: props.bind(null, Child.prototype)\\n            };\\n        }\\n    };\\n}\\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\\nfunction getPropertyDescriptor(obj, prop) {\\n    var pd = getOwnPropertyDescriptor(obj, prop), proto;\\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\\n}\\nvar _slice = [].slice;\\nfunction slice(args, start, end) {\\n    return _slice.call(args, start, end);\\n}\\nfunction override(origFunc, overridedFactory) {\\n    return overridedFactory(origFunc);\\n}\\nfunction assert(b) {\\n    if (!b)\\n        throw new Error(\\\"Assertion Failed\\\");\\n}\\nfunction asap(fn) {\\n    if (_global.setImmediate)\\n        setImmediate(fn);\\n    else\\n        setTimeout(fn, 0);\\n}\\n\\n\\u002F** Generate an object (hash map) based on given array.\\n * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to\\n *        instert on the resulting object for each item in the array. If this function returns a falsy value, the\\n *        current item wont affect the resulting object.\\n *\\u002F\\nfunction arrayToObject(array, extractor) {\\n    return array.reduce(function (result, item, i) {\\n        var nameAndValue = extractor(item, i);\\n        if (nameAndValue)\\n            result[nameAndValue[0]] = nameAndValue[1];\\n        return result;\\n    }, {});\\n}\\nfunction trycatcher(fn, reject) {\\n    return function () {\\n        try {\\n            fn.apply(this, arguments);\\n        }\\n        catch (e) {\\n            reject(e);\\n        }\\n    };\\n}\\nfunction tryCatch(fn, onerror, args) {\\n    try {\\n        fn.apply(null, args);\\n    }\\n    catch (ex) {\\n        onerror && onerror(ex);\\n    }\\n}\\nfunction getByKeyPath(obj, keyPath) {\\n    \\u002F\\u002F http:\\u002F\\u002Fwww.w3.org\\u002FTR\\u002FIndexedDB\\u002F#steps-for-extracting-a-key-from-a-value-using-a-key-path\\n    if (hasOwn(obj, keyPath))\\n        return obj[keyPath]; \\u002F\\u002F This line is moved from last to first for optimization purpose.\\n    if (!keyPath)\\n        return obj;\\n    if (typeof keyPath !== 'string') {\\n        var rv = [];\\n        for (var i = 0, l = keyPath.length; i \\u003C l; ++i) {\\n            var val = getByKeyPath(obj, keyPath[i]);\\n            rv.push(val);\\n        }\\n        return rv;\\n    }\\n    var period = keyPath.indexOf('.');\\n    if (period !== -1) {\\n        var innerObj = obj[keyPath.substr(0, period)];\\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\\n    }\\n    return undefined;\\n}\\nfunction setByKeyPath(obj, keyPath, value) {\\n    if (!obj || keyPath === undefined)\\n        return;\\n    if ('isFrozen' in Object && Object.isFrozen(obj))\\n        return;\\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\\n        assert(typeof value !== 'string' && 'length' in value);\\n        for (var i = 0, l = keyPath.length; i \\u003C l; ++i) {\\n            setByKeyPath(obj, keyPath[i], value[i]);\\n        }\\n    }\\n    else {\\n        var period = keyPath.indexOf('.');\\n        if (period !== -1) {\\n            var currentKeyPath = keyPath.substr(0, period);\\n            var remainingKeyPath = keyPath.substr(period + 1);\\n            if (remainingKeyPath === \\\"\\\")\\n                if (value === undefined)\\n                    delete obj[currentKeyPath];\\n                else\\n                    obj[currentKeyPath] = value;\\n            else {\\n                var innerObj = obj[currentKeyPath];\\n                if (!innerObj)\\n                    innerObj = (obj[currentKeyPath] = {});\\n                setByKeyPath(innerObj, remainingKeyPath, value);\\n            }\\n        }\\n        else {\\n            if (value === undefined)\\n                delete obj[keyPath];\\n            else\\n                obj[keyPath] = value;\\n        }\\n    }\\n}\\nfunction delByKeyPath(obj, keyPath) {\\n    if (typeof keyPath === 'string')\\n        setByKeyPath(obj, keyPath, undefined);\\n    else if ('length' in keyPath)\\n        [].map.call(keyPath, function (kp) {\\n            setByKeyPath(obj, kp, undefined);\\n        });\\n}\\nfunction shallowClone(obj) {\\n    var rv = {};\\n    for (var m in obj) {\\n        if (hasOwn(obj, m))\\n            rv[m] = obj[m];\\n    }\\n    return rv;\\n}\\nvar concat = [].concat;\\nfunction flatten(a) {\\n    return concat.apply([], a);\\n}\\n\\u002F\\u002Fhttps:\\u002F\\u002Fdeveloper.mozilla.org\\u002Fen-US\\u002Fdocs\\u002FWeb\\u002FAPI\\u002FWeb_Workers_API\\u002FStructured_clone_algorithm\\nvar intrinsicTypes = \\\"Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set\\\"\\n    .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\\\"Int\\\", \\\"Uint\\\", \\\"Float\\\"].map(function (t) { return t + num + \\\"Array\\\"; }); }))).filter(function (t) { return _global[t]; }).map(function (t) { return _global[t]; });\\nfunction deepClone(any) {\\n    if (!any || typeof any !== 'object')\\n        return any;\\n    var rv;\\n    if (isArray(any)) {\\n        rv = [];\\n        for (var i = 0, l = any.length; i \\u003C l; ++i) {\\n            rv.push(deepClone(any[i]));\\n        }\\n    }\\n    else if (intrinsicTypes.indexOf(any.constructor) \\u003E= 0) {\\n        rv = any;\\n    }\\n    else {\\n        rv = any.constructor ? Object.create(any.constructor.prototype) : {};\\n        for (var prop in any) {\\n            if (hasOwn(any, prop)) {\\n                rv[prop] = deepClone(any[prop]);\\n            }\\n        }\\n    }\\n    return rv;\\n}\\nfunction getObjectDiff(a, b, rv, prfx) {\\n    \\u002F\\u002F Compares objects a and b and produces a diff object.\\n    rv = rv || {};\\n    prfx = prfx || '';\\n    keys(a).forEach(function (prop) {\\n        if (!hasOwn(b, prop))\\n            rv[prfx + prop] = undefined; \\u002F\\u002F Property removed\\n        else {\\n            var ap = a[prop], bp = b[prop];\\n            if (typeof ap === 'object' && typeof bp === 'object' &&\\n                ap && bp &&\\n                \\u002F\\u002F Now compare constructors are same (not equal because wont work in Safari)\\n                ('' + ap.constructor) === ('' + bp.constructor))\\n                \\u002F\\u002F Same type of object but its properties may have changed\\n                getObjectDiff(ap, bp, rv, prfx + prop + \\\".\\\");\\n            else if (ap !== bp)\\n                rv[prfx + prop] = b[prop]; \\u002F\\u002F Primitive value changed\\n        }\\n    });\\n    keys(b).forEach(function (prop) {\\n        if (!hasOwn(a, prop)) {\\n            rv[prfx + prop] = b[prop]; \\u002F\\u002F Property added\\n        }\\n    });\\n    return rv;\\n}\\n\\u002F\\u002F If first argument is iterable or array-like, return it as an array\\nvar iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;\\nvar getIteratorOf = iteratorSymbol ? function (x) {\\n    var i;\\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\\n} : function () { return null; };\\nvar NO_CHAR_ARRAY = {};\\n\\u002F\\u002F Takes one or several arguments and returns an array based on the following criteras:\\n\\u002F\\u002F * If several arguments provided, return arguments converted to an array in a way that\\n\\u002F\\u002F   still allows javascript engine to optimize the code.\\n\\u002F\\u002F * If single argument is an array, return a clone of it.\\n\\u002F\\u002F * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special\\n\\u002F\\u002F   case to the two bullets below.\\n\\u002F\\u002F * If single argument is an iterable, convert it to an array and return the resulting array.\\n\\u002F\\u002F * If single argument is array-like (has length of type number), convert it to an array.\\nfunction getArrayOf(arrayLike) {\\n    var i, a, x, it;\\n    if (arguments.length === 1) {\\n        if (isArray(arrayLike))\\n            return arrayLike.slice();\\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\\n            return [arrayLike];\\n        if ((it = getIteratorOf(arrayLike))) {\\n            a = [];\\n            while ((x = it.next()), !x.done)\\n                a.push(x.value);\\n            return a;\\n        }\\n        if (arrayLike == null)\\n            return [arrayLike];\\n        i = arrayLike.length;\\n        if (typeof i === 'number') {\\n            a = new Array(i);\\n            while (i--)\\n                a[i] = arrayLike[i];\\n            return a;\\n        }\\n        return [arrayLike];\\n    }\\n    i = arguments.length;\\n    a = new Array(i);\\n    while (i--)\\n        a[i] = arguments[i];\\n    return a;\\n}\\n\\n\\u002F\\u002F By default, debug will be true only if platform is a web platform and its page is served from localhost.\\n\\u002F\\u002F When debug = true, error's stacks will contain asyncronic long stacks.\\nvar debug = typeof location !== 'undefined' &&\\n    \\u002F\\u002F By default, use debug mode if served from localhost.\\n    \\u002F^(http|https):\\\\\\u002F\\\\\\u002F(localhost|127\\\\.0\\\\.0\\\\.1)\\u002F.test(location.href);\\nfunction setDebug(value, filter) {\\n    debug = value;\\n    libraryFilter = filter;\\n}\\nvar libraryFilter = function () { return true; };\\nvar NEEDS_THROW_FOR_STACK = !new Error(\\\"\\\").stack;\\nfunction getErrorWithStack() {\\n    \\\"use strict\\\";\\n    if (NEEDS_THROW_FOR_STACK)\\n        try {\\n            \\u002F\\u002F Doing something naughty in strict mode here to trigger a specific error\\n            \\u002F\\u002F that can be explicitely ignored in debugger's exception settings.\\n            \\u002F\\u002F If we'd just throw new Error() here, IE's debugger's exception settings\\n            \\u002F\\u002F will just consider it as \\\"exception thrown by javascript code\\\" which is\\n            \\u002F\\u002F something you wouldn't want it to ignore.\\n            getErrorWithStack.arguments;\\n            throw new Error(); \\u002F\\u002F Fallback if above line don't throw.\\n        }\\n        catch (e) {\\n            return e;\\n        }\\n    return new Error();\\n}\\nfunction prettyStack(exception, numIgnoredFrames) {\\n    var stack = exception.stack;\\n    if (!stack)\\n        return \\\"\\\";\\n    numIgnoredFrames = (numIgnoredFrames || 0);\\n    if (stack.indexOf(exception.name) === 0)\\n        numIgnoredFrames += (exception.name + exception.message).split('\\\\n').length;\\n    return stack.split('\\\\n')\\n        .slice(numIgnoredFrames)\\n        .filter(libraryFilter)\\n        .map(function (frame) { return \\\"\\\\n\\\" + frame; })\\n        .join('');\\n}\\nfunction deprecated(what, fn) {\\n    return function () {\\n        console.warn(what + \\\" is deprecated. See https:\\u002F\\u002Fgithub.com\\u002Fdfahlander\\u002FDexie.js\\u002Fwiki\\u002FDeprecations. \\\" + prettyStack(getErrorWithStack(), 1));\\n        return fn.apply(this, arguments);\\n    };\\n}\\n\\nvar dexieErrorNames = [\\n    'Modify',\\n    'Bulk',\\n    'OpenFailed',\\n    'VersionChange',\\n    'Schema',\\n    'Upgrade',\\n    'InvalidTable',\\n    'MissingAPI',\\n    'NoSuchDatabase',\\n    'InvalidArgument',\\n    'SubTransaction',\\n    'Unsupported',\\n    'Internal',\\n    'DatabaseClosed',\\n    'PrematureCommit',\\n    'ForeignAwait'\\n];\\nvar idbDomErrorNames = [\\n    'Unknown',\\n    'Constraint',\\n    'Data',\\n    'TransactionInactive',\\n    'ReadOnly',\\n    'Version',\\n    'NotFound',\\n    'InvalidState',\\n    'InvalidAccess',\\n    'Abort',\\n    'Timeout',\\n    'QuotaExceeded',\\n    'Syntax',\\n    'DataClone'\\n];\\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\\nvar defaultTexts = {\\n    VersionChanged: \\\"Database version changed by other database connection\\\",\\n    DatabaseClosed: \\\"Database has been closed\\\",\\n    Abort: \\\"Transaction aborted\\\",\\n    TransactionInactive: \\\"Transaction has already completed or failed\\\"\\n};\\n\\u002F\\u002F\\n\\u002F\\u002F DexieError - base class of all out exceptions.\\n\\u002F\\u002F\\nfunction DexieError(name, msg) {\\n    \\u002F\\u002F Reason we don't use ES6 classes is because:\\n    \\u002F\\u002F 1. It bloats transpiled code and increases size of minified code.\\n    \\u002F\\u002F 2. It doesn't give us much in this case.\\n    \\u002F\\u002F 3. It would require sub classes to call super(), which\\n    \\u002F\\u002F    is not needed when deriving from Error.\\n    this._e = getErrorWithStack();\\n    this.name = name;\\n    this.message = msg;\\n}\\nderive(DexieError).from(Error).extend({\\n    stack: {\\n        get: function () {\\n            return this._stack ||\\n                (this._stack = this.name + \\\": \\\" + this.message + prettyStack(this._e, 2));\\n        }\\n    },\\n    toString: function () { return this.name + \\\": \\\" + this.message; }\\n});\\nfunction getMultiErrorMessage(msg, failures) {\\n    return msg + \\\". Errors: \\\" + failures\\n        .map(function (f) { return f.toString(); })\\n        .filter(function (v, i, s) { return s.indexOf(v) === i; }) \\u002F\\u002F Only unique error strings\\n        .join('\\\\n');\\n}\\n\\u002F\\u002F\\n\\u002F\\u002F ModifyError - thrown in Collection.modify()\\n\\u002F\\u002F Specific constructor because it contains members failures and failedKeys.\\n\\u002F\\u002F\\nfunction ModifyError(msg, failures, successCount, failedKeys) {\\n    this._e = getErrorWithStack();\\n    this.failures = failures;\\n    this.failedKeys = failedKeys;\\n    this.successCount = successCount;\\n}\\nderive(ModifyError).from(DexieError);\\nfunction BulkError(msg, failures) {\\n    this._e = getErrorWithStack();\\n    this.name = \\\"BulkError\\\";\\n    this.failures = failures;\\n    this.message = getMultiErrorMessage(msg, failures);\\n}\\nderive(BulkError).from(DexieError);\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F Dynamically generate error names and exception classes based\\n\\u002F\\u002F on the names in errorList.\\n\\u002F\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F Map of {ErrorName -\\u003E ErrorName + \\\"Error\\\"}\\nvar errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \\\"Error\\\", obj); }, {});\\n\\u002F\\u002F Need an alias for DexieError because we're gonna create subclasses with the same name.\\nvar BaseException = DexieError;\\n\\u002F\\u002F Map of {ErrorName -\\u003E exception constructor}\\nvar exceptions = errorList.reduce(function (obj, name) {\\n    \\u002F\\u002F Let the name be \\\"DexieError\\\" because this name may\\n    \\u002F\\u002F be shown in call stack and when debugging. DexieError is\\n    \\u002F\\u002F the most true name because it derives from DexieError,\\n    \\u002F\\u002F and we cannot change Function.name programatically without\\n    \\u002F\\u002F dynamically create a Function object, which would be considered\\n    \\u002F\\u002F 'eval-evil'.\\n    var fullName = name + \\\"Error\\\";\\n    function DexieError(msgOrInner, inner) {\\n        this._e = getErrorWithStack();\\n        this.name = fullName;\\n        if (!msgOrInner) {\\n            this.message = defaultTexts[name] || fullName;\\n            this.inner = null;\\n        }\\n        else if (typeof msgOrInner === 'string') {\\n            this.message = msgOrInner;\\n            this.inner = inner || null;\\n        }\\n        else if (typeof msgOrInner === 'object') {\\n            this.message = msgOrInner.name + \\\" \\\" + msgOrInner.message;\\n            this.inner = msgOrInner;\\n        }\\n    }\\n    derive(DexieError).from(BaseException);\\n    obj[name] = DexieError;\\n    return obj;\\n}, {});\\n\\u002F\\u002F Use ECMASCRIPT standard exceptions where applicable:\\nexceptions.Syntax = SyntaxError;\\nexceptions.Type = TypeError;\\nexceptions.Range = RangeError;\\nvar exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\\n    obj[name + \\\"Error\\\"] = exceptions[name];\\n    return obj;\\n}, {});\\nfunction mapError(domError, message) {\\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\\n        return domError;\\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\\n    if (\\\"stack\\\" in domError) {\\n        \\u002F\\u002F Derive stack from inner exception if it has a stack\\n        setProp(rv, \\\"stack\\\", { get: function () {\\n                return this.inner.stack;\\n            } });\\n    }\\n    return rv;\\n}\\nvar fullNameExceptions = errorList.reduce(function (obj, name) {\\n    if ([\\\"Syntax\\\", \\\"Type\\\", \\\"Range\\\"].indexOf(name) === -1)\\n        obj[name + \\\"Error\\\"] = exceptions[name];\\n    return obj;\\n}, {});\\nfullNameExceptions.ModifyError = ModifyError;\\nfullNameExceptions.DexieError = DexieError;\\nfullNameExceptions.BulkError = BulkError;\\n\\nfunction nop() { }\\nfunction mirror(val) { return val; }\\nfunction pureFunctionChain(f1, f2) {\\n    \\u002F\\u002F Enables chained events that takes ONE argument and returns it to the next function in chain.\\n    \\u002F\\u002F This pattern is used in the hook(\\\"reading\\\") event.\\n    if (f1 == null || f1 === mirror)\\n        return f2;\\n    return function (val) {\\n        return f2(f1(val));\\n    };\\n}\\nfunction callBoth(on1, on2) {\\n    return function () {\\n        on1.apply(this, arguments);\\n        on2.apply(this, arguments);\\n    };\\n}\\nfunction hookCreatingChain(f1, f2) {\\n    \\u002F\\u002F Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.\\n    \\u002F\\u002F This pattern is used in the hook(\\\"creating\\\") event.\\n    if (f1 === nop)\\n        return f2;\\n    return function () {\\n        var res = f1.apply(this, arguments);\\n        if (res !== undefined)\\n            arguments[0] = res;\\n        var onsuccess = this.onsuccess, \\u002F\\u002F In case event listener has set this.onsuccess\\n        onerror = this.onerror; \\u002F\\u002F In case event listener has set this.onerror\\n        this.onsuccess = null;\\n        this.onerror = null;\\n        var res2 = f2.apply(this, arguments);\\n        if (onsuccess)\\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\\n        if (onerror)\\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\\n        return res2 !== undefined ? res2 : res;\\n    };\\n}\\nfunction hookDeletingChain(f1, f2) {\\n    if (f1 === nop)\\n        return f2;\\n    return function () {\\n        f1.apply(this, arguments);\\n        var onsuccess = this.onsuccess, \\u002F\\u002F In case event listener has set this.onsuccess\\n        onerror = this.onerror; \\u002F\\u002F In case event listener has set this.onerror\\n        this.onsuccess = this.onerror = null;\\n        f2.apply(this, arguments);\\n        if (onsuccess)\\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\\n        if (onerror)\\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\\n    };\\n}\\nfunction hookUpdatingChain(f1, f2) {\\n    if (f1 === nop)\\n        return f2;\\n    return function (modifications) {\\n        var res = f1.apply(this, arguments);\\n        extend(modifications, res); \\u002F\\u002F If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.\\n        var onsuccess = this.onsuccess, \\u002F\\u002F In case event listener has set this.onsuccess\\n        onerror = this.onerror; \\u002F\\u002F In case event listener has set this.onerror\\n        this.onsuccess = null;\\n        this.onerror = null;\\n        var res2 = f2.apply(this, arguments);\\n        if (onsuccess)\\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\\n        if (onerror)\\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\\n        return res === undefined ?\\n            (res2 === undefined ? undefined : res2) :\\n            (extend(res, res2));\\n    };\\n}\\nfunction reverseStoppableEventChain(f1, f2) {\\n    if (f1 === nop)\\n        return f2;\\n    return function () {\\n        if (f2.apply(this, arguments) === false)\\n            return false;\\n        return f1.apply(this, arguments);\\n    };\\n}\\n\\nfunction promisableChain(f1, f2) {\\n    if (f1 === nop)\\n        return f2;\\n    return function () {\\n        var res = f1.apply(this, arguments);\\n        if (res && typeof res.then === 'function') {\\n            var thiz = this, i = arguments.length, args = new Array(i);\\n            while (i--)\\n                args[i] = arguments[i];\\n            return res.then(function () {\\n                return f2.apply(thiz, args);\\n            });\\n        }\\n        return f2.apply(this, arguments);\\n    };\\n}\\n\\n\\u002F*\\n * Copyright (c) 2014-2017 David Fahlander\\n * Apache License Version 2.0, January 2004, http:\\u002F\\u002Fwww.apache.org\\u002Flicenses\\u002FLICENSE-2.0\\n *\\u002F\\n\\u002F\\u002F\\n\\u002F\\u002F Promise and Zone (PSD) for Dexie library\\n\\u002F\\u002F\\n\\u002F\\u002F I started out writing this Promise class by copying promise-light (https:\\u002F\\u002Fgithub.com\\u002Ftaylorhakes\\u002Fpromise-light) by\\n\\u002F\\u002F https:\\u002F\\u002Fgithub.com\\u002Ftaylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.\\n\\u002F\\u002F\\n\\u002F\\u002F In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another\\n\\u002F\\u002F tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use\\n\\u002F\\u002F another strategy now that simplifies everything a lot: to always execute callbacks in a new micro-task, but have an own micro-task\\n\\u002F\\u002F engine that is indexedDB compliant across all browsers.\\n\\u002F\\u002F Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.\\n\\u002F\\u002F Also with inspiration from bluebird, asyncronic stacks in debug mode.\\n\\u002F\\u002F\\n\\u002F\\u002F Specific non-standard features of this Promise class:\\n\\u002F\\u002F * Custom zone support (a.k.a. PSD) with ability to keep zones also when using native promises as well as\\n\\u002F\\u002F   native async \\u002F await.\\n\\u002F\\u002F * Promise.follow() method built upon the custom zone engine, that allows user to track all promises created from current stack frame\\n\\u002F\\u002F   and below + all promises that those promises creates or awaits.\\n\\u002F\\u002F * Detect any unhandled promise in a PSD-scope (PSD.onunhandled). \\n\\u002F\\u002F\\n\\u002F\\u002F David Fahlander, https:\\u002F\\u002Fgithub.com\\u002Fdfahlander\\n\\u002F\\u002F\\n\\u002F\\u002F Just a pointer that only this module knows about.\\n\\u002F\\u002F Used in Promise constructor to emulate a private constructor.\\nvar INTERNAL = {};\\n\\u002F\\u002F Async stacks (long stacks) must not grow infinitely.\\nvar LONG_STACKS_CLIP_LIMIT = 100;\\nvar MAX_LONG_STACKS = 20;\\nvar ZONE_ECHO_LIMIT = 7;\\nvar nativePromiseInstanceAndProto = (function () {\\n    try {\\n        \\u002F\\u002F Be able to patch native async functions\\n        return new Function(\\\"let F=async ()=\\u003E{},p=F();return [p,Object.getPrototypeOf(p),Promise.resolve(),F.constructor];\\\")();\\n    }\\n    catch (e) {\\n        var P = _global.Promise;\\n        return P ?\\n            [P.resolve(), P.prototype, P.resolve()] :\\n            [];\\n    }\\n})();\\nvar resolvedNativePromise = nativePromiseInstanceAndProto[0];\\nvar nativePromiseProto = nativePromiseInstanceAndProto[1];\\nvar resolvedGlobalPromise = nativePromiseInstanceAndProto[2];\\nvar nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\\nvar NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\\nvar AsyncFunction = nativePromiseInstanceAndProto[3];\\nvar patchGlobalPromise = !!resolvedGlobalPromise;\\nvar stack_being_generated = false;\\n\\u002F* The default function used only for the very first promise in a promise chain.\\n   As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks\\n   emulated in this module. For indexedDB compatibility, this means that every method needs to\\n   execute at least one promise before doing an indexedDB operation. Dexie will always call\\n   db.ready().then() for every operation to make sure the indexedDB event is started in an\\n   indexedDB-compatible emulated micro task loop.\\n*\\u002F\\nvar schedulePhysicalTick = resolvedGlobalPromise ?\\n    function () { resolvedGlobalPromise.then(physicalTick); }\\n    :\\n        _global.setImmediate ?\\n            \\u002F\\u002F setImmediate supported. Those modern platforms also supports Function.bind().\\n            setImmediate.bind(null, physicalTick) :\\n            _global.MutationObserver ?\\n                \\u002F\\u002F MutationObserver supported\\n                function () {\\n                    var hiddenDiv = document.createElement(\\\"div\\\");\\n                    (new MutationObserver(function () {\\n                        physicalTick();\\n                        hiddenDiv = null;\\n                    })).observe(hiddenDiv, { attributes: true });\\n                    hiddenDiv.setAttribute('i', '1');\\n                } :\\n                \\u002F\\u002F No support for setImmediate or MutationObserver. No worry, setTimeout is only called\\n                \\u002F\\u002F once time. Every tick that follows will be our emulated micro tick.\\n                \\u002F\\u002F Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug \\n                function () { setTimeout(physicalTick, 0); };\\n\\u002F\\u002F Configurable through Promise.scheduler.\\n\\u002F\\u002F Don't export because it would be unsafe to let unknown\\n\\u002F\\u002F code call it unless they do try..catch within their callback.\\n\\u002F\\u002F This function can be retrieved through getter of Promise.scheduler though,\\n\\u002F\\u002F but users must not do Promise.scheduler = myFuncThatThrowsException\\nvar asap$1 = function (callback, args) {\\n    microtickQueue.push([callback, args]);\\n    if (needsNewPhysicalTick) {\\n        schedulePhysicalTick();\\n        needsNewPhysicalTick = false;\\n    }\\n};\\nvar isOutsideMicroTick = true;\\nvar needsNewPhysicalTick = true;\\nvar unhandledErrors = [];\\nvar rejectingErrors = [];\\nvar currentFulfiller = null;\\nvar rejectionMapper = mirror; \\u002F\\u002F Remove in next major when removing error mapping of DOMErrors and DOMExceptions\\nvar globalPSD = {\\n    id: 'global',\\n    global: true,\\n    ref: 0,\\n    unhandleds: [],\\n    onunhandled: globalError,\\n    pgp: false,\\n    env: {},\\n    finalize: function () {\\n        this.unhandleds.forEach(function (uh) {\\n            try {\\n                globalError(uh[0], uh[1]);\\n            }\\n            catch (e) { }\\n        });\\n    }\\n};\\nvar PSD = globalPSD;\\nvar microtickQueue = []; \\u002F\\u002F Callbacks to call in this or next physical tick.\\nvar numScheduledCalls = 0; \\u002F\\u002F Number of listener-calls left to do in this physical tick.\\nvar tickFinalizers = []; \\u002F\\u002F Finalizers to call when there are no more async calls scheduled within current physical tick.\\nfunction Promise(fn) {\\n    if (typeof this !== 'object')\\n        throw new TypeError('Promises must be constructed via new');\\n    this._listeners = [];\\n    this.onuncatched = nop; \\u002F\\u002F Deprecate in next major. Not needed. Better to use global error handler.\\n    \\u002F\\u002F A library may set `promise._lib = true;` after promise is created to make resolve() or reject()\\n    \\u002F\\u002F execute the microtask engine implicitely within the call to resolve() or reject().\\n    \\u002F\\u002F To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack\\n    \\u002F\\u002F only contains library code when calling resolve() or reject().\\n    \\u002F\\u002F RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving\\u002Frejecting directly from\\n    \\u002F\\u002F global scope (event handler, timer etc)!\\n    this._lib = false;\\n    \\u002F\\u002F Current async scope\\n    var psd = (this._PSD = PSD);\\n    if (debug) {\\n        this._stackHolder = getErrorWithStack();\\n        this._prev = null;\\n        this._numPrev = 0; \\u002F\\u002F Number of previous promises (for long stacks)\\n    }\\n    if (typeof fn !== 'function') {\\n        if (fn !== INTERNAL)\\n            throw new TypeError('Not a function');\\n        \\u002F\\u002F Private constructor (INTERNAL, state, value).\\n        \\u002F\\u002F Used internally by Promise.resolve() and Promise.reject().\\n        this._state = arguments[1];\\n        this._value = arguments[2];\\n        if (this._state === false)\\n            handleRejection(this, this._value); \\u002F\\u002F Map error, set stack and addPossiblyUnhandledError().\\n        return;\\n    }\\n    this._state = null; \\u002F\\u002F null (=pending), false (=rejected) or true (=resolved)\\n    this._value = null; \\u002F\\u002F error or result\\n    ++psd.ref; \\u002F\\u002F Refcounting current scope\\n    executePromiseTask(this, fn);\\n}\\n\\u002F\\u002F Prepare a property descriptor to put onto Promise.prototype.then\\nvar thenProp = {\\n    get: function () {\\n        var psd = PSD, microTaskId = totalEchoes;\\n        function then(onFulfilled, onRejected) {\\n            var _this = this;\\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\\n            if (possibleAwait)\\n                decrementExpectedAwaits();\\n            var rv = new Promise(function (resolve, reject) {\\n                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait), resolve, reject, psd));\\n            });\\n            debug && linkToPreviousPromise(rv, this);\\n            return rv;\\n        }\\n        then.prototype = INTERNAL; \\u002F\\u002F For idempotense, see setter below.\\n        return then;\\n    },\\n    \\u002F\\u002F Be idempotent and allow another framework (such as zone.js or another instance of a Dexie.Promise module) to replace Promise.prototype.then\\n    \\u002F\\u002F and when that framework wants to restore the original property, we must identify that and restore the original property descriptor.\\n    set: function (value) {\\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\\n            thenProp : \\u002F\\u002F Restore to original property descriptor.\\n            {\\n                get: function () {\\n                    return value; \\u002F\\u002F Getter returning provided value (behaves like value is just changed)\\n                },\\n                set: thenProp.set \\u002F\\u002F Keep a setter that is prepared to restore original.\\n            });\\n    }\\n};\\nprops(Promise.prototype, {\\n    then: thenProp,\\n    _then: function (onFulfilled, onRejected) {\\n        \\u002F\\u002F A little tinier version of then() that don't have to create a resulting promise.\\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\\n    },\\n    catch: function (onRejected) {\\n        if (arguments.length === 1)\\n            return this.then(null, onRejected);\\n        \\u002F\\u002F First argument is the Error type to catch\\n        var type = arguments[0], handler = arguments[1];\\n        return typeof type === 'function' ? this.then(null, function (err) {\\n            \\u002F\\u002F Catching errors by its constructor type (similar to java \\u002F c++ \\u002F c#)\\n            \\u002F\\u002F Sample: promise.catch(TypeError, function (e) { ... });\\n            return err instanceof type ? handler(err) : PromiseReject(err);\\n        })\\n            : this.then(null, function (err) {\\n                \\u002F\\u002F Catching errors by the error.name property. Makes sense for indexedDB where error type\\n                \\u002F\\u002F is always DOMError but where e.name tells the actual error type.\\n                \\u002F\\u002F Sample: promise.catch('ConstraintError', function (e) { ... });\\n                return err && err.name === type ? handler(err) : PromiseReject(err);\\n            });\\n    },\\n    finally: function (onFinally) {\\n        return this.then(function (value) {\\n            onFinally();\\n            return value;\\n        }, function (err) {\\n            onFinally();\\n            return PromiseReject(err);\\n        });\\n    },\\n    stack: {\\n        get: function () {\\n            if (this._stack)\\n                return this._stack;\\n            try {\\n                stack_being_generated = true;\\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\\n                var stack = stacks.join(\\\"\\\\nFrom previous: \\\");\\n                if (this._state !== null)\\n                    this._stack = stack; \\u002F\\u002F Stack may be updated on reject.\\n                return stack;\\n            }\\n            finally {\\n                stack_being_generated = false;\\n            }\\n        }\\n    },\\n    timeout: function (ms, msg) {\\n        var _this = this;\\n        return ms \\u003C Infinity ?\\n            new Promise(function (resolve, reject) {\\n                var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\\n                _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\\n            }) : this;\\n    }\\n});\\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\\n    setProp(Promise.prototype, Symbol.toStringTag, 'Promise');\\n\\u002F\\u002F Now that Promise.prototype is defined, we have all it takes to set globalPSD.env.\\n\\u002F\\u002F Environment globals snapshotted on leaving global zone\\nglobalPSD.env = snapShot();\\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\\n    this.resolve = resolve;\\n    this.reject = reject;\\n    this.psd = zone;\\n}\\n\\u002F\\u002F Promise Static Properties\\nprops(Promise, {\\n    all: function () {\\n        var values = getArrayOf.apply(null, arguments) \\u002F\\u002F Supports iterables, implicit arguments and array-like.\\n            .map(onPossibleParallellAsync); \\u002F\\u002F Handle parallell async\\u002Fawaits \\n        return new Promise(function (resolve, reject) {\\n            if (values.length === 0)\\n                resolve([]);\\n            var remaining = values.length;\\n            values.forEach(function (a, i) { return Promise.resolve(a).then(function (x) {\\n                values[i] = x;\\n                if (!--remaining)\\n                    resolve(values);\\n            }, reject); });\\n        });\\n    },\\n    resolve: function (value) {\\n        if (value instanceof Promise)\\n            return value;\\n        if (value && typeof value.then === 'function')\\n            return new Promise(function (resolve, reject) {\\n                value.then(resolve, reject);\\n            });\\n        var rv = new Promise(INTERNAL, true, value);\\n        linkToPreviousPromise(rv, currentFulfiller);\\n        return rv;\\n    },\\n    reject: PromiseReject,\\n    race: function () {\\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\\n        return new Promise(function (resolve, reject) {\\n            values.map(function (value) { return Promise.resolve(value).then(resolve, reject); });\\n        });\\n    },\\n    PSD: {\\n        get: function () { return PSD; },\\n        set: function (value) { return PSD = value; }\\n    },\\n    \\u002F\\u002FtotalEchoes: {get: ()=\\u003EtotalEchoes},\\n    \\u002F\\u002Ftask: {get: ()=\\u003Etask},\\n    newPSD: newScope,\\n    usePSD: usePSD,\\n    scheduler: {\\n        get: function () { return asap$1; },\\n        set: function (value) { asap$1 = value; }\\n    },\\n    rejectionMapper: {\\n        get: function () { return rejectionMapper; },\\n        set: function (value) { rejectionMapper = value; } \\u002F\\u002F Map reject failures\\n    },\\n    follow: function (fn, zoneProps) {\\n        return new Promise(function (resolve, reject) {\\n            return newScope(function (resolve, reject) {\\n                var psd = PSD;\\n                psd.unhandleds = []; \\u002F\\u002F For unhandled standard- or 3rd party Promises. Checked at psd.finalize()\\n                psd.onunhandled = reject; \\u002F\\u002F Triggered directly on unhandled promises of this library.\\n                psd.finalize = callBoth(function () {\\n                    var _this = this;\\n                    \\u002F\\u002F Unhandled standard or 3rd part promises are put in PSD.unhandleds and\\n                    \\u002F\\u002F examined upon scope completion while unhandled rejections in this Promise\\n                    \\u002F\\u002F will trigger directly through psd.onunhandled\\n                    run_at_end_of_this_or_next_physical_tick(function () {\\n                        _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\\n                    });\\n                }, psd.finalize);\\n                fn();\\n            }, zoneProps, resolve, reject);\\n        });\\n    }\\n});\\n\\u002F**\\n* Take a potentially misbehaving resolver function and make sure\\n* onFulfilled and onRejected are only called once.\\n*\\n* Makes no guarantees about asynchrony.\\n*\\u002F\\nfunction executePromiseTask(promise, fn) {\\n    \\u002F\\u002F Promise Resolution Procedure:\\n    \\u002F\\u002F https:\\u002F\\u002Fgithub.com\\u002Fpromises-aplus\\u002Fpromises-spec#the-promise-resolution-procedure\\n    try {\\n        fn(function (value) {\\n            if (promise._state !== null)\\n                return; \\u002F\\u002F Already settled\\n            if (value === promise)\\n                throw new TypeError('A promise cannot be resolved with itself.');\\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\\n            if (value && typeof value.then === 'function') {\\n                executePromiseTask(promise, function (resolve, reject) {\\n                    value instanceof Promise ?\\n                        value._then(resolve, reject) :\\n                        value.then(resolve, reject);\\n                });\\n            }\\n            else {\\n                promise._state = true;\\n                promise._value = value;\\n                propagateAllListeners(promise);\\n            }\\n            if (shouldExecuteTick)\\n                endMicroTickScope();\\n        }, handleRejection.bind(null, promise)); \\u002F\\u002F If Function.bind is not supported. Exception is handled in catch below\\n    }\\n    catch (ex) {\\n        handleRejection(promise, ex);\\n    }\\n}\\nfunction handleRejection(promise, reason) {\\n    rejectingErrors.push(reason);\\n    if (promise._state !== null)\\n        return;\\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\\n    reason = rejectionMapper(reason);\\n    promise._state = false;\\n    promise._value = reason;\\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {\\n        var origProp = getPropertyDescriptor(reason, \\\"stack\\\");\\n        reason._promise = promise;\\n        setProp(reason, \\\"stack\\\", {\\n            get: function () {\\n                return stack_being_generated ?\\n                    origProp && (origProp.get ?\\n                        origProp.get.apply(reason) :\\n                        origProp.value) :\\n                    promise.stack;\\n            }\\n        });\\n    });\\n    \\u002F\\u002F Add the failure to a list of possibly uncaught errors\\n    addPossiblyUnhandledError(promise);\\n    propagateAllListeners(promise);\\n    if (shouldExecuteTick)\\n        endMicroTickScope();\\n}\\nfunction propagateAllListeners(promise) {\\n    \\u002F\\u002Fdebug && linkToPreviousPromise(promise);\\n    var listeners = promise._listeners;\\n    promise._listeners = [];\\n    for (var i = 0, len = listeners.length; i \\u003C len; ++i) {\\n        propagateToListener(promise, listeners[i]);\\n    }\\n    var psd = promise._PSD;\\n    --psd.ref || psd.finalize(); \\u002F\\u002F if psd.ref reaches zero, call psd.finalize();\\n    if (numScheduledCalls === 0) {\\n        \\u002F\\u002F If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,\\n        \\u002F\\u002F and that no deferreds where listening to this rejection or success.\\n        \\u002F\\u002F Since there is a risk that our stack can contain application code that may\\n        \\u002F\\u002F do stuff after this code is finished that may generate new calls, we cannot\\n        \\u002F\\u002F call finalizers here.\\n        ++numScheduledCalls;\\n        asap$1(function () {\\n            if (--numScheduledCalls === 0)\\n                finalizePhysicalTick(); \\u002F\\u002F Will detect unhandled errors\\n        }, []);\\n    }\\n}\\nfunction propagateToListener(promise, listener) {\\n    if (promise._state === null) {\\n        promise._listeners.push(listener);\\n        return;\\n    }\\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\\n    if (cb === null) {\\n        \\u002F\\u002F This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()\\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\\n    }\\n    ++listener.psd.ref;\\n    ++numScheduledCalls;\\n    asap$1(callListener, [cb, promise, listener]);\\n}\\nfunction callListener(cb, promise, listener) {\\n    try {\\n        \\u002F\\u002F Set static variable currentFulfiller to the promise that is being fullfilled,\\n        \\u002F\\u002F so that we connect the chain of promises (for long stacks support)\\n        currentFulfiller = promise;\\n        \\u002F\\u002F Call callback and resolve our listener with it's return value.\\n        var ret, value = promise._value;\\n        if (promise._state) {\\n            \\u002F\\u002F cb is onResolved\\n            ret = cb(value);\\n        }\\n        else {\\n            \\u002F\\u002F cb is onRejected\\n            if (rejectingErrors.length)\\n                rejectingErrors = [];\\n            ret = cb(value);\\n            if (rejectingErrors.indexOf(value) === -1)\\n                markErrorAsHandled(promise); \\u002F\\u002F Callback didnt do Promise.reject(err) nor reject(err) onto another promise.\\n        }\\n        listener.resolve(ret);\\n    }\\n    catch (e) {\\n        \\u002F\\u002F Exception thrown in callback. Reject our listener.\\n        listener.reject(e);\\n    }\\n    finally {\\n        \\u002F\\u002F Restore env and currentFulfiller.\\n        currentFulfiller = null;\\n        if (--numScheduledCalls === 0)\\n            finalizePhysicalTick();\\n        --listener.psd.ref || listener.psd.finalize();\\n    }\\n}\\nfunction getStack(promise, stacks, limit) {\\n    if (stacks.length === limit)\\n        return stacks;\\n    var stack = \\\"\\\";\\n    if (promise._state === false) {\\n        var failure = promise._value, errorName, message;\\n        if (failure != null) {\\n            errorName = failure.name || \\\"Error\\\";\\n            message = failure.message || failure;\\n            stack = prettyStack(failure, 0);\\n        }\\n        else {\\n            errorName = failure; \\u002F\\u002F If error is undefined or null, show that.\\n            message = \\\"\\\";\\n        }\\n        stacks.push(errorName + (message ? \\\": \\\" + message : \\\"\\\") + stack);\\n    }\\n    if (debug) {\\n        stack = prettyStack(promise._stackHolder, 2);\\n        if (stack && stacks.indexOf(stack) === -1)\\n            stacks.push(stack);\\n        if (promise._prev)\\n            getStack(promise._prev, stacks, limit);\\n    }\\n    return stacks;\\n}\\nfunction linkToPreviousPromise(promise, prev) {\\n    \\u002F\\u002F Support long stacks by linking to previous completed promise.\\n    var numPrev = prev ? prev._numPrev + 1 : 0;\\n    if (numPrev \\u003C LONG_STACKS_CLIP_LIMIT) {\\n        promise._prev = prev;\\n        promise._numPrev = numPrev;\\n    }\\n}\\n\\u002F* The callback to schedule with setImmediate() or setTimeout().\\n   It runs a virtual microtick and executes any callback registered in microtickQueue.\\n *\\u002F\\nfunction physicalTick() {\\n    beginMicroTickScope() && endMicroTickScope();\\n}\\nfunction beginMicroTickScope() {\\n    var wasRootExec = isOutsideMicroTick;\\n    isOutsideMicroTick = false;\\n    needsNewPhysicalTick = false;\\n    return wasRootExec;\\n}\\n\\u002F* Executes micro-ticks without doing try..catch.\\n   This can be possible because we only use this internally and\\n   the registered functions are exception-safe (they do try..catch\\n   internally before calling any external method). If registering\\n   functions in the microtickQueue that are not exception-safe, this\\n   would destroy the framework and make it instable. So we don't export\\n   our asap method.\\n*\\u002F\\nfunction endMicroTickScope() {\\n    var callbacks, i, l;\\n    do {\\n        while (microtickQueue.length \\u003E 0) {\\n            callbacks = microtickQueue;\\n            microtickQueue = [];\\n            l = callbacks.length;\\n            for (i = 0; i \\u003C l; ++i) {\\n                var item = callbacks[i];\\n                item[0].apply(null, item[1]);\\n            }\\n        }\\n    } while (microtickQueue.length \\u003E 0);\\n    isOutsideMicroTick = true;\\n    needsNewPhysicalTick = true;\\n}\\nfunction finalizePhysicalTick() {\\n    var unhandledErrs = unhandledErrors;\\n    unhandledErrors = [];\\n    unhandledErrs.forEach(function (p) {\\n        p._PSD.onunhandled.call(null, p._value, p);\\n    });\\n    var finalizers = tickFinalizers.slice(0); \\u002F\\u002F Clone first because finalizer may remove itself from list.\\n    var i = finalizers.length;\\n    while (i)\\n        finalizers[--i]();\\n}\\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\\n    function finalizer() {\\n        fn();\\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\\n    }\\n    tickFinalizers.push(finalizer);\\n    ++numScheduledCalls;\\n    asap$1(function () {\\n        if (--numScheduledCalls === 0)\\n            finalizePhysicalTick();\\n    }, []);\\n}\\nfunction addPossiblyUnhandledError(promise) {\\n    \\u002F\\u002F Only add to unhandledErrors if not already there. The first one to add to this list\\n    \\u002F\\u002F will be upon the first rejection so that the root cause (first promise in the\\n    \\u002F\\u002F rejection chain) is the one listed.\\n    if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\\n        unhandledErrors.push(promise);\\n}\\nfunction markErrorAsHandled(promise) {\\n    \\u002F\\u002F Called when a reject handled is actually being called.\\n    \\u002F\\u002F Search in unhandledErrors for any promise whos _value is this promise_value (list\\n    \\u002F\\u002F contains only rejected promises, and only one item per error)\\n    var i = unhandledErrors.length;\\n    while (i)\\n        if (unhandledErrors[--i]._value === promise._value) {\\n            \\u002F\\u002F Found a promise that failed with this same error object pointer,\\n            \\u002F\\u002F Remove that since there is a listener that actually takes care of it.\\n            unhandledErrors.splice(i, 1);\\n            return;\\n        }\\n}\\nfunction PromiseReject(reason) {\\n    return new Promise(INTERNAL, false, reason);\\n}\\nfunction wrap(fn, errorCatcher) {\\n    var psd = PSD;\\n    return function () {\\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\\n        try {\\n            switchToZone(psd, true);\\n            return fn.apply(this, arguments);\\n        }\\n        catch (e) {\\n            errorCatcher && errorCatcher(e);\\n        }\\n        finally {\\n            switchToZone(outerScope, false);\\n            if (wasRootExec)\\n                endMicroTickScope();\\n        }\\n    };\\n}\\n\\u002F\\u002F\\n\\u002F\\u002F variables used for native await support\\n\\u002F\\u002F\\nvar task = { awaits: 0, echoes: 0, id: 0 }; \\u002F\\u002F The ongoing macro-task when using zone-echoing.\\nvar taskCounter = 0; \\u002F\\u002F ID counter for macro tasks.\\nvar zoneStack = []; \\u002F\\u002F Stack of left zones to restore asynchronically.\\nvar zoneEchoes = 0; \\u002F\\u002F zoneEchoes is a must in order to persist zones between native await expressions.\\nvar totalEchoes = 0; \\u002F\\u002F ID counter for micro-tasks. Used to detect possible native await in our Promise.prototype.then.\\nvar zone_id_counter = 0;\\nfunction newScope(fn, props$$1, a1, a2) {\\n    var parent = PSD, psd = Object.create(parent);\\n    psd.parent = parent;\\n    psd.ref = 0;\\n    psd.global = false;\\n    psd.id = ++zone_id_counter;\\n    \\u002F\\u002F Prepare for promise patching (done in usePSD):\\n    var globalEnv = globalPSD.env;\\n    psd.env = patchGlobalPromise ? {\\n        Promise: Promise,\\n        PromiseProp: { value: Promise, configurable: true, writable: true },\\n        all: Promise.all,\\n        race: Promise.race,\\n        resolve: Promise.resolve,\\n        reject: Promise.reject,\\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd) \\u002F\\u002F global then\\n    } : {};\\n    if (props$$1)\\n        extend(psd, props$$1);\\n    \\u002F\\u002F unhandleds and onunhandled should not be specifically set here.\\n    \\u002F\\u002F Leave them on parent prototype.\\n    \\u002F\\u002F unhandleds.push(err) will push to parent's prototype\\n    \\u002F\\u002F onunhandled() will call parents onunhandled (with this scope's this-pointer though!)\\n    ++parent.ref;\\n    psd.finalize = function () {\\n        --this.parent.ref || this.parent.finalize();\\n    };\\n    var rv = usePSD(psd, fn, a1, a2);\\n    if (psd.ref === 0)\\n        psd.finalize();\\n    return rv;\\n}\\n\\u002F\\u002F Function to call if scopeFunc returns NativePromise\\n\\u002F\\u002F Also for each NativePromise in the arguments to Promise.all()\\nfunction incrementExpectedAwaits() {\\n    if (!task.id)\\n        task.id = ++taskCounter;\\n    ++task.awaits;\\n    task.echoes += ZONE_ECHO_LIMIT;\\n    return task.id;\\n}\\n\\u002F\\u002F Function to call when 'then' calls back on a native promise where onAwaitExpected() had been called.\\n\\u002F\\u002F Also call this when a native await calls then method on a promise. In that case, don't supply\\n\\u002F\\u002F sourceTaskId because we already know it refers to current task.\\nfunction decrementExpectedAwaits(sourceTaskId) {\\n    if (!task.awaits || (sourceTaskId && sourceTaskId !== task.id))\\n        return;\\n    if (--task.awaits === 0)\\n        task.id = 0;\\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT; \\u002F\\u002F Will reset echoes to 0 if awaits is 0.\\n}\\n\\u002F\\u002F Call from Promise.all() and Promise.race()\\nfunction onPossibleParallellAsync(possiblePromise) {\\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\\n        incrementExpectedAwaits();\\n        return possiblePromise.then(function (x) {\\n            decrementExpectedAwaits();\\n            return x;\\n        }, function (e) {\\n            decrementExpectedAwaits();\\n            return rejection(e);\\n        });\\n    }\\n    return possiblePromise;\\n}\\nfunction zoneEnterEcho(targetZone) {\\n    ++totalEchoes;\\n    if (!task.echoes || --task.echoes === 0) {\\n        task.echoes = task.id = 0; \\u002F\\u002F Cancel zone echoing.\\n    }\\n    zoneStack.push(PSD);\\n    switchToZone(targetZone, true);\\n}\\nfunction zoneLeaveEcho() {\\n    var zone = zoneStack[zoneStack.length - 1];\\n    zoneStack.pop();\\n    switchToZone(zone, false);\\n}\\nfunction switchToZone(targetZone, bEnteringZone) {\\n    var currentZone = PSD;\\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\\n        \\u002F\\u002F Enter or leave zone asynchronically as well, so that tasks initiated during current tick\\n        \\u002F\\u002F will be surrounded by the zone when they are invoked.\\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\\n    }\\n    if (targetZone === PSD)\\n        return;\\n    PSD = targetZone; \\u002F\\u002F The actual zone switch occurs at this line.\\n    \\u002F\\u002F Snapshot on every leave from global zone.\\n    if (currentZone === globalPSD)\\n        globalPSD.env = snapShot();\\n    if (patchGlobalPromise) {\\n        \\u002F\\u002F Let's patch the global and native Promises (may be same or may be different)\\n        var GlobalPromise = globalPSD.env.Promise;\\n        \\u002F\\u002F Swich environments (may be PSD-zone or the global zone. Both apply.)\\n        var targetEnv = targetZone.env;\\n        \\u002F\\u002F Change Promise.prototype.then for native and global Promise (they MAY differ on polyfilled environments, but both can be accessed)\\n        \\u002F\\u002F Must be done on each zone change because the patched method contains targetZone in its closure.\\n        nativePromiseProto.then = targetEnv.nthen;\\n        GlobalPromise.prototype.then = targetEnv.gthen;\\n        if (currentZone.global || targetZone.global) {\\n            \\u002F\\u002F Leaving or entering global zone. It's time to patch \\u002F restore global Promise.\\n            \\u002F\\u002F Set this Promise to window.Promise so that transiled async functions will work on Firefox, Safari and IE, as well as with Zonejs and angular.\\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\\n            \\u002F\\u002F Support Promise.all() etc to work indexedDB-safe also when people are including es6-promise as a module (they might\\n            \\u002F\\u002F not be accessing global.Promise but a local reference to it)\\n            GlobalPromise.all = targetEnv.all;\\n            GlobalPromise.race = targetEnv.race;\\n            GlobalPromise.resolve = targetEnv.resolve;\\n            GlobalPromise.reject = targetEnv.reject;\\n        }\\n    }\\n}\\nfunction snapShot() {\\n    var GlobalPromise = _global.Promise;\\n    return patchGlobalPromise ? {\\n        Promise: GlobalPromise,\\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \\\"Promise\\\"),\\n        all: GlobalPromise.all,\\n        race: GlobalPromise.race,\\n        resolve: GlobalPromise.resolve,\\n        reject: GlobalPromise.reject,\\n        nthen: nativePromiseProto.then,\\n        gthen: GlobalPromise.prototype.then\\n    } : {};\\n}\\nfunction usePSD(psd, fn, a1, a2, a3) {\\n    var outerScope = PSD;\\n    try {\\n        switchToZone(psd, true);\\n        return fn(a1, a2, a3);\\n    }\\n    finally {\\n        switchToZone(outerScope, false);\\n    }\\n}\\nfunction enqueueNativeMicroTask(job) {\\n    \\u002F\\u002F\\n    \\u002F\\u002F Precondition: nativePromiseThen !== undefined\\n    \\u002F\\u002F\\n    nativePromiseThen.call(resolvedNativePromise, job);\\n}\\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait) {\\n    return typeof fn !== 'function' ? fn : function () {\\n        var outerZone = PSD;\\n        if (possibleAwait)\\n            incrementExpectedAwaits();\\n        switchToZone(zone, true);\\n        try {\\n            return fn.apply(this, arguments);\\n        }\\n        finally {\\n            switchToZone(outerZone, false);\\n        }\\n    };\\n}\\nfunction getPatchedPromiseThen(origThen, zone) {\\n    return function (onResolved, onRejected) {\\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone, false), nativeAwaitCompatibleWrap(onRejected, zone, false));\\n    };\\n}\\nvar UNHANDLEDREJECTION = \\\"unhandledrejection\\\";\\nfunction globalError(err, promise) {\\n    var rv;\\n    try {\\n        rv = promise.onuncatched(err);\\n    }\\n    catch (e) { }\\n    if (rv !== false)\\n        try {\\n            var event, eventData = { promise: promise, reason: err };\\n            if (_global.document && document.createEvent) {\\n                event = document.createEvent('Event');\\n                event.initEvent(UNHANDLEDREJECTION, true, true);\\n                extend(event, eventData);\\n            }\\n            else if (_global.CustomEvent) {\\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\\n                extend(event, eventData);\\n            }\\n            if (event && _global.dispatchEvent) {\\n                dispatchEvent(event);\\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\\n                    \\u002F\\u002F No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.\\n                    try {\\n                        _global.onunhandledrejection(event);\\n                    }\\n                    catch (_) { }\\n            }\\n            if (!event.defaultPrevented) {\\n                console.warn(\\\"Unhandled rejection: \\\" + (err.stack || err));\\n            }\\n        }\\n        catch (e) { }\\n}\\nvar rejection = Promise.reject;\\n\\nfunction Events(ctx) {\\n    var evs = {};\\n    var rv = function (eventName, subscriber) {\\n        if (subscriber) {\\n            \\u002F\\u002F Subscribe. If additional arguments than just the subscriber was provided, forward them as well.\\n            var i = arguments.length, args = new Array(i - 1);\\n            while (--i)\\n                args[i - 1] = arguments[i];\\n            evs[eventName].subscribe.apply(null, args);\\n            return ctx;\\n        }\\n        else if (typeof (eventName) === 'string') {\\n            \\u002F\\u002F Return interface allowing to fire or unsubscribe from event\\n            return evs[eventName];\\n        }\\n    };\\n    rv.addEventType = add;\\n    for (var i = 1, l = arguments.length; i \\u003C l; ++i) {\\n        add(arguments[i]);\\n    }\\n    return rv;\\n    function add(eventName, chainFunction, defaultFunction) {\\n        if (typeof eventName === 'object')\\n            return addConfiguredEvents(eventName);\\n        if (!chainFunction)\\n            chainFunction = reverseStoppableEventChain;\\n        if (!defaultFunction)\\n            defaultFunction = nop;\\n        var context = {\\n            subscribers: [],\\n            fire: defaultFunction,\\n            subscribe: function (cb) {\\n                if (context.subscribers.indexOf(cb) === -1) {\\n                    context.subscribers.push(cb);\\n                    context.fire = chainFunction(context.fire, cb);\\n                }\\n            },\\n            unsubscribe: function (cb) {\\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\\n            }\\n        };\\n        evs[eventName] = rv[eventName] = context;\\n        return context;\\n    }\\n    function addConfiguredEvents(cfg) {\\n        \\u002F\\u002F events(this, {reading: [functionChain, nop]});\\n        keys(cfg).forEach(function (eventName) {\\n            var args = cfg[eventName];\\n            if (isArray(args)) {\\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\\n            }\\n            else if (args === 'asap') {\\n                \\u002F\\u002F Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack\\n                \\u002F\\u002F enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.\\n                var context = add(eventName, mirror, function fire() {\\n                    \\u002F\\u002F Optimazation-safe cloning of arguments into args.\\n                    var i = arguments.length, args = new Array(i);\\n                    while (i--)\\n                        args[i] = arguments[i];\\n                    \\u002F\\u002F All each subscriber:\\n                    context.subscribers.forEach(function (fn) {\\n                        asap(function fireEvent() {\\n                            fn.apply(null, args);\\n                        });\\n                    });\\n                });\\n            }\\n            else\\n                throw new exceptions.InvalidArgument(\\\"Invalid event config\\\");\\n        });\\n    }\\n}\\n\\n\\u002F*\\n * Dexie.js - a minimalistic wrapper for IndexedDB\\n * ===============================================\\n *\\n * Copyright (c) 2014-2017 David Fahlander\\n *\\n * Version {version}, {date}\\n *\\n * http:\\u002F\\u002Fdexie.org\\n *\\n * Apache License Version 2.0, January 2004, http:\\u002F\\u002Fwww.apache.org\\u002Flicenses\\u002FLICENSE-2.0\\n *\\n *\\u002F\\nvar DEXIE_VERSION = '{version}';\\nvar maxString = String.fromCharCode(65535);\\nvar maxKey = (function () { try {\\n    IDBKeyRange.only([[]]);\\n    return [[]];\\n}\\ncatch (e) {\\n    return maxString;\\n} })();\\nvar minKey = -Infinity;\\nvar INVALID_KEY_ARGUMENT = \\\"Invalid key provided. Keys must be of type string, number, Date or Array\\u003Cstring | number | Date\\u003E.\\\";\\nvar STRING_EXPECTED = \\\"String expected.\\\";\\nvar connections = [];\\nvar isIEOrEdge = typeof navigator !== 'undefined' && \\u002F(MSIE|Trident|Edge)\\u002F.test(navigator.userAgent);\\nvar hasIEDeleteObjectStoreBug = isIEOrEdge;\\nvar hangsOnDeleteLargeKeyRange = isIEOrEdge;\\nvar dexieStackFrameFilter = function (frame) { return !\\u002F(dexie\\\\.js|dexie\\\\.min\\\\.js)\\u002F.test(frame); };\\nvar dbNamesDB; \\u002F\\u002F Global database for backing Dexie.getDatabaseNames() on browser without indexedDB.webkitGetDatabaseNames() \\n\\u002F\\u002F Init debug\\nsetDebug(debug, dexieStackFrameFilter);\\nfunction Dexie(dbName, options) {\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"options\\\" type=\\\"Object\\\" optional=\\\"true\\\"\\u003ESpecify only if you wich to control which addons that should run on this instance\\u003C\\u002Fparam\\u003E\\n    var deps = Dexie.dependencies;\\n    var opts = extend({\\n        \\u002F\\u002F Default Options\\n        addons: Dexie.addons,\\n        autoOpen: true,\\n        indexedDB: deps.indexedDB,\\n        IDBKeyRange: deps.IDBKeyRange \\u002F\\u002F Backend IDBKeyRange api. Default to browser env.\\n    }, options);\\n    var addons = opts.addons, autoOpen = opts.autoOpen, indexedDB = opts.indexedDB, IDBKeyRange = opts.IDBKeyRange;\\n    var globalSchema = this._dbSchema = {};\\n    var versions = [];\\n    var dbStoreNames = [];\\n    var allTables = {};\\n    \\u002F\\u002F\\u002F\\u003Cvar type=\\\"IDBDatabase\\\" \\u002F\\u003E\\n    var idbdb = null; \\u002F\\u002F Instance of IDBDatabase\\n    var dbOpenError = null;\\n    var isBeingOpened = false;\\n    var onReadyBeingFired = null;\\n    var openComplete = false;\\n    var READONLY = \\\"readonly\\\", READWRITE = \\\"readwrite\\\";\\n    var db = this;\\n    var dbReadyResolve, dbReadyPromise = new Promise(function (resolve) {\\n        dbReadyResolve = resolve;\\n    }), cancelOpen, openCanceller = new Promise(function (_, reject) {\\n        cancelOpen = reject;\\n    });\\n    var autoSchema = true;\\n    var hasNativeGetDatabaseNames = !!getNativeGetDatabaseNamesFn(indexedDB), hasGetAll;\\n    function init() {\\n        \\u002F\\u002F Default subscribers to \\\"versionchange\\\" and \\\"blocked\\\".\\n        \\u002F\\u002F Can be overridden by custom handlers. If custom handlers return false, these default\\n        \\u002F\\u002F behaviours will be prevented.\\n        db.on(\\\"versionchange\\\", function (ev) {\\n            \\u002F\\u002F Default behavior for versionchange event is to close database connection.\\n            \\u002F\\u002F Caller can override this behavior by doing db.on(\\\"versionchange\\\", function(){ return false; });\\n            \\u002F\\u002F Let's not block the other window from making it's delete() or open() call.\\n            \\u002F\\u002F NOTE! This event is never fired in IE,Edge or Safari.\\n            if (ev.newVersion \\u003E 0)\\n                console.warn(\\\"Another connection wants to upgrade database '\\\" + db.name + \\\"'. Closing db now to resume the upgrade.\\\");\\n            else\\n                console.warn(\\\"Another connection wants to delete database '\\\" + db.name + \\\"'. Closing db now to resume the delete request.\\\");\\n            db.close();\\n            \\u002F\\u002F In many web applications, it would be recommended to force window.reload()\\n            \\u002F\\u002F when this event occurs. To do that, subscribe to the versionchange event\\n            \\u002F\\u002F and call window.location.reload(true) if ev.newVersion \\u003E 0 (not a deletion)\\n            \\u002F\\u002F The reason for this is that your current web app obviously has old schema code that needs\\n            \\u002F\\u002F to be updated. Another window got a newer version of the app and needs to upgrade DB but\\n            \\u002F\\u002F your window is blocking it unless we close it here.\\n        });\\n        db.on(\\\"blocked\\\", function (ev) {\\n            if (!ev.newVersion || ev.newVersion \\u003C ev.oldVersion)\\n                console.warn(\\\"Dexie.delete('\\\" + db.name + \\\"') was blocked\\\");\\n            else\\n                console.warn(\\\"Upgrade '\\\" + db.name + \\\"' blocked by other connection holding version \\\" + ev.oldVersion \\u002F 10);\\n        });\\n    }\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F ------------------------- Versioning Framework---------------------------\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    this.version = function (versionNumber) {\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"versionNumber\\\" type=\\\"Number\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Creturns type=\\\"Version\\\"\\u003E\\u003C\\u002Freturns\\u003E\\n        if (idbdb || isBeingOpened)\\n            throw new exceptions.Schema(\\\"Cannot add version when database is open\\\");\\n        this.verno = Math.max(this.verno, versionNumber);\\n        var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\\n        if (versionInstance)\\n            return versionInstance;\\n        versionInstance = new Version(versionNumber);\\n        versions.push(versionInstance);\\n        versions.sort(lowerVersionFirst);\\n        \\u002F\\u002F Disable autoschema mode, as at least one version is specified.\\n        autoSchema = false;\\n        return versionInstance;\\n    };\\n    function Version(versionNumber) {\\n        this._cfg = {\\n            version: versionNumber,\\n            storesSource: null,\\n            dbschema: {},\\n            tables: {},\\n            contentUpgrade: null\\n        };\\n        this.stores({}); \\u002F\\u002F Derive earlier schemas by default.\\n    }\\n    extend(Version.prototype, {\\n        stores: function (stores) {\\n            \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n            \\u002F\\u002F\\u002F   Defines the schema for a particular version\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"stores\\\" type=\\\"Object\\\"\\u003E\\n            \\u002F\\u002F\\u002F Example: \\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F   {users: \\\"id++,first,last,&amp;username,*email\\\", \\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F   passwords: \\\"id++,&amp;username\\\"}\\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F Syntax: {Table: \\\"[primaryKey][++],[&amp;][*]index1,[&amp;][*]index2,...\\\"}\\u003Cbr\\u002F\\u003E\\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F Special characters:\\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F  \\\"&amp;\\\"  means unique key, \\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F  \\\"*\\\"  means value is multiEntry, \\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F  \\\"++\\\" means auto-increment and only applicable for primary key \\u003Cbr\\u002F\\u003E\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fparam\\u003E\\n            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\\n            \\u002F\\u002F Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.\\n            var storesSpec = {};\\n            versions.forEach(function (version) {\\n                extend(storesSpec, version._cfg.storesSource);\\n            });\\n            var dbschema = (this._cfg.dbschema = {});\\n            this._parseStoresSpec(storesSpec, dbschema);\\n            \\u002F\\u002F Update the latest schema to this version\\n            \\u002F\\u002F Update API\\n            globalSchema = db._dbSchema = dbschema;\\n            removeTablesApi([allTables, db, Transaction.prototype]); \\u002F\\u002F Keep Transaction.prototype even though it should be depr.\\n            setApiOnPlace([allTables, db, Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\\n            dbStoreNames = keys(dbschema);\\n            return this;\\n        },\\n        upgrade: function (upgradeFunction) {\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"upgradeFunction\\\" optional=\\\"true\\\"\\u003EFunction that performs upgrading actions.\\u003C\\u002Fparam\\u003E\\n            var self = this;\\n            this._cfg.contentUpgrade = upgradeFunction;\\n            return this;\\n        },\\n        _parseStoresSpec: function (stores, outSchema) {\\n            keys(stores).forEach(function (tableName) {\\n                if (stores[tableName] !== null) {\\n                    var instanceTemplate = {};\\n                    var indexes = parseIndexSyntax(stores[tableName]);\\n                    var primKey = indexes.shift();\\n                    if (primKey.multi)\\n                        throw new exceptions.Schema(\\\"Primary key cannot be multi-valued\\\");\\n                    if (primKey.keyPath)\\n                        setByKeyPath(instanceTemplate, primKey.keyPath, primKey.auto ? 0 : primKey.keyPath);\\n                    indexes.forEach(function (idx) {\\n                        if (idx.auto)\\n                            throw new exceptions.Schema(\\\"Only primary key can be marked as autoIncrement (++)\\\");\\n                        if (!idx.keyPath)\\n                            throw new exceptions.Schema(\\\"Index must have a name and cannot be an empty string\\\");\\n                        setByKeyPath(instanceTemplate, idx.keyPath, idx.compound ? idx.keyPath.map(function () { return \\\"\\\"; }) : \\\"\\\");\\n                    });\\n                    outSchema[tableName] = new TableSchema(tableName, primKey, indexes, instanceTemplate);\\n                }\\n            });\\n        }\\n    });\\n    function runUpgraders(oldVersion, idbtrans, reject) {\\n        var trans = db._createTransaction(READWRITE, dbStoreNames, globalSchema);\\n        trans.create(idbtrans);\\n        trans._completion.catch(reject);\\n        var rejectTransaction = trans._reject.bind(trans);\\n        newScope(function () {\\n            PSD.trans = trans;\\n            if (oldVersion === 0) {\\n                \\u002F\\u002F Create tables:\\n                keys(globalSchema).forEach(function (tableName) {\\n                    createTable(idbtrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\\n                });\\n                Promise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\\n            }\\n            else\\n                updateTablesAndIndexes(oldVersion, trans, idbtrans).catch(rejectTransaction);\\n        });\\n    }\\n    function updateTablesAndIndexes(oldVersion, trans, idbtrans) {\\n        \\u002F\\u002F Upgrade version to version, step-by-step from oldest to newest version.\\n        \\u002F\\u002F Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)\\n        var queue = [];\\n        var oldVersionStruct = versions.filter(function (version) { return version._cfg.version === oldVersion; })[0];\\n        if (!oldVersionStruct)\\n            throw new exceptions.Upgrade(\\\"Dexie specification of currently installed DB version is missing\\\");\\n        globalSchema = db._dbSchema = oldVersionStruct._cfg.dbschema;\\n        var anyContentUpgraderHasRun = false;\\n        var versToRun = versions.filter(function (v) { return v._cfg.version \\u003E oldVersion; });\\n        versToRun.forEach(function (version) {\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"version\\\" type=\\\"Version\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n            queue.push(function () {\\n                var oldSchema = globalSchema;\\n                var newSchema = version._cfg.dbschema;\\n                adjustToExistingIndexNames(oldSchema, idbtrans);\\n                adjustToExistingIndexNames(newSchema, idbtrans);\\n                globalSchema = db._dbSchema = newSchema;\\n                var diff = getSchemaDiff(oldSchema, newSchema);\\n                \\u002F\\u002F Add tables           \\n                diff.add.forEach(function (tuple) {\\n                    createTable(idbtrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\\n                });\\n                \\u002F\\u002F Change tables\\n                diff.change.forEach(function (change) {\\n                    if (change.recreate) {\\n                        throw new exceptions.Upgrade(\\\"Not yet support for changing primary key\\\");\\n                    }\\n                    else {\\n                        var store = idbtrans.objectStore(change.name);\\n                        \\u002F\\u002F Add indexes\\n                        change.add.forEach(function (idx) {\\n                            addIndex(store, idx);\\n                        });\\n                        \\u002F\\u002F Update indexes\\n                        change.change.forEach(function (idx) {\\n                            store.deleteIndex(idx.name);\\n                            addIndex(store, idx);\\n                        });\\n                        \\u002F\\u002F Delete indexes\\n                        change.del.forEach(function (idxName) {\\n                            store.deleteIndex(idxName);\\n                        });\\n                    }\\n                });\\n                if (version._cfg.contentUpgrade) {\\n                    anyContentUpgraderHasRun = true;\\n                    return Promise.follow(function () {\\n                        version._cfg.contentUpgrade(trans);\\n                    });\\n                }\\n            });\\n            queue.push(function (idbtrans) {\\n                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\\n                    var newSchema = version._cfg.dbschema;\\n                    \\u002F\\u002F Delete old tables\\n                    deleteRemovedTables(newSchema, idbtrans);\\n                }\\n            });\\n        });\\n        \\u002F\\u002F Now, create a queue execution engine\\n        function runQueue() {\\n            return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\\n                Promise.resolve();\\n        }\\n        return runQueue().then(function () {\\n            createMissingTables(globalSchema, idbtrans); \\u002F\\u002F At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)\\n        });\\n    }\\n    function getSchemaDiff(oldSchema, newSchema) {\\n        var diff = {\\n            del: [],\\n            add: [],\\n            change: [] \\u002F\\u002F Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}\\n        };\\n        for (var table in oldSchema) {\\n            if (!newSchema[table])\\n                diff.del.push(table);\\n        }\\n        for (table in newSchema) {\\n            var oldDef = oldSchema[table], newDef = newSchema[table];\\n            if (!oldDef) {\\n                diff.add.push([table, newDef]);\\n            }\\n            else {\\n                var change = {\\n                    name: table,\\n                    def: newDef,\\n                    recreate: false,\\n                    del: [],\\n                    add: [],\\n                    change: []\\n                };\\n                if (oldDef.primKey.src !== newDef.primKey.src) {\\n                    \\u002F\\u002F Primary key has changed. Remove and re-add table.\\n                    change.recreate = true;\\n                    diff.change.push(change);\\n                }\\n                else {\\n                    \\u002F\\u002F Same primary key. Just find out what differs:\\n                    var oldIndexes = oldDef.idxByName;\\n                    var newIndexes = newDef.idxByName;\\n                    for (var idxName in oldIndexes) {\\n                        if (!newIndexes[idxName])\\n                            change.del.push(idxName);\\n                    }\\n                    for (idxName in newIndexes) {\\n                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\\n                        if (!oldIdx)\\n                            change.add.push(newIdx);\\n                        else if (oldIdx.src !== newIdx.src)\\n                            change.change.push(newIdx);\\n                    }\\n                    if (change.del.length \\u003E 0 || change.add.length \\u003E 0 || change.change.length \\u003E 0) {\\n                        diff.change.push(change);\\n                    }\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n    function createTable(idbtrans, tableName, primKey, indexes) {\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"idbtrans\\\" type=\\\"IDBTransaction\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });\\n        indexes.forEach(function (idx) { addIndex(store, idx); });\\n        return store;\\n    }\\n    function createMissingTables(newSchema, idbtrans) {\\n        keys(newSchema).forEach(function (tableName) {\\n            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\\n                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\\n            }\\n        });\\n    }\\n    function deleteRemovedTables(newSchema, idbtrans) {\\n        for (var i = 0; i \\u003C idbtrans.db.objectStoreNames.length; ++i) {\\n            var storeName = idbtrans.db.objectStoreNames[i];\\n            if (newSchema[storeName] == null) {\\n                idbtrans.db.deleteObjectStore(storeName);\\n            }\\n        }\\n    }\\n    function addIndex(store, idx) {\\n        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\\n    }\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F      Dexie Protected API\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    this._allTables = allTables;\\n    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {\\n        return new Transaction(mode, storeNames, dbschema, parentTransaction);\\n    };\\n    \\u002F* Generate a temporary transaction when db operations are done outside a transaction scope.\\n    *\\u002F\\n    function tempTransaction(mode, storeNames, fn) {\\n        if (!openComplete && (!PSD.letThrough)) {\\n            if (!isBeingOpened) {\\n                if (!autoOpen)\\n                    return rejection(new exceptions.DatabaseClosed());\\n                db.open().catch(nop); \\u002F\\u002F Open in background. If if fails, it will be catched by the final promise anyway.\\n            }\\n            return dbReadyPromise.then(function () { return tempTransaction(mode, storeNames, fn); });\\n        }\\n        else {\\n            var trans = db._createTransaction(mode, storeNames, globalSchema);\\n            try {\\n                trans.create();\\n            }\\n            catch (ex) {\\n                return rejection(ex);\\n            }\\n            return trans._promise(mode, function (resolve, reject) {\\n                return newScope(function () {\\n                    PSD.trans = trans;\\n                    return fn(resolve, reject, trans);\\n                });\\n            }).then(function (result) {\\n                \\u002F\\u002F Instead of resolving value directly, wait with resolving it until transaction has completed.\\n                \\u002F\\u002F Otherwise the data would not be in the DB if requesting it in the then() operation.\\n                \\u002F\\u002F Specifically, to ensure that the following expression will work:\\n                \\u002F\\u002F\\n                \\u002F\\u002F   db.friends.put({name: \\\"Arne\\\"}).then(function () {\\n                \\u002F\\u002F       db.friends.where(\\\"name\\\").equals(\\\"Arne\\\").count(function(count) {\\n                \\u002F\\u002F           assert (count === 1);\\n                \\u002F\\u002F       });\\n                \\u002F\\u002F   });\\n                \\u002F\\u002F\\n                return trans._completion.then(function () { return result; });\\n            }); \\u002F*.catch(err =\\u003E { \\u002F\\u002F Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.\\n                trans._reject(err);\\n                return rejection(err);\\n            });*\\u002F\\n        }\\n    }\\n    this._whenReady = function (fn) {\\n        return openComplete || PSD.letThrough ? fn() : new Promise(function (resolve, reject) {\\n            if (!isBeingOpened) {\\n                if (!autoOpen) {\\n                    reject(new exceptions.DatabaseClosed());\\n                    return;\\n                }\\n                db.open().catch(nop); \\u002F\\u002F Open in background. If if fails, it will be catched by the final promise anyway.\\n            }\\n            dbReadyPromise.then(resolve, reject);\\n        }).then(fn);\\n    };\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F      Dexie API\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    this.verno = 0;\\n    this.open = function () {\\n        if (isBeingOpened || idbdb)\\n            return dbReadyPromise.then(function () { return dbOpenError ? rejection(dbOpenError) : db; });\\n        debug && (openCanceller._stackHolder = getErrorWithStack()); \\u002F\\u002F Let stacks point to when open() was called rather than where new Dexie() was called.\\n        isBeingOpened = true;\\n        dbOpenError = null;\\n        openComplete = false;\\n        \\u002F\\u002F Function pointers to call when the core opening process completes.\\n        var resolveDbReady = dbReadyResolve, \\n        \\u002F\\u002F upgradeTransaction to abort on failure.\\n        upgradeTransaction = null;\\n        return Promise.race([openCanceller, new Promise(function (resolve, reject) {\\n                \\u002F\\u002F Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:\\n                \\u002F\\u002F IE fails when deleting objectStore after reading from it.\\n                \\u002F\\u002F A future version of Dexie.js will stopover an intermediate version to workaround this.\\n                \\u002F\\u002F At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.\\n                \\u002F\\u002F If no API, throw!\\n                if (!indexedDB)\\n                    throw new exceptions.MissingAPI(\\\"indexedDB API not found. If using IE10+, make sure to run your code on a server URL \\\" +\\n                        \\\"(not locally). If using old Safari versions, make sure to include indexedDB polyfill.\\\");\\n                var req = autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\\n                if (!req)\\n                    throw new exceptions.MissingAPI(\\\"IndexedDB API not available\\\"); \\u002F\\u002F May happen in Safari private mode, see https:\\u002F\\u002Fgithub.com\\u002Fdfahlander\\u002FDexie.js\\u002Fissues\\u002F134\\n                req.onerror = eventRejectHandler(reject);\\n                req.onblocked = wrap(fireOnBlocked);\\n                req.onupgradeneeded = wrap(function (e) {\\n                    upgradeTransaction = req.transaction;\\n                    if (autoSchema && !db._allowEmptyDB) {\\n                        \\u002F\\u002F Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.\\n                        \\u002F\\u002F If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we\\n                        \\u002F\\u002F do not create a new database by accident here.\\n                        req.onerror = preventDefault; \\u002F\\u002F Prohibit onabort error from firing before we're done!\\n                        upgradeTransaction.abort(); \\u002F\\u002F Abort transaction (would hope that this would make DB disappear but it doesnt.)\\n                        \\u002F\\u002F Close database and delete it.\\n                        req.result.close();\\n                        var delreq = indexedDB.deleteDatabase(dbName); \\u002F\\u002F The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!\\n                        delreq.onsuccess = delreq.onerror = wrap(function () {\\n                            reject(new exceptions.NoSuchDatabase(\\\"Database \\\" + dbName + \\\" doesnt exist\\\"));\\n                        });\\n                    }\\n                    else {\\n                        upgradeTransaction.onerror = eventRejectHandler(reject);\\n                        var oldVer = e.oldVersion \\u003E Math.pow(2, 62) ? 0 : e.oldVersion; \\u002F\\u002F Safari 8 fix.\\n                        runUpgraders(oldVer \\u002F 10, upgradeTransaction, reject, req);\\n                    }\\n                }, reject);\\n                req.onsuccess = wrap(function () {\\n                    \\u002F\\u002F Core opening procedure complete. Now let's just record some stuff.\\n                    upgradeTransaction = null;\\n                    idbdb = req.result;\\n                    connections.push(db); \\u002F\\u002F Used for emulating versionchange event on IE\\u002FEdge\\u002FSafari.\\n                    if (autoSchema)\\n                        readGlobalSchema();\\n                    else if (idbdb.objectStoreNames.length \\u003E 0) {\\n                        try {\\n                            adjustToExistingIndexNames(globalSchema, idbdb.transaction(safariMultiStoreFix(idbdb.objectStoreNames), READONLY));\\n                        }\\n                        catch (e) {\\n                            \\u002F\\u002F Safari may bail out if \\u003E 1 store names. However, this shouldnt be a showstopper. Issue #120.\\n                        }\\n                    }\\n                    idbdb.onversionchange = wrap(function (ev) {\\n                        db._vcFired = true; \\u002F\\u002F detect implementations that not support versionchange (IE\\u002FEdge\\u002FSafari)\\n                        db.on(\\\"versionchange\\\").fire(ev);\\n                    });\\n                    if (!hasNativeGetDatabaseNames && dbName !== '__dbnames') {\\n                        dbNamesDB.dbnames.put({ name: dbName }).catch(nop);\\n                    }\\n                    resolve();\\n                }, reject);\\n            })]).then(function () {\\n            \\u002F\\u002F Before finally resolving the dbReadyPromise and this promise,\\n            \\u002F\\u002F call and await all on('ready') subscribers:\\n            \\u002F\\u002F Dexie.vip() makes subscribers able to use the database while being opened.\\n            \\u002F\\u002F This is a must since these subscribers take part of the opening procedure.\\n            onReadyBeingFired = [];\\n            return Promise.resolve(Dexie.vip(db.on.ready.fire)).then(function fireRemainders() {\\n                if (onReadyBeingFired.length \\u003E 0) {\\n                    \\u002F\\u002F In case additional subscribers to db.on('ready') were added during the time db.on.ready.fire was executed.\\n                    var remainders = onReadyBeingFired.reduce(promisableChain, nop);\\n                    onReadyBeingFired = [];\\n                    return Promise.resolve(Dexie.vip(remainders)).then(fireRemainders);\\n                }\\n            });\\n        }).finally(function () {\\n            onReadyBeingFired = null;\\n        }).then(function () {\\n            \\u002F\\u002F Resolve the db.open() with the db instance.\\n            isBeingOpened = false;\\n            return db;\\n        }).catch(function (err) {\\n            try {\\n                \\u002F\\u002F Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.\\n                upgradeTransaction && upgradeTransaction.abort();\\n            }\\n            catch (e) { }\\n            isBeingOpened = false; \\u002F\\u002F Set before calling db.close() so that it doesnt reject openCanceller again (leads to unhandled rejection event).\\n            db.close(); \\u002F\\u002F Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.\\n            \\u002F\\u002F A call to db.close() may have made on-ready subscribers fail. Use dbOpenError if set, since err could be a follow-up error on that.\\n            dbOpenError = err; \\u002F\\u002F Record the error. It will be used to reject further promises of db operations.\\n            return rejection(dbOpenError);\\n        }).finally(function () {\\n            openComplete = true;\\n            resolveDbReady(); \\u002F\\u002F dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.\\n        });\\n    };\\n    this.close = function () {\\n        var idx = connections.indexOf(db);\\n        if (idx \\u003E= 0)\\n            connections.splice(idx, 1);\\n        if (idbdb) {\\n            try {\\n                idbdb.close();\\n            }\\n            catch (e) { }\\n            idbdb = null;\\n        }\\n        autoOpen = false;\\n        dbOpenError = new exceptions.DatabaseClosed();\\n        if (isBeingOpened)\\n            cancelOpen(dbOpenError);\\n        \\u002F\\u002F Reset dbReadyPromise promise:\\n        dbReadyPromise = new Promise(function (resolve) {\\n            dbReadyResolve = resolve;\\n        });\\n        openCanceller = new Promise(function (_, reject) {\\n            cancelOpen = reject;\\n        });\\n    };\\n    this.delete = function () {\\n        var hasArguments = arguments.length \\u003E 0;\\n        return new Promise(function (resolve, reject) {\\n            if (hasArguments)\\n                throw new exceptions.InvalidArgument(\\\"Arguments not allowed in db.delete()\\\");\\n            if (isBeingOpened) {\\n                dbReadyPromise.then(doDelete);\\n            }\\n            else {\\n                doDelete();\\n            }\\n            function doDelete() {\\n                db.close();\\n                var req = indexedDB.deleteDatabase(dbName);\\n                req.onsuccess = wrap(function () {\\n                    if (!hasNativeGetDatabaseNames) {\\n                        dbNamesDB.dbnames.delete(dbName).catch(nop);\\n                    }\\n                    resolve();\\n                });\\n                req.onerror = eventRejectHandler(reject);\\n                req.onblocked = fireOnBlocked;\\n            }\\n        });\\n    };\\n    this.backendDB = function () {\\n        return idbdb;\\n    };\\n    this.isOpen = function () {\\n        return idbdb !== null;\\n    };\\n    this.hasBeenClosed = function () {\\n        return dbOpenError && (dbOpenError instanceof exceptions.DatabaseClosed);\\n    };\\n    this.hasFailed = function () {\\n        return dbOpenError !== null;\\n    };\\n    this.dynamicallyOpened = function () {\\n        return autoSchema;\\n    };\\n    \\u002F\\u002F\\n    \\u002F\\u002F Properties\\n    \\u002F\\u002F\\n    this.name = dbName;\\n    \\u002F\\u002F db.tables - an array of all Table instances.\\n    props(this, {\\n        tables: {\\n            get: function () {\\n                \\u002F\\u002F\\u002F \\u003Creturns type=\\\"Array\\\" elementType=\\\"Table\\\" \\u002F\\u003E\\n                return keys(allTables).map(function (name) { return allTables[name]; });\\n            }\\n        }\\n    });\\n    \\u002F\\u002F\\n    \\u002F\\u002F Events\\n    \\u002F\\u002F\\n    this.on = Events(this, \\\"populate\\\", \\\"blocked\\\", \\\"versionchange\\\", { ready: [promisableChain, nop] });\\n    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\\n        return function (subscriber, bSticky) {\\n            Dexie.vip(function () {\\n                if (openComplete) {\\n                    \\u002F\\u002F Database already open. Call subscriber asap.\\n                    if (!dbOpenError)\\n                        Promise.resolve().then(subscriber);\\n                    \\u002F\\u002F bSticky: Also subscribe to future open sucesses (after close \\u002F reopen) \\n                    if (bSticky)\\n                        subscribe(subscriber);\\n                }\\n                else if (onReadyBeingFired) {\\n                    \\u002F\\u002F db.on('ready') subscribers are currently being executed and have not yet resolved or rejected\\n                    onReadyBeingFired.push(subscriber);\\n                    if (bSticky)\\n                        subscribe(subscriber);\\n                }\\n                else {\\n                    \\u002F\\u002F Database not yet open. Subscribe to it.\\n                    subscribe(subscriber);\\n                    \\u002F\\u002F If bSticky is falsy, make sure to unsubscribe subscriber when fired once.\\n                    if (!bSticky)\\n                        subscribe(function unsubscribe() {\\n                            db.on.ready.unsubscribe(subscriber);\\n                            db.on.ready.unsubscribe(unsubscribe);\\n                        });\\n                }\\n            });\\n        };\\n    });\\n    this.transaction = function () {\\n        \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n        \\u002F\\u002F\\u002F\\n        \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"mode\\\" type=\\\"String\\\"\\u003E\\\"r\\\" for readonly, or \\\"rw\\\" for readwrite\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"tableInstances\\\"\\u003ETable instance, Array of Table instances, String or String Array of object stores to include in the transaction\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"scopeFunc\\\" type=\\\"Function\\\"\\u003EFunction to execute with transaction\\u003C\\u002Fparam\\u003E\\n        var args = extractTransactionArgs.apply(this, arguments);\\n        return this._transaction.apply(this, args);\\n    };\\n    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\\n        \\u002F\\u002F Let table arguments be all arguments between mode and last argument.\\n        var i = arguments.length;\\n        if (i \\u003C 2)\\n            throw new exceptions.InvalidArgument(\\\"Too few arguments\\\");\\n        \\u002F\\u002F Prevent optimzation killer (https:\\u002F\\u002Fgithub.com\\u002Fpetkaantonov\\u002Fbluebird\\u002Fwiki\\u002FOptimization-killers#32-leaking-arguments)\\n        \\u002F\\u002F and clone arguments except the first one into local var 'args'.\\n        var args = new Array(i - 1);\\n        while (--i)\\n            args[i - 1] = arguments[i];\\n        \\u002F\\u002F Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.\\n        scopeFunc = args.pop();\\n        var tables = flatten(args); \\u002F\\u002F Support using array as middle argument, or a mix of arrays and non-arrays.\\n        return [mode, tables, scopeFunc];\\n    }\\n    this._transaction = function (mode, tables, scopeFunc) {\\n        var parentTransaction = PSD.trans;\\n        \\u002F\\u002F Check if parent transactions is bound to this db instance, and if caller wants to reuse it\\n        if (!parentTransaction || parentTransaction.db !== db || mode.indexOf('!') !== -1)\\n            parentTransaction = null;\\n        var onlyIfCompatible = mode.indexOf('?') !== -1;\\n        mode = mode.replace('!', '').replace('?', ''); \\u002F\\u002F Ok. Will change arguments[0] as well but we wont touch arguments henceforth.\\n        try {\\n            \\u002F\\u002F\\n            \\u002F\\u002F Get storeNames from arguments. Either through given table instances, or through given table names.\\n            \\u002F\\u002F\\n            var storeNames = tables.map(function (table) {\\n                var storeName = table instanceof Table ? table.name : table;\\n                if (typeof storeName !== 'string')\\n                    throw new TypeError(\\\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\\\");\\n                return storeName;\\n            });\\n            \\u002F\\u002F\\n            \\u002F\\u002F Resolve mode. Allow shortcuts \\\"r\\\" and \\\"rw\\\".\\n            \\u002F\\u002F\\n            if (mode == \\\"r\\\" || mode == READONLY)\\n                mode = READONLY;\\n            else if (mode == \\\"rw\\\" || mode == READWRITE)\\n                mode = READWRITE;\\n            else\\n                throw new exceptions.InvalidArgument(\\\"Invalid transaction mode: \\\" + mode);\\n            if (parentTransaction) {\\n                \\u002F\\u002F Basic checks\\n                if (parentTransaction.mode === READONLY && mode === READWRITE) {\\n                    if (onlyIfCompatible) {\\n                        \\u002F\\u002F Spawn new transaction instead.\\n                        parentTransaction = null;\\n                    }\\n                    else\\n                        throw new exceptions.SubTransaction(\\\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\\\");\\n                }\\n                if (parentTransaction) {\\n                    storeNames.forEach(function (storeName) {\\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\\n                            if (onlyIfCompatible) {\\n                                \\u002F\\u002F Spawn new transaction instead.\\n                                parentTransaction = null;\\n                            }\\n                            else\\n                                throw new exceptions.SubTransaction(\\\"Table \\\" + storeName +\\n                                    \\\" not included in parent transaction.\\\");\\n                        }\\n                    });\\n                }\\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\\n                    \\u002F\\u002F '?' mode should not keep using an inactive transaction.\\n                    parentTransaction = null;\\n                }\\n            }\\n        }\\n        catch (e) {\\n            return parentTransaction ?\\n                parentTransaction._promise(null, function (_, reject) { reject(e); }) :\\n                rejection(e);\\n        }\\n        \\u002F\\u002F If this is a sub-transaction, lock the parent and then launch the sub-transaction.\\n        return (parentTransaction ?\\n            parentTransaction._promise(mode, enterTransactionScope, \\\"lock\\\") :\\n            PSD.trans ?\\n                \\u002F\\u002F no parent transaction despite PSD.trans exists. Make sure also\\n                \\u002F\\u002F that the zone we create is not a sub-zone of current, because\\n                \\u002F\\u002F Promise.follow() should not wait for it if so.\\n                usePSD(PSD.transless, function () { return db._whenReady(enterTransactionScope); }) :\\n                db._whenReady(enterTransactionScope));\\n        function enterTransactionScope() {\\n            return Promise.resolve().then(function () {\\n                \\u002F\\u002F Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().\\n                var transless = PSD.transless || PSD;\\n                \\u002F\\u002F Our transaction.\\n                \\u002F\\u002Freturn new Promise((resolve, reject) =\\u003E {\\n                var trans = db._createTransaction(mode, storeNames, globalSchema, parentTransaction);\\n                \\u002F\\u002F Let the transaction instance be part of a Promise-specific data (PSD) value.\\n                var zoneProps = {\\n                    trans: trans,\\n                    transless: transless\\n                };\\n                if (parentTransaction) {\\n                    \\u002F\\u002F Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)\\n                    trans.idbtrans = parentTransaction.idbtrans;\\n                }\\n                else {\\n                    trans.create(); \\u002F\\u002F Create the backend transaction so that complete() or error() will trigger even if no operation is made upon it.\\n                }\\n                \\u002F\\u002F Support for native async await.\\n                if (scopeFunc.constructor === AsyncFunction) {\\n                    incrementExpectedAwaits();\\n                }\\n                var returnValue;\\n                var promiseFollowed = Promise.follow(function () {\\n                    \\u002F\\u002F Finally, call the scope function with our table and transaction arguments.\\n                    returnValue = scopeFunc.call(trans, trans);\\n                    if (returnValue) {\\n                        if (returnValue.constructor === NativePromise) {\\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\\n                            returnValue.then(decrementor, decrementor);\\n                        }\\n                        else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\\n                            \\u002F\\u002F scopeFunc returned an iterator with throw-support. Handle yield as await.\\n                            returnValue = awaitIterator(returnValue);\\n                        }\\n                    }\\n                }, zoneProps);\\n                return (returnValue && typeof returnValue.then === 'function' ?\\n                    \\u002F\\u002F Promise returned. User uses promise-style transactions.\\n                    Promise.resolve(returnValue).then(function (x) { return trans.active ?\\n                        x \\u002F\\u002F Transaction still active. Continue.\\n                        : rejection(new exceptions.PrematureCommit(\\\"Transaction committed too early. See http:\\u002F\\u002Fbit.ly\\u002F2kdckMn\\\")); })\\n                    \\u002F\\u002F No promise returned. Wait for all outstanding promises before continuing. \\n                    : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\\n                    \\u002F\\u002F sub transactions don't react to idbtrans.oncomplete. We must trigger a completion:\\n                    if (parentTransaction)\\n                        trans._resolve();\\n                    \\u002F\\u002F wait for trans._completion\\n                    \\u002F\\u002F (if root transaction, this means 'complete' event. If sub-transaction, we've just fired it ourselves)\\n                    return trans._completion.then(function () { return x; });\\n                }).catch(function (e) {\\n                    trans._reject(e); \\u002F\\u002F Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!\\n                    return rejection(e);\\n                });\\n            });\\n        }\\n    };\\n    this.table = function (tableName) {\\n        \\u002F\\u002F\\u002F \\u003Creturns type=\\\"Table\\\"\\u003E\\u003C\\u002Freturns\\u003E\\n        if (!hasOwn(allTables, tableName)) {\\n            throw new exceptions.InvalidTable(\\\"Table \\\" + tableName + \\\" does not exist\\\");\\n        }\\n        return allTables[tableName];\\n    };\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F Table Class\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    function Table(name, tableSchema, optionalTrans) {\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"name\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        this.name = name;\\n        this.schema = tableSchema;\\n        this._tx = optionalTrans;\\n        this.hook = allTables[name] ? allTables[name].hook : Events(null, {\\n            \\\"creating\\\": [hookCreatingChain, nop],\\n            \\\"reading\\\": [pureFunctionChain, mirror],\\n            \\\"updating\\\": [hookUpdatingChain, nop],\\n            \\\"deleting\\\": [hookDeletingChain, nop]\\n        });\\n    }\\n    function BulkErrorHandlerCatchAll(errorList, done, supportHooks) {\\n        return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(function (e) {\\n            errorList.push(e);\\n            done && done();\\n        });\\n    }\\n    function bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook) {\\n        \\u002F\\u002F If hasDeleteHook, keysOrTuples must be an array of tuples: [[key1, value2],[key2,value2],...],\\n        \\u002F\\u002F else keysOrTuples must be just an array of keys: [key1, key2, ...].\\n        return new Promise(function (resolve, reject) {\\n            var len = keysOrTuples.length, lastItem = len - 1;\\n            if (len === 0)\\n                return resolve();\\n            if (!hasDeleteHook) {\\n                for (var i = 0; i \\u003C len; ++i) {\\n                    var req = idbstore.delete(keysOrTuples[i]);\\n                    req.onerror = eventRejectHandler(reject);\\n                    if (i === lastItem)\\n                        req.onsuccess = wrap(function () { return resolve(); });\\n                }\\n            }\\n            else {\\n                var hookCtx, errorHandler = hookedEventRejectHandler(reject), successHandler = hookedEventSuccessHandler(null);\\n                tryCatch(function () {\\n                    for (var i = 0; i \\u003C len; ++i) {\\n                        hookCtx = { onsuccess: null, onerror: null };\\n                        var tuple = keysOrTuples[i];\\n                        deletingHook.call(hookCtx, tuple[0], tuple[1], trans);\\n                        var req = idbstore.delete(tuple[0]);\\n                        req._hookCtx = hookCtx;\\n                        req.onerror = errorHandler;\\n                        if (i === lastItem)\\n                            req.onsuccess = hookedEventSuccessHandler(resolve);\\n                        else\\n                            req.onsuccess = successHandler;\\n                    }\\n                }, function (err) {\\n                    hookCtx.onerror && hookCtx.onerror(err);\\n                    throw err;\\n                });\\n            }\\n        });\\n    }\\n    props(Table.prototype, {\\n        \\u002F\\u002F\\n        \\u002F\\u002F Table Protected Methods\\n        \\u002F\\u002F\\n        _trans: function getTransaction(mode, fn, writeLocked) {\\n            var trans = this._tx || PSD.trans;\\n            return trans && trans.db === db ?\\n                trans === PSD.trans ?\\n                    trans._promise(mode, fn, writeLocked) :\\n                    newScope(function () { return trans._promise(mode, fn, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\\n                tempTransaction(mode, [this.name], fn);\\n        },\\n        _idbstore: function getIDBObjectStore(mode, fn, writeLocked) {\\n            var tableName = this.name;\\n            function supplyIdbStore(resolve, reject, trans) {\\n                if (trans.storeNames.indexOf(tableName) === -1)\\n                    throw new exceptions.NotFound(\\\"Table\\\" + tableName + \\\" not part of transaction\\\");\\n                return fn(resolve, reject, trans.idbtrans.objectStore(tableName), trans);\\n            }\\n            return this._trans(mode, supplyIdbStore, writeLocked);\\n        },\\n        \\u002F\\u002F\\n        \\u002F\\u002F Table Public Methods\\n        \\u002F\\u002F\\n        get: function (keyOrCrit, cb) {\\n            if (keyOrCrit && keyOrCrit.constructor === Object)\\n                return this.where(keyOrCrit).first(cb);\\n            var self = this;\\n            return this._idbstore(READONLY, function (resolve, reject, idbstore) {\\n                var req = idbstore.get(keyOrCrit);\\n                req.onerror = eventRejectHandler(reject);\\n                req.onsuccess = wrap(function () {\\n                    resolve(self.hook.reading.fire(req.result));\\n                }, reject);\\n            }).then(cb);\\n        },\\n        where: function (indexOrCrit) {\\n            if (typeof indexOrCrit === 'string')\\n                return new WhereClause(this, indexOrCrit);\\n            if (isArray(indexOrCrit))\\n                return new WhereClause(this, \\\"[\\\" + indexOrCrit.join('+') + \\\"]\\\");\\n            \\u002F\\u002F indexOrCrit is an object map of {[keyPath]:value} \\n            var keyPaths = keys(indexOrCrit);\\n            if (keyPaths.length === 1)\\n                \\u002F\\u002F Only one critera. This was the easy case:\\n                return this\\n                    .where(keyPaths[0])\\n                    .equals(indexOrCrit[keyPaths[0]]);\\n            \\u002F\\u002F Multiple criterias.\\n            \\u002F\\u002F Let's try finding a compound index that matches all keyPaths in\\n            \\u002F\\u002F arbritary order:\\n            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\\n                return ix.compound &&\\n                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) \\u003E= 0; }) &&\\n                    ix.keyPath.every(function (keyPath) { return keyPaths.indexOf(keyPath) \\u003E= 0; });\\n            })[0];\\n            if (compoundIndex && maxKey !== maxString)\\n                \\u002F\\u002F Cool! We found such compound index\\n                \\u002F\\u002F and this browser supports compound indexes (maxKey !== maxString)!\\n                return this\\n                    .where(compoundIndex.name)\\n                    .equals(compoundIndex.keyPath.map(function (kp) { return indexOrCrit[kp]; }));\\n            if (!compoundIndex)\\n                console.warn(\\\"The query \\\" + JSON.stringify(indexOrCrit) + \\\" on \\\" + this.name + \\\" would benefit of a \\\" +\\n                    (\\\"compound index [\\\" + keyPaths.join('+') + \\\"]\\\"));\\n            \\u002F\\u002F Ok, now let's fallback to finding at least one matching index\\n            \\u002F\\u002F and filter the rest.\\n            var idxByName = this.schema.idxByName;\\n            var simpleIndex = keyPaths.reduce(function (r, keyPath) { return [\\n                r[0] || idxByName[keyPath],\\n                r[0] || !idxByName[keyPath] ?\\n                    combine(r[1], function (x) { return '' + getByKeyPath(x, keyPath) ==\\n                        '' + indexOrCrit[keyPath]; })\\n                    : r[1]\\n            ]; }, [null, null]);\\n            var idx = simpleIndex[0];\\n            return idx ?\\n                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\\n                    .filter(simpleIndex[1]) :\\n                compoundIndex ?\\n                    this.filter(simpleIndex[1]) : \\u002F\\u002F Has compound but browser bad. Allow filter.\\n                    this.where(keyPaths).equals(''); \\u002F\\u002F No index at all. Fail lazily.\\n        },\\n        count: function (cb) {\\n            return this.toCollection().count(cb);\\n        },\\n        offset: function (offset) {\\n            return this.toCollection().offset(offset);\\n        },\\n        limit: function (numRows) {\\n            return this.toCollection().limit(numRows);\\n        },\\n        reverse: function () {\\n            return this.toCollection().reverse();\\n        },\\n        filter: function (filterFunction) {\\n            return this.toCollection().and(filterFunction);\\n        },\\n        each: function (fn) {\\n            return this.toCollection().each(fn);\\n        },\\n        toArray: function (cb) {\\n            return this.toCollection().toArray(cb);\\n        },\\n        orderBy: function (index) {\\n            return new Collection(new WhereClause(this, isArray(index) ?\\n                \\\"[\\\" + index.join('+') + \\\"]\\\" :\\n                index));\\n        },\\n        toCollection: function () {\\n            return new Collection(new WhereClause(this));\\n        },\\n        mapToClass: function (constructor, structure) {\\n            \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n            \\u002F\\u002F\\u002F     Map table to a javascript constructor function. Objects returned from the database will be instances of this class, making\\n            \\u002F\\u002F\\u002F     it possible to the instanceOf operator as well as extending the class using constructor.prototype.method = function(){...}.\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"constructor\\\"\\u003EConstructor function representing the class.\\u003C\\u002Fparam\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"structure\\\" optional=\\\"true\\\"\\u003EHelps IDE code completion by knowing the members that objects contain and not just the indexes. Also\\n            \\u002F\\u002F\\u002F know what type each member has. Example: {name: String, emailAddresses: [String], password}\\u003C\\u002Fparam\\u003E\\n            this.schema.mappedClass = constructor;\\n            var instanceTemplate = Object.create(constructor.prototype);\\n            if (structure) {\\n                \\u002F\\u002F structure and instanceTemplate is for IDE code competion only while constructor.prototype is for actual inheritance.\\n                applyStructure(instanceTemplate, structure);\\n            }\\n            this.schema.instanceTemplate = instanceTemplate;\\n            \\u002F\\u002F Now, subscribe to the when(\\\"reading\\\") event to make all objects that come out from this table inherit from given class\\n            \\u002F\\u002F no matter which method to use for reading (Table.get() or Table.where(...)... )\\n            var readHook = function (obj) {\\n                if (!obj)\\n                    return obj; \\u002F\\u002F No valid object. (Value is null). Return as is.\\n                \\u002F\\u002F Create a new object that derives from constructor:\\n                var res = Object.create(constructor.prototype);\\n                \\u002F\\u002F Clone members:\\n                for (var m in obj)\\n                    if (hasOwn(obj, m))\\n                        try {\\n                            res[m] = obj[m];\\n                        }\\n                        catch (_) { }\\n                return res;\\n            };\\n            if (this.schema.readHook) {\\n                this.hook.reading.unsubscribe(this.schema.readHook);\\n            }\\n            this.schema.readHook = readHook;\\n            this.hook(\\\"reading\\\", readHook);\\n            return constructor;\\n        },\\n        defineClass: function (structure) {\\n            \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n            \\u002F\\u002F\\u002F     Define all members of the class that represents the table. This will help code completion of when objects are read from the database\\n            \\u002F\\u002F\\u002F     as well as making it possible to extend the prototype of the returned constructor function.\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"structure\\\"\\u003EHelps IDE code completion by knowing the members that objects contain and not just the indexes. Also\\n            \\u002F\\u002F\\u002F know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}\\u003C\\u002Fparam\\u003E\\n            return this.mapToClass(Dexie.defineClass(structure), structure);\\n        },\\n        bulkDelete: function (keys$$1) {\\n            if (this.hook.deleting.fire === nop) {\\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\\n                    resolve(bulkDelete(idbstore, trans, keys$$1, false, nop));\\n                });\\n            }\\n            else {\\n                return this\\n                    .where(':id')\\n                    .anyOf(keys$$1)\\n                    .delete()\\n                    .then(function () { }); \\u002F\\u002F Resolve with undefined.\\n            }\\n        },\\n        bulkPut: function (objects, keys$$1) {\\n            var _this = this;\\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\\n                if (!idbstore.keyPath && !_this.schema.primKey.auto && !keys$$1)\\n                    throw new exceptions.InvalidArgument(\\\"bulkPut() with non-inbound keys requires keys array in second argument\\\");\\n                if (idbstore.keyPath && keys$$1)\\n                    throw new exceptions.InvalidArgument(\\\"bulkPut(): keys argument invalid on tables with inbound keys\\\");\\n                if (keys$$1 && keys$$1.length !== objects.length)\\n                    throw new exceptions.InvalidArgument(\\\"Arguments objects and keys must have the same length\\\");\\n                if (objects.length === 0)\\n                    return resolve(); \\u002F\\u002F Caller provided empty list.\\n                var done = function (result) {\\n                    if (errorList.length === 0)\\n                        resolve(result);\\n                    else\\n                        reject(new BulkError(_this.name + \\\".bulkPut(): \\\" + errorList.length + \\\" of \\\" + numObjs + \\\" operations failed\\\", errorList));\\n                };\\n                var req, errorList = [], errorHandler, numObjs = objects.length, table = _this;\\n                if (_this.hook.creating.fire === nop && _this.hook.updating.fire === nop) {\\n                    \\u002F\\u002F\\n                    \\u002F\\u002F Standard Bulk (no 'creating' or 'updating' hooks to care about)\\n                    \\u002F\\u002F\\n                    errorHandler = BulkErrorHandlerCatchAll(errorList);\\n                    for (var i = 0, l = objects.length; i \\u003C l; ++i) {\\n                        req = keys$$1 ? idbstore.put(objects[i], keys$$1[i]) : idbstore.put(objects[i]);\\n                        req.onerror = errorHandler;\\n                    }\\n                    \\u002F\\u002F Only need to catch success or error on the last operation\\n                    \\u002F\\u002F according to the IDB spec.\\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);\\n                    req.onsuccess = eventSuccessHandler(done);\\n                }\\n                else {\\n                    var effectiveKeys = keys$$1 || idbstore.keyPath && objects.map(function (o) { return getByKeyPath(o, idbstore.keyPath); });\\n                    \\u002F\\u002F Generate map of {[key]: object}\\n                    var objectLookup = effectiveKeys && arrayToObject(effectiveKeys, function (key, i) { return key != null && [key, objects[i]]; });\\n                    var promise = !effectiveKeys ?\\n                        \\u002F\\u002F Auto-incremented key-less objects only without any keys argument.\\n                        table.bulkAdd(objects) :\\n                        \\u002F\\u002F Keys provided. Either as inbound in provided objects, or as a keys argument.\\n                        \\u002F\\u002F Begin with updating those that exists in DB:\\n                        table.where(':id').anyOf(effectiveKeys.filter(function (key) { return key != null; })).modify(function () {\\n                            this.value = objectLookup[this.primKey];\\n                            objectLookup[this.primKey] = null; \\u002F\\u002F Mark as \\\"don't add this\\\"\\n                        }).catch(ModifyError, function (e) {\\n                            errorList = e.failures; \\u002F\\u002F No need to concat here. These are the first errors added.\\n                        }).then(function () {\\n                            \\u002F\\u002F Now, let's examine which items didnt exist so we can add them:\\n                            var objsToAdd = [], keysToAdd = keys$$1 && [];\\n                            \\u002F\\u002F Iterate backwards. Why? Because if same key was used twice, just add the last one.\\n                            for (var i = effectiveKeys.length - 1; i \\u003E= 0; --i) {\\n                                var key = effectiveKeys[i];\\n                                if (key == null || objectLookup[key]) {\\n                                    objsToAdd.push(objects[i]);\\n                                    keys$$1 && keysToAdd.push(key);\\n                                    if (key != null)\\n                                        objectLookup[key] = null; \\u002F\\u002F Mark as \\\"dont add again\\\"\\n                                }\\n                            }\\n                            \\u002F\\u002F The items are in reverse order so reverse them before adding.\\n                            \\u002F\\u002F Could be important in order to get auto-incremented keys the way the caller\\n                            \\u002F\\u002F would expect. Could have used unshift instead of push()\\u002Freverse(),\\n                            \\u002F\\u002F but: http:\\u002F\\u002Fjsperf.com\\u002Funshift-vs-reverse\\n                            objsToAdd.reverse();\\n                            keys$$1 && keysToAdd.reverse();\\n                            return table.bulkAdd(objsToAdd, keysToAdd);\\n                        }).then(function (lastAddedKey) {\\n                            \\u002F\\u002F Resolve with key of the last object in given arguments to bulkPut():\\n                            var lastEffectiveKey = effectiveKeys[effectiveKeys.length - 1]; \\u002F\\u002F Key was provided.\\n                            return lastEffectiveKey != null ? lastEffectiveKey : lastAddedKey;\\n                        });\\n                    promise.then(done).catch(BulkError, function (e) {\\n                        \\u002F\\u002F Concat failure from ModifyError and reject using our 'done' method.\\n                        errorList = errorList.concat(e.failures);\\n                        done();\\n                    }).catch(reject);\\n                }\\n            }, \\\"locked\\\"); \\u002F\\u002F If called from transaction scope, lock transaction til all steps are done.\\n        },\\n        bulkAdd: function (objects, keys$$1) {\\n            var self = this, creatingHook = this.hook.creating.fire;\\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\\n                if (!idbstore.keyPath && !self.schema.primKey.auto && !keys$$1)\\n                    throw new exceptions.InvalidArgument(\\\"bulkAdd() with non-inbound keys requires keys array in second argument\\\");\\n                if (idbstore.keyPath && keys$$1)\\n                    throw new exceptions.InvalidArgument(\\\"bulkAdd(): keys argument invalid on tables with inbound keys\\\");\\n                if (keys$$1 && keys$$1.length !== objects.length)\\n                    throw new exceptions.InvalidArgument(\\\"Arguments objects and keys must have the same length\\\");\\n                if (objects.length === 0)\\n                    return resolve(); \\u002F\\u002F Caller provided empty list.\\n                function done(result) {\\n                    if (errorList.length === 0)\\n                        resolve(result);\\n                    else\\n                        reject(new BulkError(self.name + \\\".bulkAdd(): \\\" + errorList.length + \\\" of \\\" + numObjs + \\\" operations failed\\\", errorList));\\n                }\\n                var req, errorList = [], errorHandler, successHandler, numObjs = objects.length;\\n                if (creatingHook !== nop) {\\n                    \\u002F\\u002F\\n                    \\u002F\\u002F There are subscribers to hook('creating')\\n                    \\u002F\\u002F Must behave as documented.\\n                    \\u002F\\u002F\\n                    var keyPath = idbstore.keyPath, hookCtx;\\n                    errorHandler = BulkErrorHandlerCatchAll(errorList, null, true);\\n                    successHandler = hookedEventSuccessHandler(null);\\n                    tryCatch(function () {\\n                        for (var i = 0, l = objects.length; i \\u003C l; ++i) {\\n                            hookCtx = { onerror: null, onsuccess: null };\\n                            var key = keys$$1 && keys$$1[i];\\n                            var obj = objects[i], effectiveKey = keys$$1 ? key : keyPath ? getByKeyPath(obj, keyPath) : undefined, keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans);\\n                            if (effectiveKey == null && keyToUse != null) {\\n                                if (keyPath) {\\n                                    obj = deepClone(obj);\\n                                    setByKeyPath(obj, keyPath, keyToUse);\\n                                }\\n                                else {\\n                                    key = keyToUse;\\n                                }\\n                            }\\n                            req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);\\n                            req._hookCtx = hookCtx;\\n                            if (i \\u003C l - 1) {\\n                                req.onerror = errorHandler;\\n                                if (hookCtx.onsuccess)\\n                                    req.onsuccess = successHandler;\\n                            }\\n                        }\\n                    }, function (err) {\\n                        hookCtx.onerror && hookCtx.onerror(err);\\n                        throw err;\\n                    });\\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done, true);\\n                    req.onsuccess = hookedEventSuccessHandler(done);\\n                }\\n                else {\\n                    \\u002F\\u002F\\n                    \\u002F\\u002F Standard Bulk (no 'creating' hook to care about)\\n                    \\u002F\\u002F\\n                    errorHandler = BulkErrorHandlerCatchAll(errorList);\\n                    for (var i = 0, l = objects.length; i \\u003C l; ++i) {\\n                        req = keys$$1 ? idbstore.add(objects[i], keys$$1[i]) : idbstore.add(objects[i]);\\n                        req.onerror = errorHandler;\\n                    }\\n                    \\u002F\\u002F Only need to catch success or error on the last operation\\n                    \\u002F\\u002F according to the IDB spec.\\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);\\n                    req.onsuccess = eventSuccessHandler(done);\\n                }\\n            });\\n        },\\n        add: function (obj, key) {\\n            \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n            \\u002F\\u002F\\u002F   Add an object to the database. In case an object with same primary key already exists, the object will not be added.\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"obj\\\" type=\\\"Object\\\"\\u003EA javascript object to insert\\u003C\\u002Fparam\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"key\\\" optional=\\\"true\\\"\\u003EPrimary key\\u003C\\u002Fparam\\u003E\\n            var creatingHook = this.hook.creating.fire;\\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\\n                var hookCtx = { onsuccess: null, onerror: null };\\n                if (creatingHook !== nop) {\\n                    var effectiveKey = (key != null) ? key : (idbstore.keyPath ? getByKeyPath(obj, idbstore.keyPath) : undefined);\\n                    var keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans); \\u002F\\u002F Allow subscribers to when(\\\"creating\\\") to generate the key.\\n                    if (effectiveKey == null && keyToUse != null) {\\n                        if (idbstore.keyPath)\\n                            setByKeyPath(obj, idbstore.keyPath, keyToUse);\\n                        else\\n                            key = keyToUse;\\n                    }\\n                }\\n                try {\\n                    var req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);\\n                    req._hookCtx = hookCtx;\\n                    req.onerror = hookedEventRejectHandler(reject);\\n                    req.onsuccess = hookedEventSuccessHandler(function (result) {\\n                        \\u002F\\u002F TODO: Remove these two lines in next major release (2.0?)\\n                        \\u002F\\u002F It's no good practice to have side effects on provided parameters\\n                        var keyPath = idbstore.keyPath;\\n                        if (keyPath)\\n                            setByKeyPath(obj, keyPath, result);\\n                        resolve(result);\\n                    });\\n                }\\n                catch (e) {\\n                    if (hookCtx.onerror)\\n                        hookCtx.onerror(e);\\n                    throw e;\\n                }\\n            });\\n        },\\n        put: function (obj, key) {\\n            var _this = this;\\n            \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n            \\u002F\\u002F\\u002F   Add an object to the database but in case an object with same primary key alread exists, the existing one will get updated.\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"obj\\\" type=\\\"Object\\\"\\u003EA javascript object to insert or update\\u003C\\u002Fparam\\u003E\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"key\\\" optional=\\\"true\\\"\\u003EPrimary key\\u003C\\u002Fparam\\u003E\\n            var creatingHook = this.hook.creating.fire, updatingHook = this.hook.updating.fire;\\n            if (creatingHook !== nop || updatingHook !== nop) {\\n                \\u002F\\u002F\\n                \\u002F\\u002F People listens to when(\\\"creating\\\") or when(\\\"updating\\\") events!\\n                \\u002F\\u002F We must know whether the put operation results in an CREATE or UPDATE.\\n                \\u002F\\u002F\\n                var keyPath = this.schema.primKey.keyPath;\\n                var effectiveKey = (key !== undefined) ? key : (keyPath && getByKeyPath(obj, keyPath));\\n                if (effectiveKey == null)\\n                    return this.add(obj);\\n                \\u002F\\u002F Since key is optional, make sure we get it from obj if not provided\\n                \\u002F\\u002F Primary key exist. Lock transaction and try modifying existing. If nothing modified, call add().\\n                \\u002F\\u002F clone obj before this async call. If caller modifies obj the line after put(), the IDB spec requires that it should not affect operation.\\n                obj = deepClone(obj);\\n                return this._trans(READWRITE, function () {\\n                    return _this.where(\\\":id\\\").equals(effectiveKey).modify(function () {\\n                        \\u002F\\u002F Replace extisting value with our object\\n                        \\u002F\\u002F CRUD event firing handled in Collection.modify()\\n                        this.value = obj;\\n                    }).then(function (count) { return count === 0 ? _this.add(obj, key) : effectiveKey; });\\n                }, \\\"locked\\\"); \\u002F\\u002F Lock needed because operation is splitted into modify() and add().\\n            }\\n            else {\\n                \\u002F\\u002F Use the standard IDB put() method.\\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\\n                    var req = key !== undefined ? idbstore.put(obj, key) : idbstore.put(obj);\\n                    req.onerror = eventRejectHandler(reject);\\n                    req.onsuccess = wrap(function (ev) {\\n                        var keyPath = idbstore.keyPath;\\n                        if (keyPath)\\n                            setByKeyPath(obj, keyPath, ev.target.result);\\n                        resolve(req.result);\\n                    });\\n                });\\n            }\\n        },\\n        'delete': function (key) {\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"key\\\"\\u003EPrimary key of the object to delete\\u003C\\u002Fparam\\u003E\\n            if (this.hook.deleting.subscribers.length) {\\n                \\u002F\\u002F People listens to when(\\\"deleting\\\") event. Must implement delete using Collection.delete() that will\\n                \\u002F\\u002F call the CRUD event. Only Collection.delete() will know whether an object was actually deleted.\\n                return this.where(\\\":id\\\").equals(key).delete();\\n            }\\n            else {\\n                \\u002F\\u002F No one listens. Use standard IDB delete() method.\\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\\n                    var req = idbstore.delete(key);\\n                    req.onerror = eventRejectHandler(reject);\\n                    req.onsuccess = wrap(function () {\\n                        resolve(req.result);\\n                    });\\n                });\\n            }\\n        },\\n        clear: function () {\\n            if (this.hook.deleting.subscribers.length) {\\n                \\u002F\\u002F People listens to when(\\\"deleting\\\") event. Must implement delete using Collection.delete() that will\\n                \\u002F\\u002F call the CRUD event. Only Collection.delete() will knows which objects that are actually deleted.\\n                return this.toCollection().delete();\\n            }\\n            else {\\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\\n                    var req = idbstore.clear();\\n                    req.onerror = eventRejectHandler(reject);\\n                    req.onsuccess = wrap(function () {\\n                        resolve(req.result);\\n                    });\\n                });\\n            }\\n        },\\n        update: function (keyOrObject, modifications) {\\n            if (typeof modifications !== 'object' || isArray(modifications))\\n                throw new exceptions.InvalidArgument(\\\"Modifications must be an object.\\\");\\n            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\\n                \\u002F\\u002F object to modify. Also modify given object with the modifications:\\n                keys(modifications).forEach(function (keyPath) {\\n                    setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\\n                });\\n                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\\n                if (key === undefined)\\n                    return rejection(new exceptions.InvalidArgument(\\\"Given object does not contain its primary key\\\"));\\n                return this.where(\\\":id\\\").equals(key).modify(modifications);\\n            }\\n            else {\\n                \\u002F\\u002F key to modify\\n                return this.where(\\\":id\\\").equals(keyOrObject).modify(modifications);\\n            }\\n        }\\n    });\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F Transaction Class\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    function Transaction(mode, storeNames, dbschema, parent) {\\n        var _this = this;\\n        \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n        \\u002F\\u002F\\u002F    Transaction class. Represents a database transaction. All operations on db goes through a Transaction.\\n        \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"mode\\\" type=\\\"String\\\"\\u003EAny of \\\"readwrite\\\" or \\\"readonly\\\"\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"storeNames\\\" type=\\\"Array\\\"\\u003EArray of table names to operate on\\u003C\\u002Fparam\\u003E\\n        this.db = db;\\n        this.mode = mode;\\n        this.storeNames = storeNames;\\n        this.idbtrans = null;\\n        this.on = Events(this, \\\"complete\\\", \\\"error\\\", \\\"abort\\\");\\n        this.parent = parent || null;\\n        this.active = true;\\n        this._reculock = 0;\\n        this._blockedFuncs = [];\\n        this._resolve = null;\\n        this._reject = null;\\n        this._waitingFor = null;\\n        this._waitingQueue = null;\\n        this._spinCount = 0; \\u002F\\u002F Just for debugging waitFor()\\n        this._completion = new Promise(function (resolve, reject) {\\n            _this._resolve = resolve;\\n            _this._reject = reject;\\n        });\\n        this._completion.then(function () {\\n            _this.active = false;\\n            _this.on.complete.fire();\\n        }, function (e) {\\n            var wasActive = _this.active;\\n            _this.active = false;\\n            _this.on.error.fire(e);\\n            _this.parent ?\\n                _this.parent._reject(e) :\\n                wasActive && _this.idbtrans && _this.idbtrans.abort();\\n            return rejection(e); \\u002F\\u002F Indicate we actually DO NOT catch this error.\\n        });\\n    }\\n    props(Transaction.prototype, {\\n        \\u002F\\u002F\\n        \\u002F\\u002F Transaction Protected Methods (not required by API users, but needed internally and eventually by dexie extensions)\\n        \\u002F\\u002F\\n        _lock: function () {\\n            assert(!PSD.global); \\u002F\\u002F Locking and unlocking reuires to be within a PSD scope.\\n            \\u002F\\u002F Temporary set all requests into a pending queue if they are called before database is ready.\\n            ++this._reculock; \\u002F\\u002F Recursive read\\u002Fwrite lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)\\n            if (this._reculock === 1 && !PSD.global)\\n                PSD.lockOwnerFor = this;\\n            return this;\\n        },\\n        _unlock: function () {\\n            assert(!PSD.global); \\u002F\\u002F Locking and unlocking reuires to be within a PSD scope.\\n            if (--this._reculock === 0) {\\n                if (!PSD.global)\\n                    PSD.lockOwnerFor = null;\\n                while (this._blockedFuncs.length \\u003E 0 && !this._locked()) {\\n                    var fnAndPSD = this._blockedFuncs.shift();\\n                    try {\\n                        usePSD(fnAndPSD[1], fnAndPSD[0]);\\n                    }\\n                    catch (e) { }\\n                }\\n            }\\n            return this;\\n        },\\n        _locked: function () {\\n            \\u002F\\u002F Checks if any write-lock is applied on this transaction.\\n            \\u002F\\u002F To simplify the Dexie API for extension implementations, we support recursive locks.\\n            \\u002F\\u002F This is accomplished by using \\\"Promise Specific Data\\\" (PSD).\\n            \\u002F\\u002F PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).\\n            \\u002F\\u002F PSD is local to code executing on top of the call stacks of any of any code executed by Promise():\\n            \\u002F\\u002F         * callback given to the Promise() constructor  (function (resolve, reject){...})\\n            \\u002F\\u002F         * callbacks given to then()\\u002Fcatch()\\u002Ffinally() methods (function (value){...})\\n            \\u002F\\u002F If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.\\n            \\u002F\\u002F Derivation is done so that the inner PSD __proto__ points to the outer PSD.\\n            \\u002F\\u002F PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.\\n            return this._reculock && PSD.lockOwnerFor !== this;\\n        },\\n        create: function (idbtrans) {\\n            var _this = this;\\n            if (!this.mode)\\n                return this;\\n            assert(!this.idbtrans);\\n            if (!idbtrans && !idbdb) {\\n                switch (dbOpenError && dbOpenError.name) {\\n                    case \\\"DatabaseClosedError\\\":\\n                        \\u002F\\u002F Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\\n                        throw new exceptions.DatabaseClosed(dbOpenError);\\n                    case \\\"MissingAPIError\\\":\\n                        \\u002F\\u002F Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\\n                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\\n                    default:\\n                        \\u002F\\u002F Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!\\n                        throw new exceptions.OpenFailed(dbOpenError);\\n                }\\n            }\\n            if (!this.active)\\n                throw new exceptions.TransactionInactive();\\n            assert(this._completion._state === null);\\n            idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);\\n            idbtrans.onerror = wrap(function (ev) {\\n                preventDefault(ev); \\u002F\\u002F Prohibit default bubbling to window.error\\n                _this._reject(idbtrans.error);\\n            });\\n            idbtrans.onabort = wrap(function (ev) {\\n                preventDefault(ev);\\n                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\\n                _this.active = false;\\n                _this.on(\\\"abort\\\").fire(ev);\\n            });\\n            idbtrans.oncomplete = wrap(function () {\\n                _this.active = false;\\n                _this._resolve();\\n            });\\n            return this;\\n        },\\n        _promise: function (mode, fn, bWriteLock) {\\n            var _this = this;\\n            if (mode === READWRITE && this.mode !== READWRITE)\\n                return rejection(new exceptions.ReadOnly(\\\"Transaction is readonly\\\"));\\n            if (!this.active)\\n                return rejection(new exceptions.TransactionInactive());\\n            if (this._locked()) {\\n                return new Promise(function (resolve, reject) {\\n                    _this._blockedFuncs.push([function () {\\n                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\\n                        }, PSD]);\\n                });\\n            }\\n            else if (bWriteLock) {\\n                return newScope(function () {\\n                    var p = new Promise(function (resolve, reject) {\\n                        _this._lock();\\n                        var rv = fn(resolve, reject, _this);\\n                        if (rv && rv.then)\\n                            rv.then(resolve, reject);\\n                    });\\n                    p.finally(function () { return _this._unlock(); });\\n                    p._lib = true;\\n                    return p;\\n                });\\n            }\\n            else {\\n                var p = new Promise(function (resolve, reject) {\\n                    var rv = fn(resolve, reject, _this);\\n                    if (rv && rv.then)\\n                        rv.then(resolve, reject);\\n                });\\n                p._lib = true;\\n                return p;\\n            }\\n        },\\n        _root: function () {\\n            return this.parent ? this.parent._root() : this;\\n        },\\n        waitFor: function (promise) {\\n            \\u002F\\u002F Always operate on the root transaction (in case this is a sub stransaction)\\n            var root = this._root();\\n            \\u002F\\u002F For stability reasons, convert parameter to promise no matter what type is passed to waitFor().\\n            \\u002F\\u002F (We must be able to call .then() on it.)\\n            promise = Promise.resolve(promise);\\n            if (root._waitingFor) {\\n                \\u002F\\u002F Already called waitFor(). Wait for both to complete.\\n                root._waitingFor = root._waitingFor.then(function () { return promise; });\\n            }\\n            else {\\n                \\u002F\\u002F We're not in waiting state. Start waiting state.\\n                root._waitingFor = promise;\\n                root._waitingQueue = [];\\n                \\u002F\\u002F Start interacting with indexedDB until promise completes:\\n                var store = root.idbtrans.objectStore(root.storeNames[0]);\\n                (function spin() {\\n                    ++root._spinCount; \\u002F\\u002F For debugging only\\n                    while (root._waitingQueue.length)\\n                        (root._waitingQueue.shift())();\\n                    if (root._waitingFor)\\n                        store.get(-Infinity).onsuccess = spin;\\n                }());\\n            }\\n            var currentWaitPromise = root._waitingFor;\\n            return new Promise(function (resolve, reject) {\\n                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\\n                    if (root._waitingFor === currentWaitPromise) {\\n                        \\u002F\\u002F No one added a wait after us. Safe to stop the spinning.\\n                        root._waitingFor = null;\\n                    }\\n                });\\n            });\\n        },\\n        \\u002F\\u002F\\n        \\u002F\\u002F Transaction Public Properties and Methods\\n        \\u002F\\u002F\\n        abort: function () {\\n            this.active && this._reject(new exceptions.Abort());\\n            this.active = false;\\n        },\\n        tables: {\\n            get: deprecated(\\\"Transaction.tables\\\", function () { return allTables; })\\n        },\\n        table: function (name) {\\n            var table = db.table(name); \\u002F\\u002F Don't check that table is part of transaction. It must fail lazily!\\n            return new Table(name, table.schema, this);\\n        }\\n    });\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F WhereClause\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    function WhereClause(table, index, orCollection) {\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"table\\\" type=\\\"Table\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"index\\\" type=\\\"String\\\" optional=\\\"true\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"orCollection\\\" type=\\\"Collection\\\" optional=\\\"true\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        this._ctx = {\\n            table: table,\\n            index: index === \\\":id\\\" ? null : index,\\n            or: orCollection\\n        };\\n    }\\n    props(WhereClause.prototype, function () {\\n        \\u002F\\u002F WhereClause private methods\\n        function fail(collectionOrWhereClause, err, T) {\\n            var collection = collectionOrWhereClause instanceof WhereClause ?\\n                new Collection(collectionOrWhereClause) :\\n                collectionOrWhereClause;\\n            collection._ctx.error = T ? new T(err) : new TypeError(err);\\n            return collection;\\n        }\\n        function emptyCollection(whereClause) {\\n            return new Collection(whereClause, function () { return IDBKeyRange.only(\\\"\\\"); }).limit(0);\\n        }\\n        function upperFactory(dir) {\\n            return dir === \\\"next\\\" ? function (s) { return s.toUpperCase(); } : function (s) { return s.toLowerCase(); };\\n        }\\n        function lowerFactory(dir) {\\n            return dir === \\\"next\\\" ? function (s) { return s.toLowerCase(); } : function (s) { return s.toUpperCase(); };\\n        }\\n        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\\n            var length = Math.min(key.length, lowerNeedle.length);\\n            var llp = -1;\\n            for (var i = 0; i \\u003C length; ++i) {\\n                var lwrKeyChar = lowerKey[i];\\n                if (lwrKeyChar !== lowerNeedle[i]) {\\n                    if (cmp(key[i], upperNeedle[i]) \\u003C 0)\\n                        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\\n                    if (cmp(key[i], lowerNeedle[i]) \\u003C 0)\\n                        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\\n                    if (llp \\u003E= 0)\\n                        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\\n                    return null;\\n                }\\n                if (cmp(key[i], lwrKeyChar) \\u003C 0)\\n                    llp = i;\\n            }\\n            if (length \\u003C lowerNeedle.length && dir === \\\"next\\\")\\n                return key + upperNeedle.substr(key.length);\\n            if (length \\u003C key.length && dir === \\\"prev\\\")\\n                return key.substr(0, upperNeedle.length);\\n            return (llp \\u003C 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\\n        }\\n        function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"needles\\\" type=\\\"Array\\\" elementType=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n            var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\\n            if (!needles.every(function (s) { return typeof s === 'string'; })) {\\n                return fail(whereClause, STRING_EXPECTED);\\n            }\\n            function initDirection(dir) {\\n                upper = upperFactory(dir);\\n                lower = lowerFactory(dir);\\n                compare = (dir === \\\"next\\\" ? simpleCompare : simpleCompareReverse);\\n                var needleBounds = needles.map(function (needle) {\\n                    return { lower: lower(needle), upper: upper(needle) };\\n                }).sort(function (a, b) {\\n                    return compare(a.lower, b.lower);\\n                });\\n                upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\\n                lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\\n                direction = dir;\\n                nextKeySuffix = (dir === \\\"next\\\" ? \\\"\\\" : suffix);\\n            }\\n            initDirection(\\\"next\\\");\\n            var c = new Collection(whereClause, function () {\\n                return IDBKeyRange.bound(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);\\n            });\\n            c._ondirectionchange = function (direction) {\\n                \\u002F\\u002F This event onlys occur before filter is called the first time.\\n                initDirection(direction);\\n            };\\n            var firstPossibleNeedle = 0;\\n            c._addAlgorithm(function (cursor, advance, resolve) {\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"cursor\\\" type=\\\"IDBCursor\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"advance\\\" type=\\\"Function\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"resolve\\\" type=\\\"Function\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                var key = cursor.key;\\n                if (typeof key !== 'string')\\n                    return false;\\n                var lowerKey = lower(key);\\n                if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\\n                    return true;\\n                }\\n                else {\\n                    var lowestPossibleCasing = null;\\n                    for (var i = firstPossibleNeedle; i \\u003C needlesLen; ++i) {\\n                        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\\n                        if (casing === null && lowestPossibleCasing === null)\\n                            firstPossibleNeedle = i + 1;\\n                        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) \\u003E 0) {\\n                            lowestPossibleCasing = casing;\\n                        }\\n                    }\\n                    if (lowestPossibleCasing !== null) {\\n                        advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\\n                    }\\n                    else {\\n                        advance(resolve);\\n                    }\\n                    return false;\\n                }\\n            });\\n            return c;\\n        }\\n        \\u002F\\u002F\\n        \\u002F\\u002F WhereClause public methods\\n        \\u002F\\u002F\\n        return {\\n            between: function (lower, upper, includeLower, includeUpper) {\\n                \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n                \\u002F\\u002F\\u002F     Filter out records whose where-field lays between given lower and upper values. Applies to Strings, Numbers and Dates.\\n                \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"lower\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"upper\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"includeLower\\\" optional=\\\"true\\\"\\u003EWhether items that equals lower should be included. Default true.\\u003C\\u002Fparam\\u003E\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"includeUpper\\\" optional=\\\"true\\\"\\u003EWhether items that equals upper should be included. Default false.\\u003C\\u002Fparam\\u003E\\n                \\u002F\\u002F\\u002F \\u003Creturns type=\\\"Collection\\\"\\u003E\\u003C\\u002Freturns\\u003E\\n                includeLower = includeLower !== false; \\u002F\\u002F Default to true\\n                includeUpper = includeUpper === true; \\u002F\\u002F Default to false\\n                try {\\n                    if ((cmp(lower, upper) \\u003E 0) ||\\n                        (cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\\n                        return emptyCollection(this); \\u002F\\u002F Workaround for idiotic W3C Specification that DataError must be thrown if lower \\u003E upper. The natural result would be to return an empty collection.\\n                    return new Collection(this, function () { return IDBKeyRange.bound(lower, upper, !includeLower, !includeUpper); });\\n                }\\n                catch (e) {\\n                    return fail(this, INVALID_KEY_ARGUMENT);\\n                }\\n            },\\n            equals: function (value) {\\n                return new Collection(this, function () { return IDBKeyRange.only(value); });\\n            },\\n            above: function (value) {\\n                return new Collection(this, function () { return IDBKeyRange.lowerBound(value, true); });\\n            },\\n            aboveOrEqual: function (value) {\\n                return new Collection(this, function () { return IDBKeyRange.lowerBound(value); });\\n            },\\n            below: function (value) {\\n                return new Collection(this, function () { return IDBKeyRange.upperBound(value, true); });\\n            },\\n            belowOrEqual: function (value) {\\n                return new Collection(this, function () { return IDBKeyRange.upperBound(value); });\\n            },\\n            startsWith: function (str) {\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"str\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                if (typeof str !== 'string')\\n                    return fail(this, STRING_EXPECTED);\\n                return this.between(str, str + maxString, true, true);\\n            },\\n            startsWithIgnoreCase: function (str) {\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"str\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                if (str === \\\"\\\")\\n                    return this.startsWith(str);\\n                return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\\n            },\\n            equalsIgnoreCase: function (str) {\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"str\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \\\"\\\");\\n            },\\n            anyOfIgnoreCase: function () {\\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\\n                if (set.length === 0)\\n                    return emptyCollection(this);\\n                return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \\\"\\\");\\n            },\\n            startsWithAnyOfIgnoreCase: function () {\\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\\n                if (set.length === 0)\\n                    return emptyCollection(this);\\n                return addIgnoreCaseAlgorithm(this, function (x, a) {\\n                    return a.some(function (n) {\\n                        return x.indexOf(n) === 0;\\n                    });\\n                }, set, maxString);\\n            },\\n            anyOf: function () {\\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\\n                var compare = ascending;\\n                try {\\n                    set.sort(compare);\\n                }\\n                catch (e) {\\n                    return fail(this, INVALID_KEY_ARGUMENT);\\n                }\\n                if (set.length === 0)\\n                    return emptyCollection(this);\\n                var c = new Collection(this, function () { return IDBKeyRange.bound(set[0], set[set.length - 1]); });\\n                c._ondirectionchange = function (direction) {\\n                    compare = (direction === \\\"next\\\" ? ascending : descending);\\n                    set.sort(compare);\\n                };\\n                var i = 0;\\n                c._addAlgorithm(function (cursor, advance, resolve) {\\n                    var key = cursor.key;\\n                    while (compare(key, set[i]) \\u003E 0) {\\n                        \\u002F\\u002F The cursor has passed beyond this key. Check next.\\n                        ++i;\\n                        if (i === set.length) {\\n                            \\u002F\\u002F There is no next. Stop searching.\\n                            advance(resolve);\\n                            return false;\\n                        }\\n                    }\\n                    if (compare(key, set[i]) === 0) {\\n                        \\u002F\\u002F The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\\n                        return true;\\n                    }\\n                    else {\\n                        \\u002F\\u002F cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\\n                        advance(function () { cursor.continue(set[i]); });\\n                        return false;\\n                    }\\n                });\\n                return c;\\n            },\\n            notEqual: function (value) {\\n                return this.inAnyRange([[minKey, value], [value, maxKey]], { includeLowers: false, includeUppers: false });\\n            },\\n            noneOf: function () {\\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\\n                if (set.length === 0)\\n                    return new Collection(this); \\u002F\\u002F Return entire collection.\\n                try {\\n                    set.sort(ascending);\\n                }\\n                catch (e) {\\n                    return fail(this, INVALID_KEY_ARGUMENT);\\n                }\\n                \\u002F\\u002F Transform [\\\"a\\\",\\\"b\\\",\\\"c\\\"] to a set of ranges for between\\u002Fabove\\u002Fbelow: [[minKey,\\\"a\\\"], [\\\"a\\\",\\\"b\\\"], [\\\"b\\\",\\\"c\\\"], [\\\"c\\\",maxKey]]\\n                var ranges = set.reduce(function (res, val) { return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]]; }, null);\\n                ranges.push([set[set.length - 1], maxKey]);\\n                return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\\n            },\\n            \\u002F** Filter out values withing given set of ranges.\\n            * Example, give children and elders a rebate of 50%:\\n            *\\n            *   db.friends.where('age').inAnyRange([[0,18],[65,Infinity]]).modify({Rebate: 1\\u002F2});\\n            *\\n            * @param {(string|number|Date|Array)[][]} ranges\\n            * @param {{includeLowers: boolean, includeUppers: boolean}} options\\n            *\\u002F\\n            inAnyRange: function (ranges, options) {\\n                if (ranges.length === 0)\\n                    return emptyCollection(this);\\n                if (!ranges.every(function (range) { return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) \\u003C= 0; })) {\\n                    return fail(this, \\\"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\\\", exceptions.InvalidArgument);\\n                }\\n                var includeLowers = !options || options.includeLowers !== false; \\u002F\\u002F Default to true\\n                var includeUppers = options && options.includeUppers === true; \\u002F\\u002F Default to false\\n                function addRange(ranges, newRange) {\\n                    for (var i = 0, l = ranges.length; i \\u003C l; ++i) {\\n                        var range = ranges[i];\\n                        if (cmp(newRange[0], range[1]) \\u003C 0 && cmp(newRange[1], range[0]) \\u003E 0) {\\n                            range[0] = min(range[0], newRange[0]);\\n                            range[1] = max(range[1], newRange[1]);\\n                            break;\\n                        }\\n                    }\\n                    if (i === l)\\n                        ranges.push(newRange);\\n                    return ranges;\\n                }\\n                var sortDirection = ascending;\\n                function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\\n                \\u002F\\u002F Join overlapping ranges\\n                var set;\\n                try {\\n                    set = ranges.reduce(addRange, []);\\n                    set.sort(rangeSorter);\\n                }\\n                catch (ex) {\\n                    return fail(this, INVALID_KEY_ARGUMENT);\\n                }\\n                var i = 0;\\n                var keyIsBeyondCurrentEntry = includeUppers ?\\n                    function (key) { return ascending(key, set[i][1]) \\u003E 0; } :\\n                    function (key) { return ascending(key, set[i][1]) \\u003E= 0; };\\n                var keyIsBeforeCurrentEntry = includeLowers ?\\n                    function (key) { return descending(key, set[i][0]) \\u003E 0; } :\\n                    function (key) { return descending(key, set[i][0]) \\u003E= 0; };\\n                function keyWithinCurrentRange(key) {\\n                    return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\\n                }\\n                var checkKey = keyIsBeyondCurrentEntry;\\n                var c = new Collection(this, function () {\\n                    return IDBKeyRange.bound(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);\\n                });\\n                c._ondirectionchange = function (direction) {\\n                    if (direction === \\\"next\\\") {\\n                        checkKey = keyIsBeyondCurrentEntry;\\n                        sortDirection = ascending;\\n                    }\\n                    else {\\n                        checkKey = keyIsBeforeCurrentEntry;\\n                        sortDirection = descending;\\n                    }\\n                    set.sort(rangeSorter);\\n                };\\n                c._addAlgorithm(function (cursor, advance, resolve) {\\n                    var key = cursor.key;\\n                    while (checkKey(key)) {\\n                        \\u002F\\u002F The cursor has passed beyond this key. Check next.\\n                        ++i;\\n                        if (i === set.length) {\\n                            \\u002F\\u002F There is no next. Stop searching.\\n                            advance(resolve);\\n                            return false;\\n                        }\\n                    }\\n                    if (keyWithinCurrentRange(key)) {\\n                        \\u002F\\u002F The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\\n                        return true;\\n                    }\\n                    else if (cmp(key, set[i][1]) === 0 || cmp(key, set[i][0]) === 0) {\\n                        \\u002F\\u002F includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.\\n                        \\u002F\\u002F Continue to next key but don't include this one.\\n                        return false;\\n                    }\\n                    else {\\n                        \\u002F\\u002F cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\\n                        advance(function () {\\n                            if (sortDirection === ascending)\\n                                cursor.continue(set[i][0]);\\n                            else\\n                                cursor.continue(set[i][1]);\\n                        });\\n                        return false;\\n                    }\\n                });\\n                return c;\\n            },\\n            startsWithAnyOf: function () {\\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\\n                if (!set.every(function (s) { return typeof s === 'string'; })) {\\n                    return fail(this, \\\"startsWithAnyOf() only works with strings\\\");\\n                }\\n                if (set.length === 0)\\n                    return emptyCollection(this);\\n                return this.inAnyRange(set.map(function (str) {\\n                    return [str, str + maxString];\\n                }));\\n            }\\n        };\\n    });\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F Collection Class\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    function Collection(whereClause, keyRangeGenerator) {\\n        \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n        \\u002F\\u002F\\u002F\\n        \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"whereClause\\\" type=\\\"WhereClause\\\"\\u003EWhere clause instance\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"keyRangeGenerator\\\" value=\\\"function(){ return IDBKeyRange.bound(0,1);}\\\" optional=\\\"true\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        var keyRange = null, error = null;\\n        if (keyRangeGenerator)\\n            try {\\n                keyRange = keyRangeGenerator();\\n            }\\n            catch (ex) {\\n                error = ex;\\n            }\\n        var whereCtx = whereClause._ctx, table = whereCtx.table;\\n        this._ctx = {\\n            table: table,\\n            index: whereCtx.index,\\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\\n            range: keyRange,\\n            keysOnly: false,\\n            dir: \\\"next\\\",\\n            unique: \\\"\\\",\\n            algorithm: null,\\n            filter: null,\\n            replayFilter: null,\\n            justLimit: true,\\n            isMatch: null,\\n            offset: 0,\\n            limit: Infinity,\\n            error: error,\\n            or: whereCtx.or,\\n            valueMapper: table.hook.reading.fire\\n        };\\n    }\\n    function isPlainKeyRange(ctx, ignoreLimitFilter) {\\n        return !(ctx.filter || ctx.algorithm || ctx.or) &&\\n            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\\n    }\\n    props(Collection.prototype, function () {\\n        \\u002F\\u002F\\n        \\u002F\\u002F Collection Private Functions\\n        \\u002F\\u002F\\n        function addFilter(ctx, fn) {\\n            ctx.filter = combine(ctx.filter, fn);\\n        }\\n        function addReplayFilter(ctx, factory, isLimitFilter) {\\n            var curr = ctx.replayFilter;\\n            ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\\n            ctx.justLimit = isLimitFilter && !curr;\\n        }\\n        function addMatchFilter(ctx, fn) {\\n            ctx.isMatch = combine(ctx.isMatch, fn);\\n        }\\n        \\u002F** @param ctx {\\n         *      isPrimKey: boolean,\\n         *      table: Table,\\n         *      index: string\\n         * }\\n         * @param store IDBObjectStore\\n         **\\u002F\\n        function getIndexOrStore(ctx, store) {\\n            if (ctx.isPrimKey)\\n                return store;\\n            var indexSpec = ctx.table.schema.idxByName[ctx.index];\\n            if (!indexSpec)\\n                throw new exceptions.Schema(\\\"KeyPath \\\" + ctx.index + \\\" on object store \\\" + store.name + \\\" is not indexed\\\");\\n            return store.index(indexSpec.name);\\n        }\\n        \\u002F** @param ctx {\\n         *      isPrimKey: boolean,\\n         *      table: Table,\\n         *      index: string,\\n         *      keysOnly: boolean,\\n         *      range?: IDBKeyRange,\\n         *      dir: \\\"next\\\" | \\\"prev\\\"\\n         * }\\n         *\\u002F\\n        function openCursor(ctx, store) {\\n            var idxOrStore = getIndexOrStore(ctx, store);\\n            return ctx.keysOnly && 'openKeyCursor' in idxOrStore ?\\n                idxOrStore.openKeyCursor(ctx.range || null, ctx.dir + ctx.unique) :\\n                idxOrStore.openCursor(ctx.range || null, ctx.dir + ctx.unique);\\n        }\\n        function iter(ctx, fn, resolve, reject, idbstore) {\\n            var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\\n            if (!ctx.or) {\\n                iterate(openCursor(ctx, idbstore), combine(ctx.algorithm, filter), fn, resolve, reject, !ctx.keysOnly && ctx.valueMapper);\\n            }\\n            else\\n                (function () {\\n                    var set = {};\\n                    var resolved = 0;\\n                    function resolveboth() {\\n                        if (++resolved === 2)\\n                            resolve(); \\u002F\\u002F Seems like we just support or btwn max 2 expressions, but there are no limit because we do recursion.\\n                    }\\n                    function union(item, cursor, advance) {\\n                        if (!filter || filter(cursor, advance, resolveboth, reject)) {\\n                            var primaryKey = cursor.primaryKey;\\n                            var key = '' + primaryKey;\\n                            if (key === '[object ArrayBuffer]')\\n                                key = '' + new Uint8Array(primaryKey);\\n                            if (!hasOwn(set, key)) {\\n                                set[key] = true;\\n                                fn(item, cursor, advance);\\n                            }\\n                        }\\n                    }\\n                    ctx.or._iterate(union, resolveboth, reject, idbstore);\\n                    iterate(openCursor(ctx, idbstore), ctx.algorithm, union, resolveboth, reject, !ctx.keysOnly && ctx.valueMapper);\\n                })();\\n        }\\n        return {\\n            \\u002F\\u002F\\n            \\u002F\\u002F Collection Protected Functions\\n            \\u002F\\u002F\\n            _read: function (fn, cb) {\\n                var ctx = this._ctx;\\n                return ctx.error ?\\n                    ctx.table._trans(null, rejection.bind(null, ctx.error)) :\\n                    ctx.table._idbstore(READONLY, fn).then(cb);\\n            },\\n            _write: function (fn) {\\n                var ctx = this._ctx;\\n                return ctx.error ?\\n                    ctx.table._trans(null, rejection.bind(null, ctx.error)) :\\n                    ctx.table._idbstore(READWRITE, fn, \\\"locked\\\"); \\u002F\\u002F When doing write operations on collections, always lock the operation so that upcoming operations gets queued.\\n            },\\n            _addAlgorithm: function (fn) {\\n                var ctx = this._ctx;\\n                ctx.algorithm = combine(ctx.algorithm, fn);\\n            },\\n            _iterate: function (fn, resolve, reject, idbstore) {\\n                return iter(this._ctx, fn, resolve, reject, idbstore);\\n            },\\n            clone: function (props$$1) {\\n                var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\\n                if (props$$1)\\n                    extend(ctx, props$$1);\\n                rv._ctx = ctx;\\n                return rv;\\n            },\\n            raw: function () {\\n                this._ctx.valueMapper = null;\\n                return this;\\n            },\\n            \\u002F\\u002F\\n            \\u002F\\u002F Collection Public methods\\n            \\u002F\\u002F\\n            each: function (fn) {\\n                var ctx = this._ctx;\\n                return this._read(function (resolve, reject, idbstore) {\\n                    iter(ctx, fn, resolve, reject, idbstore);\\n                });\\n            },\\n            count: function (cb) {\\n                var ctx = this._ctx;\\n                if (isPlainKeyRange(ctx, true)) {\\n                    \\u002F\\u002F This is a plain key range. We can use the count() method if the index.\\n                    return this._read(function (resolve, reject, idbstore) {\\n                        var idx = getIndexOrStore(ctx, idbstore);\\n                        var req = (ctx.range ? idx.count(ctx.range) : idx.count());\\n                        req.onerror = eventRejectHandler(reject);\\n                        req.onsuccess = function (e) {\\n                            resolve(Math.min(e.target.result, ctx.limit));\\n                        };\\n                    }, cb);\\n                }\\n                else {\\n                    \\u002F\\u002F Algorithms, filters or expressions are applied. Need to count manually.\\n                    var count = 0;\\n                    return this._read(function (resolve, reject, idbstore) {\\n                        iter(ctx, function () { ++count; return false; }, function () { resolve(count); }, reject, idbstore);\\n                    }, cb);\\n                }\\n            },\\n            sortBy: function (keyPath, cb) {\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"keyPath\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n                var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\\n                function getval(obj, i) {\\n                    if (i)\\n                        return getval(obj[parts[i]], i - 1);\\n                    return obj[lastPart];\\n                }\\n                var order = this._ctx.dir === \\\"next\\\" ? 1 : -1;\\n                function sorter(a, b) {\\n                    var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\\n                    return aVal \\u003C bVal ? -order : aVal \\u003E bVal ? order : 0;\\n                }\\n                return this.toArray(function (a) {\\n                    return a.sort(sorter);\\n                }).then(cb);\\n            },\\n            toArray: function (cb) {\\n                var ctx = this._ctx;\\n                return this._read(function (resolve, reject, idbstore) {\\n                    if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit \\u003E 0) {\\n                        \\u002F\\u002F Special optimation if we could use IDBObjectStore.getAll() or\\n                        \\u002F\\u002F IDBKeyRange.getAll():\\n                        var readingHook = ctx.table.hook.reading.fire;\\n                        var idxOrStore = getIndexOrStore(ctx, idbstore);\\n                        var req = ctx.limit \\u003C Infinity ?\\n                            idxOrStore.getAll(ctx.range, ctx.limit) :\\n                            idxOrStore.getAll(ctx.range);\\n                        req.onerror = eventRejectHandler(reject);\\n                        req.onsuccess = readingHook === mirror ?\\n                            eventSuccessHandler(resolve) :\\n                            eventSuccessHandler(function (res) {\\n                                try {\\n                                    resolve(res.map(readingHook));\\n                                }\\n                                catch (e) {\\n                                    reject(e);\\n                                }\\n                            });\\n                    }\\n                    else {\\n                        \\u002F\\u002F Getting array through a cursor.\\n                        var a = [];\\n                        iter(ctx, function (item) { a.push(item); }, function arrayComplete() {\\n                            resolve(a);\\n                        }, reject, idbstore);\\n                    }\\n                }, cb);\\n            },\\n            offset: function (offset) {\\n                var ctx = this._ctx;\\n                if (offset \\u003C= 0)\\n                    return this;\\n                ctx.offset += offset; \\u002F\\u002F For count()\\n                if (isPlainKeyRange(ctx)) {\\n                    addReplayFilter(ctx, function () {\\n                        var offsetLeft = offset;\\n                        return function (cursor, advance) {\\n                            if (offsetLeft === 0)\\n                                return true;\\n                            if (offsetLeft === 1) {\\n                                --offsetLeft;\\n                                return false;\\n                            }\\n                            advance(function () {\\n                                cursor.advance(offsetLeft);\\n                                offsetLeft = 0;\\n                            });\\n                            return false;\\n                        };\\n                    });\\n                }\\n                else {\\n                    addReplayFilter(ctx, function () {\\n                        var offsetLeft = offset;\\n                        return function () { return (--offsetLeft \\u003C 0); };\\n                    });\\n                }\\n                return this;\\n            },\\n            limit: function (numRows) {\\n                this._ctx.limit = Math.min(this._ctx.limit, numRows); \\u002F\\u002F For count()\\n                addReplayFilter(this._ctx, function () {\\n                    var rowsLeft = numRows;\\n                    return function (cursor, advance, resolve) {\\n                        if (--rowsLeft \\u003C= 0)\\n                            advance(resolve); \\u002F\\u002F Stop after this item has been included\\n                        return rowsLeft \\u003E= 0; \\u002F\\u002F If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.\\n                    };\\n                }, true);\\n                return this;\\n            },\\n            until: function (filterFunction, bIncludeStopEntry) {\\n                var ctx = this._ctx;\\n                addFilter(this._ctx, function (cursor, advance, resolve) {\\n                    if (filterFunction(cursor.value)) {\\n                        advance(resolve);\\n                        return bIncludeStopEntry;\\n                    }\\n                    else {\\n                        return true;\\n                    }\\n                });\\n                return this;\\n            },\\n            first: function (cb) {\\n                return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\\n            },\\n            last: function (cb) {\\n                return this.reverse().first(cb);\\n            },\\n            filter: function (filterFunction) {\\n                \\u002F\\u002F\\u002F \\u003Cparam name=\\\"jsFunctionFilter\\\" type=\\\"Function\\\"\\u003Efunction(val){return true\\u002Ffalse}\\u003C\\u002Fparam\\u003E\\n                addFilter(this._ctx, function (cursor) {\\n                    return filterFunction(cursor.value);\\n                });\\n                \\u002F\\u002F match filters not used in Dexie.js but can be used by 3rd part libraries to test a\\n                \\u002F\\u002F collection for a match without querying DB. Used by Dexie.Observable.\\n                addMatchFilter(this._ctx, filterFunction);\\n                return this;\\n            },\\n            and: function (filterFunction) {\\n                return this.filter(filterFunction);\\n            },\\n            or: function (indexName) {\\n                return new WhereClause(this._ctx.table, indexName, this);\\n            },\\n            reverse: function () {\\n                this._ctx.dir = (this._ctx.dir === \\\"prev\\\" ? \\\"next\\\" : \\\"prev\\\");\\n                if (this._ondirectionchange)\\n                    this._ondirectionchange(this._ctx.dir);\\n                return this;\\n            },\\n            desc: function () {\\n                return this.reverse();\\n            },\\n            eachKey: function (cb) {\\n                var ctx = this._ctx;\\n                ctx.keysOnly = !ctx.isMatch;\\n                return this.each(function (val, cursor) { cb(cursor.key, cursor); });\\n            },\\n            eachUniqueKey: function (cb) {\\n                this._ctx.unique = \\\"unique\\\";\\n                return this.eachKey(cb);\\n            },\\n            eachPrimaryKey: function (cb) {\\n                var ctx = this._ctx;\\n                ctx.keysOnly = !ctx.isMatch;\\n                return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\\n            },\\n            keys: function (cb) {\\n                var ctx = this._ctx;\\n                ctx.keysOnly = !ctx.isMatch;\\n                var a = [];\\n                return this.each(function (item, cursor) {\\n                    a.push(cursor.key);\\n                }).then(function () {\\n                    return a;\\n                }).then(cb);\\n            },\\n            primaryKeys: function (cb) {\\n                var ctx = this._ctx;\\n                if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit \\u003E 0) {\\n                    \\u002F\\u002F Special optimation if we could use IDBObjectStore.getAllKeys() or\\n                    \\u002F\\u002F IDBKeyRange.getAllKeys():\\n                    return this._read(function (resolve, reject, idbstore) {\\n                        var idxOrStore = getIndexOrStore(ctx, idbstore);\\n                        var req = ctx.limit \\u003C Infinity ?\\n                            idxOrStore.getAllKeys(ctx.range, ctx.limit) :\\n                            idxOrStore.getAllKeys(ctx.range);\\n                        req.onerror = eventRejectHandler(reject);\\n                        req.onsuccess = eventSuccessHandler(resolve);\\n                    }).then(cb);\\n                }\\n                ctx.keysOnly = !ctx.isMatch;\\n                var a = [];\\n                return this.each(function (item, cursor) {\\n                    a.push(cursor.primaryKey);\\n                }).then(function () {\\n                    return a;\\n                }).then(cb);\\n            },\\n            uniqueKeys: function (cb) {\\n                this._ctx.unique = \\\"unique\\\";\\n                return this.keys(cb);\\n            },\\n            firstKey: function (cb) {\\n                return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\\n            },\\n            lastKey: function (cb) {\\n                return this.reverse().firstKey(cb);\\n            },\\n            distinct: function () {\\n                var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\\n                if (!idx || !idx.multi)\\n                    return this; \\u002F\\u002F distinct() only makes differencies on multiEntry indexes.\\n                var set = {};\\n                addFilter(this._ctx, function (cursor) {\\n                    var strKey = cursor.primaryKey.toString(); \\u002F\\u002F Converts any Date to String, String to String, Number to String and Array to comma-separated string\\n                    var found = hasOwn(set, strKey);\\n                    set[strKey] = true;\\n                    return !found;\\n                });\\n                return this;\\n            },\\n            \\u002F\\u002F\\n            \\u002F\\u002F Methods that mutate storage\\n            \\u002F\\u002F\\n            modify: function (changes) {\\n                var self = this, ctx = this._ctx, hook = ctx.table.hook, updatingHook = hook.updating.fire, deletingHook = hook.deleting.fire;\\n                return this._write(function (resolve, reject, idbstore, trans) {\\n                    var modifyer;\\n                    if (typeof changes === 'function') {\\n                        \\u002F\\u002F Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)\\n                        if (updatingHook === nop && deletingHook === nop) {\\n                            \\u002F\\u002F Noone cares about what is being changed. Just let the modifier function be the given argument as is.\\n                            modifyer = changes;\\n                        }\\n                        else {\\n                            \\u002F\\u002F People want to know exactly what is being modified or deleted.\\n                            \\u002F\\u002F Let modifyer be a proxy function that finds out what changes the caller is actually doing\\n                            \\u002F\\u002F and call the hooks accordingly!\\n                            modifyer = function (item) {\\n                                var origItem = deepClone(item); \\u002F\\u002F Clone the item first so we can compare laters.\\n                                if (changes.call(this, item, this) === false)\\n                                    return false; \\u002F\\u002F Call the real modifyer function (If it returns false explicitely, it means it dont want to modify anyting on this object)\\n                                if (!hasOwn(this, \\\"value\\\")) {\\n                                    \\u002F\\u002F The real modifyer function requests a deletion of the object. Inform the deletingHook that a deletion is taking place.\\n                                    deletingHook.call(this, this.primKey, item, trans);\\n                                }\\n                                else {\\n                                    \\u002F\\u002F No deletion. Check what was changed\\n                                    var objectDiff = getObjectDiff(origItem, this.value);\\n                                    var additionalChanges = updatingHook.call(this, objectDiff, this.primKey, origItem, trans);\\n                                    if (additionalChanges) {\\n                                        \\u002F\\u002F Hook want to apply additional modifications. Make sure to fullfill the will of the hook.\\n                                        item = this.value;\\n                                        keys(additionalChanges).forEach(function (keyPath) {\\n                                            setByKeyPath(item, keyPath, additionalChanges[keyPath]); \\u002F\\u002F Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\\n                                        });\\n                                    }\\n                                }\\n                            };\\n                        }\\n                    }\\n                    else if (updatingHook === nop) {\\n                        \\u002F\\u002F changes is a set of {keyPath: value} and no one is listening to the updating hook.\\n                        var keyPaths = keys(changes);\\n                        var numKeys = keyPaths.length;\\n                        modifyer = function (item) {\\n                            var anythingModified = false;\\n                            for (var i = 0; i \\u003C numKeys; ++i) {\\n                                var keyPath = keyPaths[i], val = changes[keyPath];\\n                                if (getByKeyPath(item, keyPath) !== val) {\\n                                    setByKeyPath(item, keyPath, val); \\u002F\\u002F Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\\n                                    anythingModified = true;\\n                                }\\n                            }\\n                            return anythingModified;\\n                        };\\n                    }\\n                    else {\\n                        \\u002F\\u002F changes is a set of {keyPath: value} and people are listening to the updating hook so we need to call it and\\n                        \\u002F\\u002F allow it to add additional modifications to make.\\n                        var origChanges = changes;\\n                        changes = shallowClone(origChanges); \\u002F\\u002F Let's work with a clone of the changes keyPath\\u002Fvalue set so that we can restore it in case a hook extends it.\\n                        modifyer = function (item) {\\n                            var anythingModified = false;\\n                            var additionalChanges = updatingHook.call(this, changes, this.primKey, deepClone(item), trans);\\n                            if (additionalChanges)\\n                                extend(changes, additionalChanges);\\n                            keys(changes).forEach(function (keyPath) {\\n                                var val = changes[keyPath];\\n                                if (getByKeyPath(item, keyPath) !== val) {\\n                                    setByKeyPath(item, keyPath, val);\\n                                    anythingModified = true;\\n                                }\\n                            });\\n                            if (additionalChanges)\\n                                changes = shallowClone(origChanges); \\u002F\\u002F Restore original changes for next iteration\\n                            return anythingModified;\\n                        };\\n                    }\\n                    var count = 0;\\n                    var successCount = 0;\\n                    var iterationComplete = false;\\n                    var failures = [];\\n                    var failKeys = [];\\n                    var currentKey = null;\\n                    function modifyItem(item, cursor) {\\n                        currentKey = cursor.primaryKey;\\n                        var thisContext = {\\n                            primKey: cursor.primaryKey,\\n                            value: item,\\n                            onsuccess: null,\\n                            onerror: null\\n                        };\\n                        function onerror(e) {\\n                            failures.push(e);\\n                            failKeys.push(thisContext.primKey);\\n                            checkFinished();\\n                            return true; \\u002F\\u002F Catch these errors and let a final rejection decide whether or not to abort entire transaction\\n                        }\\n                        if (modifyer.call(thisContext, item, thisContext) !== false) {\\n                            var bDelete = !hasOwn(thisContext, \\\"value\\\");\\n                            ++count;\\n                            tryCatch(function () {\\n                                var req = (bDelete ? cursor.delete() : cursor.update(thisContext.value));\\n                                req._hookCtx = thisContext;\\n                                req.onerror = hookedEventRejectHandler(onerror);\\n                                req.onsuccess = hookedEventSuccessHandler(function () {\\n                                    ++successCount;\\n                                    checkFinished();\\n                                });\\n                            }, onerror);\\n                        }\\n                        else if (thisContext.onsuccess) {\\n                            \\u002F\\u002F Hook will expect either onerror or onsuccess to always be called!\\n                            thisContext.onsuccess(thisContext.value);\\n                        }\\n                    }\\n                    function doReject(e) {\\n                        if (e) {\\n                            failures.push(e);\\n                            failKeys.push(currentKey);\\n                        }\\n                        return reject(new ModifyError(\\\"Error modifying one or more objects\\\", failures, successCount, failKeys));\\n                    }\\n                    function checkFinished() {\\n                        if (iterationComplete && successCount + failures.length === count) {\\n                            if (failures.length \\u003E 0)\\n                                doReject();\\n                            else\\n                                resolve(successCount);\\n                        }\\n                    }\\n                    self.clone().raw()._iterate(modifyItem, function () {\\n                        iterationComplete = true;\\n                        checkFinished();\\n                    }, doReject, idbstore);\\n                });\\n            },\\n            'delete': function () {\\n                var _this = this;\\n                var ctx = this._ctx, range = ctx.range, deletingHook = ctx.table.hook.deleting.fire, hasDeleteHook = deletingHook !== nop;\\n                if (!hasDeleteHook &&\\n                    isPlainKeyRange(ctx) &&\\n                    ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || !range)) {\\n                    \\u002F\\u002F May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)\\n                    \\u002F\\u002F For chromium, this is the way most optimized version.\\n                    \\u002F\\u002F For IE\\u002FEdge, this could hang the indexedDB engine and make operating system instable\\n                    \\u002F\\u002F (https:\\u002F\\u002Fgist.github.com\\u002Fdfahlander\\u002F5a39328f029de18222cf2125d56c38f7)\\n                    return this._write(function (resolve, reject, idbstore) {\\n                        \\u002F\\u002F Our API contract is to return a count of deleted items, so we have to count() before delete().\\n                        var onerror = eventRejectHandler(reject), countReq = (range ? idbstore.count(range) : idbstore.count());\\n                        countReq.onerror = onerror;\\n                        countReq.onsuccess = function () {\\n                            var count = countReq.result;\\n                            tryCatch(function () {\\n                                var delReq = (range ? idbstore.delete(range) : idbstore.clear());\\n                                delReq.onerror = onerror;\\n                                delReq.onsuccess = function () { return resolve(count); };\\n                            }, function (err) { return reject(err); });\\n                        };\\n                    });\\n                }\\n                \\u002F\\u002F Default version to use when collection is not a vanilla IDBKeyRange on the primary key.\\n                \\u002F\\u002F Divide into chunks to not starve RAM.\\n                \\u002F\\u002F If has delete hook, we will have to collect not just keys but also objects, so it will use\\n                \\u002F\\u002F more memory and need lower chunk size.\\n                var CHUNKSIZE = hasDeleteHook ? 2000 : 10000;\\n                return this._write(function (resolve, reject, idbstore, trans) {\\n                    var totalCount = 0;\\n                    \\u002F\\u002F Clone collection and change its table and set a limit of CHUNKSIZE on the cloned Collection instance.\\n                    var collection = _this\\n                        .clone({\\n                        keysOnly: !ctx.isMatch && !hasDeleteHook\\n                    }) \\u002F\\u002F load just keys (unless filter() or and() or deleteHook has subscribers)\\n                        .distinct() \\u002F\\u002F In case multiEntry is used, never delete same key twice because resulting count\\n                        .limit(CHUNKSIZE)\\n                        .raw(); \\u002F\\u002F Don't filter through reading-hooks (like mapped classes etc)\\n                    var keysOrTuples = [];\\n                    \\u002F\\u002F We're gonna do things on as many chunks that are needed.\\n                    \\u002F\\u002F Use recursion of nextChunk function:\\n                    var nextChunk = function () { return collection.each(hasDeleteHook ? function (val, cursor) {\\n                        \\u002F\\u002F Somebody subscribes to hook('deleting'). Collect all primary keys and their values,\\n                        \\u002F\\u002F so that the hook can be called with its values in bulkDelete().\\n                        keysOrTuples.push([cursor.primaryKey, cursor.value]);\\n                    } : function (val, cursor) {\\n                        \\u002F\\u002F No one subscribes to hook('deleting'). Collect only primary keys:\\n                        keysOrTuples.push(cursor.primaryKey);\\n                    }).then(function () {\\n                        \\u002F\\u002F Chromium deletes faster when doing it in sort order.\\n                        hasDeleteHook ?\\n                            keysOrTuples.sort(function (a, b) { return ascending(a[0], b[0]); }) :\\n                            keysOrTuples.sort(ascending);\\n                        return bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook);\\n                    }).then(function () {\\n                        var count = keysOrTuples.length;\\n                        totalCount += count;\\n                        keysOrTuples = [];\\n                        return count \\u003C CHUNKSIZE ? totalCount : nextChunk();\\n                    }); };\\n                    resolve(nextChunk());\\n                });\\n            }\\n        };\\n    });\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F ------------------------- Help functions ---------------------------\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    \\u002F\\u002F\\n    function lowerVersionFirst(a, b) {\\n        return a._cfg.version - b._cfg.version;\\n    }\\n    function setApiOnPlace(objs, tableNames, dbschema) {\\n        tableNames.forEach(function (tableName) {\\n            var schema = dbschema[tableName];\\n            objs.forEach(function (obj) {\\n                if (!(tableName in obj)) {\\n                    if (obj === Transaction.prototype || obj instanceof Transaction) {\\n                        \\u002F\\u002F obj is a Transaction prototype (or prototype of a subclass to Transaction)\\n                        \\u002F\\u002F Make the API a getter that returns this.table(tableName)\\n                        setProp(obj, tableName, { get: function () { return this.table(tableName); } });\\n                    }\\n                    else {\\n                        \\u002F\\u002F Table will not be bound to a transaction (will use Dexie.currentTransaction)\\n                        obj[tableName] = new Table(tableName, schema);\\n                    }\\n                }\\n            });\\n        });\\n    }\\n    function removeTablesApi(objs) {\\n        objs.forEach(function (obj) {\\n            for (var key in obj) {\\n                if (obj[key] instanceof Table)\\n                    delete obj[key];\\n            }\\n        });\\n    }\\n    function iterate(req, filter, fn, resolve, reject, valueMapper) {\\n        \\u002F\\u002F Apply valueMapper (hook('reading') or mappped class)\\n        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\\n        \\u002F\\u002F Wrap fn with PSD and microtick stuff from Promise.\\n        var wrappedFn = wrap(mappedFn, reject);\\n        if (!req.onerror)\\n            req.onerror = eventRejectHandler(reject);\\n        if (filter) {\\n            req.onsuccess = trycatcher(function filter_record() {\\n                var cursor = req.result;\\n                if (cursor) {\\n                    var c = function () { cursor.continue(); };\\n                    if (filter(cursor, function (advancer) { c = advancer; }, resolve, reject))\\n                        wrappedFn(cursor.value, cursor, function (advancer) { c = advancer; });\\n                    c();\\n                }\\n                else {\\n                    resolve();\\n                }\\n            }, reject);\\n        }\\n        else {\\n            req.onsuccess = trycatcher(function filter_record() {\\n                var cursor = req.result;\\n                if (cursor) {\\n                    var c = function () { cursor.continue(); };\\n                    wrappedFn(cursor.value, cursor, function (advancer) { c = advancer; });\\n                    c();\\n                }\\n                else {\\n                    resolve();\\n                }\\n            }, reject);\\n        }\\n    }\\n    function parseIndexSyntax(indexes) {\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"indexes\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Creturns type=\\\"Array\\\" elementType=\\\"IndexSpec\\\"\\u003E\\u003C\\u002Freturns\\u003E\\n        var rv = [];\\n        indexes.split(',').forEach(function (index) {\\n            index = index.trim();\\n            var name = index.replace(\\u002F([&*]|\\\\+\\\\+)\\u002Fg, \\\"\\\"); \\u002F\\u002F Remove \\\"&\\\", \\\"++\\\" and \\\"*\\\"\\n            \\u002F\\u002F Let keyPath of \\\"[a+b]\\\" be [\\\"a\\\",\\\"b\\\"]:\\n            var keyPath = \\u002F^\\\\[\\u002F.test(name) ? name.match(\\u002F^\\\\[(.*)\\\\]$\\u002F)[1].split('+') : name;\\n            rv.push(new IndexSpec(name, keyPath || null, \\u002F\\\\&\\u002F.test(index), \\u002F\\\\*\\u002F.test(index), \\u002F\\\\+\\\\+\\u002F.test(index), isArray(keyPath), \\u002F\\\\.\\u002F.test(index)));\\n        });\\n        return rv;\\n    }\\n    function cmp(key1, key2) {\\n        return indexedDB.cmp(key1, key2);\\n    }\\n    function min(a, b) {\\n        return cmp(a, b) \\u003C 0 ? a : b;\\n    }\\n    function max(a, b) {\\n        return cmp(a, b) \\u003E 0 ? a : b;\\n    }\\n    function ascending(a, b) {\\n        return indexedDB.cmp(a, b);\\n    }\\n    function descending(a, b) {\\n        return indexedDB.cmp(b, a);\\n    }\\n    function simpleCompare(a, b) {\\n        return a \\u003C b ? -1 : a === b ? 0 : 1;\\n    }\\n    function simpleCompareReverse(a, b) {\\n        return a \\u003E b ? -1 : a === b ? 0 : 1;\\n    }\\n    function combine(filter1, filter2) {\\n        return filter1 ?\\n            filter2 ?\\n                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\\n                filter1 :\\n            filter2;\\n    }\\n    function readGlobalSchema() {\\n        db.verno = idbdb.version \\u002F 10;\\n        db._dbSchema = globalSchema = {};\\n        dbStoreNames = slice(idbdb.objectStoreNames, 0);\\n        if (dbStoreNames.length === 0)\\n            return; \\u002F\\u002F Database contains no stores.\\n        var trans = idbdb.transaction(safariMultiStoreFix(dbStoreNames), 'readonly');\\n        dbStoreNames.forEach(function (storeName) {\\n            var store = trans.objectStore(storeName), keyPath = store.keyPath, dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;\\n            var primKey = new IndexSpec(keyPath, keyPath || \\\"\\\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== 'string', dotted);\\n            var indexes = [];\\n            for (var j = 0; j \\u003C store.indexNames.length; ++j) {\\n                var idbindex = store.index(store.indexNames[j]);\\n                keyPath = idbindex.keyPath;\\n                dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;\\n                var index = new IndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== 'string', dotted);\\n                indexes.push(index);\\n            }\\n            globalSchema[storeName] = new TableSchema(storeName, primKey, indexes, {});\\n        });\\n        setApiOnPlace([allTables], keys(globalSchema), globalSchema);\\n    }\\n    function adjustToExistingIndexNames(schema, idbtrans) {\\n        \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n        \\u002F\\u002F\\u002F Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db\\n        \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"schema\\\" type=\\\"Object\\\"\\u003EMap between name and TableSchema\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"idbtrans\\\" type=\\\"IDBTransaction\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n        var storeNames = idbtrans.db.objectStoreNames;\\n        for (var i = 0; i \\u003C storeNames.length; ++i) {\\n            var storeName = storeNames[i];\\n            var store = idbtrans.objectStore(storeName);\\n            hasGetAll = 'getAll' in store;\\n            for (var j = 0; j \\u003C store.indexNames.length; ++j) {\\n                var indexName = store.indexNames[j];\\n                var keyPath = store.index(indexName).keyPath;\\n                var dexieName = typeof keyPath === 'string' ? keyPath : \\\"[\\\" + slice(keyPath).join('+') + \\\"]\\\";\\n                if (schema[storeName]) {\\n                    var indexSpec = schema[storeName].idxByName[dexieName];\\n                    if (indexSpec)\\n                        indexSpec.name = indexName;\\n                }\\n            }\\n        }\\n        \\u002F\\u002F Bug with getAll() on Safari ver\\u003C604 on Workers only, see discussion following PR #579\\n        if (\\u002FSafari\\u002F.test(navigator.userAgent) &&\\n            !\\u002F(Chrome\\\\\\u002F|Edge\\\\\\u002F)\\u002F.test(navigator.userAgent) &&\\n            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\\n            [].concat(navigator.userAgent.match(\\u002FSafari\\\\\\u002F(\\\\d*)\\u002F))[1] \\u003C 604) {\\n            hasGetAll = false;\\n        }\\n    }\\n    function fireOnBlocked(ev) {\\n        db.on(\\\"blocked\\\").fire(ev);\\n        \\u002F\\u002F Workaround (not fully*) for missing \\\"versionchange\\\" event in IE,Edge and Safari:\\n        connections\\n            .filter(function (c) { return c.name === db.name && c !== db && !c._vcFired; })\\n            .map(function (c) { return c.on(\\\"versionchange\\\").fire(ev); });\\n    }\\n    extend(this, {\\n        Collection: Collection,\\n        Table: Table,\\n        Transaction: Transaction,\\n        Version: Version,\\n        WhereClause: WhereClause\\n    });\\n    init();\\n    addons.forEach(function (fn) {\\n        fn(db);\\n    });\\n}\\nfunction parseType(type) {\\n    if (typeof type === 'function') {\\n        return new type();\\n    }\\n    else if (isArray(type)) {\\n        return [parseType(type[0])];\\n    }\\n    else if (type && typeof type === 'object') {\\n        var rv = {};\\n        applyStructure(rv, type);\\n        return rv;\\n    }\\n    else {\\n        return type;\\n    }\\n}\\nfunction applyStructure(obj, structure) {\\n    keys(structure).forEach(function (member) {\\n        var value = parseType(structure[member]);\\n        obj[member] = value;\\n    });\\n    return obj;\\n}\\nfunction hookedEventSuccessHandler(resolve) {\\n    \\u002F\\u002F wrap() is needed when calling hooks because the rare scenario of:\\n    \\u002F\\u002F  * hook does a db operation that fails immediately (IDB throws exception)\\n    \\u002F\\u002F    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.\\n    \\u002F\\u002F    wrap() will also execute in a virtual tick.\\n    \\u002F\\u002F  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.\\n    \\u002F\\u002F  * If this was the last event in the bulk, the promise will resolve after a physical tick\\n    \\u002F\\u002F    and the transaction will have committed already.\\n    \\u002F\\u002F If no hook, the virtual tick will be executed in the reject()\\u002Fresolve of the final promise,\\n    \\u002F\\u002F because it is always marked with _lib = true when created using Transaction._promise().\\n    return wrap(function (event) {\\n        var req = event.target, ctx = req._hookCtx, \\u002F\\u002F Contains the hook error handler. Put here instead of closure to boost performance.\\n        result = ctx.value || req.result, \\u002F\\u002F Pass the object value on updates. The result from IDB is the primary key.\\n        hookSuccessHandler = ctx && ctx.onsuccess;\\n        hookSuccessHandler && hookSuccessHandler(result);\\n        resolve && resolve(result);\\n    }, resolve);\\n}\\nfunction eventRejectHandler(reject) {\\n    return wrap(function (event) {\\n        preventDefault(event);\\n        reject(event.target.error);\\n        return false;\\n    });\\n}\\nfunction eventSuccessHandler(resolve) {\\n    return wrap(function (event) {\\n        resolve(event.target.result);\\n    });\\n}\\nfunction hookedEventRejectHandler(reject) {\\n    return wrap(function (event) {\\n        \\u002F\\u002F See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.\\n        var req = event.target, err = req.error, ctx = req._hookCtx, \\u002F\\u002F Contains the hook error handler. Put here instead of closure to boost performance.\\n        hookErrorHandler = ctx && ctx.onerror;\\n        hookErrorHandler && hookErrorHandler(err);\\n        preventDefault(event);\\n        reject(err);\\n        return false;\\n    });\\n}\\nfunction preventDefault(event) {\\n    if (event.stopPropagation)\\n        event.stopPropagation();\\n    if (event.preventDefault)\\n        event.preventDefault();\\n}\\nfunction awaitIterator(iterator) {\\n    var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\\n    function step(getNext) {\\n        return function (val) {\\n            var next = getNext(val), value = next.value;\\n            return next.done ? value :\\n                (!value || typeof value.then !== 'function' ?\\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\\n                    value.then(onSuccess, onError));\\n        };\\n    }\\n    return step(callNext)();\\n}\\n\\u002F\\u002F\\n\\u002F\\u002F IndexSpec struct\\n\\u002F\\u002F\\nfunction IndexSpec(name, keyPath, unique, multi, auto, compound, dotted) {\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"name\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"keyPath\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"unique\\\" type=\\\"Boolean\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"multi\\\" type=\\\"Boolean\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"auto\\\" type=\\\"Boolean\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"compound\\\" type=\\\"Boolean\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"dotted\\\" type=\\\"Boolean\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    this.name = name;\\n    this.keyPath = keyPath;\\n    this.unique = unique;\\n    this.multi = multi;\\n    this.auto = auto;\\n    this.compound = compound;\\n    this.dotted = dotted;\\n    var keyPathSrc = typeof keyPath === 'string' ? keyPath : keyPath && ('[' + [].join.call(keyPath, '+') + ']');\\n    this.src = (unique ? '&' : '') + (multi ? '*' : '') + (auto ? \\\"++\\\" : \\\"\\\") + keyPathSrc;\\n}\\n\\u002F\\u002F\\n\\u002F\\u002F TableSchema struct\\n\\u002F\\u002F\\nfunction TableSchema(name, primKey, indexes, instanceTemplate) {\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"name\\\" type=\\\"String\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"primKey\\\" type=\\\"IndexSpec\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"indexes\\\" type=\\\"Array\\\" elementType=\\\"IndexSpec\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    \\u002F\\u002F\\u002F \\u003Cparam name=\\\"instanceTemplate\\\" type=\\\"Object\\\"\\u003E\\u003C\\u002Fparam\\u003E\\n    this.name = name;\\n    this.primKey = primKey || new IndexSpec();\\n    this.indexes = indexes || [new IndexSpec()];\\n    this.instanceTemplate = instanceTemplate;\\n    this.mappedClass = null;\\n    this.idxByName = arrayToObject(indexes, function (index) { return [index.name, index]; });\\n}\\nfunction safariMultiStoreFix(storeNames) {\\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\\n}\\nfunction getNativeGetDatabaseNamesFn(indexedDB) {\\n    var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);\\n    return fn && fn.bind(indexedDB);\\n}\\n\\u002F\\u002F Export Error classes\\nprops(Dexie, fullNameExceptions); \\u002F\\u002F Dexie.XXXError = class XXXError {...};\\n\\u002F\\u002F\\n\\u002F\\u002F Static methods and properties\\n\\u002F\\u002F \\nprops(Dexie, {\\n    \\u002F\\u002F\\n    \\u002F\\u002F Static delete() method.\\n    \\u002F\\u002F\\n    delete: function (databaseName) {\\n        var db = new Dexie(databaseName), promise = db.delete();\\n        promise.onblocked = function (fn) {\\n            db.on(\\\"blocked\\\", fn);\\n            return this;\\n        };\\n        return promise;\\n    },\\n    \\u002F\\u002F\\n    \\u002F\\u002F Static exists() method.\\n    \\u002F\\u002F\\n    exists: function (name) {\\n        return new Dexie(name).open().then(function (db) {\\n            db.close();\\n            return true;\\n        }).catch(Dexie.NoSuchDatabaseError, function () { return false; });\\n    },\\n    \\u002F\\u002F\\n    \\u002F\\u002F Static method for retrieving a list of all existing databases at current host.\\n    \\u002F\\u002F\\n    getDatabaseNames: function (cb) {\\n        var getDatabaseNames = getNativeGetDatabaseNamesFn(Dexie.dependencies.indexedDB);\\n        return getDatabaseNames ? new Promise(function (resolve, reject) {\\n            var req = getDatabaseNames();\\n            req.onsuccess = function (event) {\\n                resolve(slice(event.target.result, 0)); \\u002F\\u002F Converst DOMStringList to Array\\u003CString\\u003E\\n            };\\n            req.onerror = eventRejectHandler(reject);\\n        }).then(cb) : dbNamesDB.dbnames.toCollection().primaryKeys(cb);\\n    },\\n    defineClass: function (structure) {\\n        \\u002F\\u002F\\u002F \\u003Csummary\\u003E\\n        \\u002F\\u002F\\u002F     Create a javascript constructor based on given template for which properties to expect in the class.\\n        \\u002F\\u002F\\u002F     Any property that is a constructor function will act as a type. So {name: String} will be equal to {name: new String()}.\\n        \\u002F\\u002F\\u002F \\u003C\\u002Fsummary\\u003E\\n        \\u002F\\u002F\\u002F \\u003Cparam name=\\\"structure\\\"\\u003EHelps IDE code completion by knowing the members that objects contain and not just the indexes. Also\\n        \\u002F\\u002F\\u002F know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}\\u003C\\u002Fparam\\u003E\\n        \\u002F\\u002F Default constructor able to copy given properties into this object.\\n        function Class(properties) {\\n            \\u002F\\u002F\\u002F \\u003Cparam name=\\\"properties\\\" type=\\\"Object\\\" optional=\\\"true\\\"\\u003EProperties to initialize object with.\\n            \\u002F\\u002F\\u002F \\u003C\\u002Fparam\\u003E\\n            if (properties)\\n                extend(this, properties);\\n        }\\n        return Class;\\n    },\\n    applyStructure: applyStructure,\\n    ignoreTransaction: function (scopeFunc) {\\n        \\u002F\\u002F In case caller is within a transaction but needs to create a separate transaction.\\n        \\u002F\\u002F Example of usage:\\n        \\u002F\\u002F\\n        \\u002F\\u002F Let's say we have a logger function in our app. Other application-logic should be unaware of the\\n        \\u002F\\u002F logger function and not need to include the 'logentries' table in all transaction it performs.\\n        \\u002F\\u002F The logging should always be done in a separate transaction and not be dependant on the current\\n        \\u002F\\u002F running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.\\n        \\u002F\\u002F\\n        \\u002F\\u002F     Dexie.ignoreTransaction(function() {\\n        \\u002F\\u002F         db.logentries.add(newLogEntry);\\n        \\u002F\\u002F     });\\n        \\u002F\\u002F\\n        \\u002F\\u002F Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction\\n        \\u002F\\u002F in current Promise-scope.\\n        \\u002F\\u002F\\n        \\u002F\\u002F An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an\\n        \\u002F\\u002F API for this because\\n        \\u002F\\u002F  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().\\n        \\u002F\\u002F  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().\\n        \\u002F\\u002F  3) setImmediate() is not supported in the ES standard.\\n        \\u002F\\u002F  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.\\n        return PSD.trans ?\\n            usePSD(PSD.transless, scopeFunc) : \\u002F\\u002F Use the closest parent that was non-transactional.\\n            scopeFunc(); \\u002F\\u002F No need to change scope because there is no ongoing transaction.\\n    },\\n    vip: function (fn) {\\n        \\u002F\\u002F To be used by subscribers to the on('ready') event.\\n        \\u002F\\u002F This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.\\n        \\u002F\\u002F This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD\\n        \\u002F\\u002F from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since\\n        \\u002F\\u002F the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.\\n        \\u002F\\u002F Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()\\n        \\u002F\\u002F the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by\\n        \\u002F\\u002F the caller will not resolve until database is opened.\\n        return newScope(function () {\\n            PSD.letThrough = true; \\u002F\\u002F Make sure we are let through if still blocking db due to onready is firing.\\n            return fn();\\n        });\\n    },\\n    async: function (generatorFn) {\\n        return function () {\\n            try {\\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\\n                if (!rv || typeof rv.then !== 'function')\\n                    return Promise.resolve(rv);\\n                return rv;\\n            }\\n            catch (e) {\\n                return rejection(e);\\n            }\\n        };\\n    },\\n    spawn: function (generatorFn, args, thiz) {\\n        try {\\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\\n            if (!rv || typeof rv.then !== 'function')\\n                return Promise.resolve(rv);\\n            return rv;\\n        }\\n        catch (e) {\\n            return rejection(e);\\n        }\\n    },\\n    \\u002F\\u002F Dexie.currentTransaction property\\n    currentTransaction: {\\n        get: function () { return PSD.trans || null; }\\n    },\\n    waitFor: function (promiseOrFunction, optionalTimeout) {\\n        \\u002F\\u002F If a function is provided, invoke it and pass the returning value to Transaction.waitFor()\\n        var promise = Promise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction)\\n            .timeout(optionalTimeout || 60000); \\u002F\\u002F Default the timeout to one minute. Caller may specify Infinity if required.       \\n        \\u002F\\u002F Run given promise on current transaction. If no current transaction, just return a Dexie promise based\\n        \\u002F\\u002F on given value.\\n        return PSD.trans ? PSD.trans.waitFor(promise) : promise;\\n    },\\n    \\u002F\\u002F Export our Promise implementation since it can be handy as a standalone Promise implementation\\n    Promise: Promise,\\n    \\u002F\\u002F Dexie.debug proptery:\\n    \\u002F\\u002F Dexie.debug = false\\n    \\u002F\\u002F Dexie.debug = true\\n    \\u002F\\u002F Dexie.debug = \\\"dexie\\\" - don't hide dexie's stack frames.\\n    debug: {\\n        get: function () { return debug; },\\n        set: function (value) {\\n            setDebug(value, value === 'dexie' ? function () { return true; } : dexieStackFrameFilter);\\n        }\\n    },\\n    \\u002F\\u002F Export our derive\\u002Fextend\\u002Foverride methodology\\n    derive: derive,\\n    extend: extend,\\n    props: props,\\n    override: override,\\n    \\u002F\\u002F Export our Events() function - can be handy as a toolkit\\n    Events: Events,\\n    \\u002F\\u002F Utilities\\n    getByKeyPath: getByKeyPath,\\n    setByKeyPath: setByKeyPath,\\n    delByKeyPath: delByKeyPath,\\n    shallowClone: shallowClone,\\n    deepClone: deepClone,\\n    getObjectDiff: getObjectDiff,\\n    asap: asap,\\n    maxKey: maxKey,\\n    minKey: minKey,\\n    \\u002F\\u002F Addon registry\\n    addons: [],\\n    \\u002F\\u002F Global DB connection list\\n    connections: connections,\\n    MultiModifyError: exceptions.Modify,\\n    errnames: errnames,\\n    \\u002F\\u002F Export other static classes\\n    IndexSpec: IndexSpec,\\n    TableSchema: TableSchema,\\n    \\u002F\\u002F\\n    \\u002F\\u002F Dependencies\\n    \\u002F\\u002F\\n    \\u002F\\u002F These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.\\n    \\u002F\\u002F\\n    \\u002F\\u002F In node.js, however, these properties must be set \\\"manually\\\" before instansiating a new Dexie().\\n    \\u002F\\u002F For node.js, you need to require indexeddb-js or similar and then set these deps.\\n    \\u002F\\u002F\\n    dependencies: {\\n        \\u002F\\u002F Required:\\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\\n    },\\n    \\u002F\\u002F API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.\\n    semVer: DEXIE_VERSION,\\n    version: DEXIE_VERSION.split('.')\\n        .map(function (n) { return parseInt(n); })\\n        .reduce(function (p, c, i) { return p + (c \\u002F Math.pow(10, i * 2)); }),\\n    \\u002F\\u002F https:\\u002F\\u002Fgithub.com\\u002Fdfahlander\\u002FDexie.js\\u002Fissues\\u002F186\\n    \\u002F\\u002F typescript compiler tsc in mode ts--\\u003Ees5 & commonJS, will expect require() to return\\n    \\u002F\\u002F x.default. Workaround: Set Dexie.default = Dexie.\\n    default: Dexie,\\n    \\u002F\\u002F Make it possible to import {Dexie} (non-default import)\\n    \\u002F\\u002F Reason 1: May switch to that in future.\\n    \\u002F\\u002F Reason 2: We declare it both default and named exported in d.ts to make it possible\\n    \\u002F\\u002F to let addons extend the Dexie interface with Typescript 2.1 (works only when explicitely\\n    \\u002F\\u002F exporting the symbol, not just default exporting)\\n    Dexie: Dexie\\n});\\n\\u002F\\u002F Map DOMErrors and DOMExceptions to corresponding Dexie errors. May change in Dexie v2.0.\\nPromise.rejectionMapper = mapError;\\n\\u002F\\u002F Initialize dbNamesDB (won't ever be opened on chromium browsers')\\ndbNamesDB = new Dexie('__dbnames');\\ndbNamesDB.version(1).stores({ dbnames: 'name' });\\n(function () {\\n    \\u002F\\u002F Migrate from Dexie 1.x database names stored in localStorage:\\n    var DBNAMES = 'Dexie.DatabaseNames';\\n    if (typeof localStorage !== undefined && _global.document !== undefined)\\n        try {\\n            \\u002F\\u002F Have localStorage and is not executing in a worker. Lets migrate from Dexie 1.x.\\n            JSON.parse(localStorage.getItem(DBNAMES) || \\\"[]\\\")\\n                .forEach(function (name) { return dbNamesDB.dbnames.put({ name: name }).catch(nop); });\\n            localStorage.removeItem(DBNAMES);\\n        }\\n        catch (_e) { }\\n})();\\n\\n\\u002F* harmony default export *\\u002F __webpack_exports__[\\\"default\\\"] = (Dexie);\\n\\u002F\\u002F# sourceMappingURL=dexie.es.js.map\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 57 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nvar v1 = __webpack_require__(58);\\nvar v4 = __webpack_require__(60);\\n\\nvar uuid = v4;\\nuuid.v1 = v1;\\nuuid.v4 = v4;\\n\\nmodule.exports = uuid;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 58 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nvar rng = __webpack_require__(9);\\nvar bytesToUuid = __webpack_require__(10);\\n\\n\\u002F\\u002F **`v1()` - Generate time-based UUID**\\n\\u002F\\u002F\\n\\u002F\\u002F Inspired by https:\\u002F\\u002Fgithub.com\\u002FLiosK\\u002FUUID.js\\n\\u002F\\u002F and http:\\u002F\\u002Fdocs.python.org\\u002Flibrary\\u002Fuuid.html\\n\\nvar _nodeId;\\nvar _clockseq;\\n\\n\\u002F\\u002F Previous uuid creation time\\nvar _lastMSecs = 0;\\nvar _lastNSecs = 0;\\n\\n\\u002F\\u002F See https:\\u002F\\u002Fgithub.com\\u002Fbroofa\\u002Fnode-uuid for API details\\nfunction v1(options, buf, offset) {\\n  var i = buf && offset || 0;\\n  var b = buf || [];\\n\\n  options = options || {};\\n  var node = options.node || _nodeId;\\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\\n\\n  \\u002F\\u002F node and clockseq need to be initialized to random values if they're not\\n  \\u002F\\u002F specified.  We do this lazily to minimize issues related to insufficient\\n  \\u002F\\u002F system entropy.  See #189\\n  if (node == null || clockseq == null) {\\n    var seedBytes = rng();\\n    if (node == null) {\\n      \\u002F\\u002F Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\\n      node = _nodeId = [\\n        seedBytes[0] | 0x01,\\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\\n      ];\\n    }\\n    if (clockseq == null) {\\n      \\u002F\\u002F Per 4.2.2, randomize (14 bit) clockseq\\n      clockseq = _clockseq = (seedBytes[6] \\u003C\\u003C 8 | seedBytes[7]) & 0x3fff;\\n    }\\n  }\\n\\n  \\u002F\\u002F UUID timestamps are 100 nano-second units since the Gregorian epoch,\\n  \\u002F\\u002F (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\\n  \\u002F\\u002F time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\\n  \\u002F\\u002F (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\\n\\n  \\u002F\\u002F Per 4.2.1.2, use count of uuid's generated during the current clock\\n  \\u002F\\u002F cycle to simulate higher resolution clock\\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\\n\\n  \\u002F\\u002F Time since last uuid creation (in msecs)\\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)\\u002F10000;\\n\\n  \\u002F\\u002F Per 4.2.1.2, Bump clockseq on clock regression\\n  if (dt \\u003C 0 && options.clockseq === undefined) {\\n    clockseq = clockseq + 1 & 0x3fff;\\n  }\\n\\n  \\u002F\\u002F Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\\n  \\u002F\\u002F time interval\\n  if ((dt \\u003C 0 || msecs \\u003E _lastMSecs) && options.nsecs === undefined) {\\n    nsecs = 0;\\n  }\\n\\n  \\u002F\\u002F Per 4.2.1.2 Throw error if too many uuids are requested\\n  if (nsecs \\u003E= 10000) {\\n    throw new Error('uuid.v1(): Can\\\\'t create more than 10M uuids\\u002Fsec');\\n  }\\n\\n  _lastMSecs = msecs;\\n  _lastNSecs = nsecs;\\n  _clockseq = clockseq;\\n\\n  \\u002F\\u002F Per 4.1.4 - Convert from unix epoch to Gregorian epoch\\n  msecs += 12219292800000;\\n\\n  \\u002F\\u002F `time_low`\\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\\n  b[i++] = tl \\u003E\\u003E\\u003E 24 & 0xff;\\n  b[i++] = tl \\u003E\\u003E\\u003E 16 & 0xff;\\n  b[i++] = tl \\u003E\\u003E\\u003E 8 & 0xff;\\n  b[i++] = tl & 0xff;\\n\\n  \\u002F\\u002F `time_mid`\\n  var tmh = (msecs \\u002F 0x100000000 * 10000) & 0xfffffff;\\n  b[i++] = tmh \\u003E\\u003E\\u003E 8 & 0xff;\\n  b[i++] = tmh & 0xff;\\n\\n  \\u002F\\u002F `time_high_and_version`\\n  b[i++] = tmh \\u003E\\u003E\\u003E 24 & 0xf | 0x10; \\u002F\\u002F include version\\n  b[i++] = tmh \\u003E\\u003E\\u003E 16 & 0xff;\\n\\n  \\u002F\\u002F `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\\n  b[i++] = clockseq \\u003E\\u003E\\u003E 8 | 0x80;\\n\\n  \\u002F\\u002F `clock_seq_low`\\n  b[i++] = clockseq & 0xff;\\n\\n  \\u002F\\u002F `node`\\n  for (var n = 0; n \\u003C 6; ++n) {\\n    b[i + n] = node[n];\\n  }\\n\\n  return buf ? buf : bytesToUuid(b);\\n}\\n\\nmodule.exports = v1;\\n\\n\\n\\u002F***\\u002F }),\\n\\u002F* 59 *\\u002F\\n\\u002F***\\u002F (function(module, exports) {\\n\\nmodule.exports = require(\\\"crypto\\\");\\n\\n\\u002F***\\u002F }),\\n\\u002F* 60 *\\u002F\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nvar rng = __webpack_require__(9);\\nvar bytesToUuid = __webpack_require__(10);\\n\\nfunction v4(options, buf, offset) {\\n  var i = buf && offset || 0;\\n\\n  if (typeof(options) == 'string') {\\n    buf = options === 'binary' ? new Array(16) : null;\\n    options = null;\\n  }\\n  options = options || {};\\n\\n  var rnds = options.random || (options.rng || rng)();\\n\\n  \\u002F\\u002F Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\\n\\n  \\u002F\\u002F Copy bytes to buffer, if provided\\n  if (buf) {\\n    for (var ii = 0; ii \\u003C 16; ++ii) {\\n      buf[i + ii] = rnds[ii];\\n    }\\n  }\\n\\n  return buf || bytesToUuid(rnds);\\n}\\n\\nmodule.exports = v4;\\n\\n\\n\\u002F***\\u002F })\\n],[13]);\"}","integrity":"sha512-bQB1yFpCIu5enwvGmC1bQnoUNsBq5JhPtk8z319bjAoMjYbk9nq5vBSsDkwhq+G/SRkso0rwQ/RXeE7DT/W/tg==","time":1523799633282,"size":131583}